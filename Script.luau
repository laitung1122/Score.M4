local ImportGlobals
local ClosureBindings = {
    function()local wax,script,require=ImportGlobals(1)local ImportGlobals return (function(...)if getgenv().mspaint_loading then print("[Dương Api] Đã dừng tải(lỗi)"); return end
if getgenv().mspaint_loaded then print("[Dương Api] Không thể tải lại script khi đã chạy"); return end
getgenv().mspaint_loading = true
if not game:IsLoaded() then game.Loaded:Wait() end
--// Services \\--
local Services = require("Utils/Services")
Services:GetServices({
    "Players",
    "UserInputService",
    "TextChatService",
    "ProximityPromptService",
    "PathfindingService",
    "CoreGui",
    "StarterGui",
    "Workspace",
    "Lighting",
    "ReplicatedStorage",
    "HttpService",
    "RunService",
    "SoundService",
    "TeleportService",
    "TweenService",
    "MarketplaceService"
})
if not wax.shared.ExecutorSupport then
    wax.shared.ExecutorSupport = require("Utils/ExecutorSupport")
end
if not wax.shared.BloxstrapRPC then
    wax.shared.BloxstrapRPC = require("Utils/BloxstrapRPC")
end
if not wax.shared.FileHelper then
    wax.shared.FileHelper = require("Utils/FileHelper")
end
if not wax.shared.GotPlace then
    wax.shared.GotPlace = true
    shared.ScriptName = "Universal"
    shared.ScriptLoader = "Universal"   
    local Mappings = require("Mappings") 
    local MappingID = Mappings[game.GameId]
    if MappingID then
        local Folder = MappingID["Folder"]
        local Name = MappingID["Name"] or Folder
        local GameExclusions = MappingID["Exclusions"] or {}
        local Exclusion = GameExclusions[game.PlaceId]        
        shared.ScriptName = Name
        shared.ScriptLoader = Folder .. "/" .. MappingID["Main"]
        shared.Mapping = MappingID
        shared.ScriptFolder = Folder
        shared.ScriptExclusion = Exclusion    
        if Exclusion then
            shared.ScriptName = Name .. " (" .. Exclusion .. ")"
            shared.ScriptLoader = Folder .. "/" .. Exclusion
        end
    end
end
shared.Script = {
    Functions = {}
}
shared.Hooks = {}
shared.Script.Functions.EnforceTypes = function(args, template)
    args = if typeof(args) == "table" then args else {}
    for key, value in pairs(template) do
        local argValue = args[key]
        if argValue == nil or (value ~= nil and typeof(argValue) ~= typeof(value)) then
            args[key] = value
        elseif typeof(value) == "table" then
            args[key] = shared.Script.Functions.EnforceTypes(argValue, value)
        end
    end
    return args
end
shared.Load = require("Utils/Loader")
shared.Logs = require("Utils/Logs")
shared.Connect = require("Utils/Connections")
shared.Camera = workspace.CurrentCamera
shared.LocalPlayer = shared.Players.LocalPlayer
shared.PlayerGui = shared.LocalPlayer.PlayerGui
shared.PlayerScripts = shared.LocalPlayer.PlayerScripts
shared.Fly = require("Utils/Universal/Fly")
shared.Twerk = require("Utils/Universal/Twerk")
shared.ControlModule = require("Utils/Universal/ControlModule")
local TextChannels = shared.TextChatService:FindFirstChild("TextChannels")
if TextChannels and TextChannels:FindFirstChild("RBXGeneral") then
    shared.RBXGeneral = TextChannels.RBXGeneral
end
local UICreator = require("Utils/GUI/Creator")
shared.Window = UICreator:CreateWindow()
require("Places/Loaders/" .. shared.ScriptLoader)
UICreator:CreateSettingsTab()
require("Utils/GUI/addons")
shared.Notify:Alert({
    Title = "Dương Api",
    Description = "Cảm ơn vì đã sài dự án"
})
getgenv().mspaint_loading = false
end)() end,
    function()local wax,script,require=ImportGlobals(2)local ImportGlobals return (function(...)return {
    [2440500124] = {
        ["Folder"] = "Doors",
        ["Main"] = "Doors",
        ["Name"] = "DOORS",
        ["Exclusions"] = {
            [6516141723] = "Lobby",
            [12308344607] = "Lobby"
        }
    },
    [2091953627] = {
        ["Folder"] = "R&D",
        ["Main"] = "R&D",
        ["Name"] = "R&D"
    }
}
end)() end,
    [6] = function()local wax,script,require=ImportGlobals(6)local ImportGlobals return (function(...)
if shared.LocalPlayer and shared.LocalPlayer.PlayerGui:FindFirstChild("LoadingUI") and shared.LocalPlayer.PlayerGui.LoadingUI.Enabled then
    print("[Dương Api] Đang chờ game tải...")
    repeat task.wait() until not shared.LocalPlayer.PlayerGui:FindFirstChild("LoadingUI") and true or not shared.LocalPlayer.PlayerGui.LoadingUI.Enabled
end
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
Script.FeatureConnections = {
    Character = {},
    Clip = {},
    Door = {},
    Humanoid = {},
    Player = {},
    Pump = {},
    RootPart = {},
}
Script.ESPTable = {
    Chest = {},
    Door = {},
    Entity = {},
    SideEntity = {},
    Gold = {},
    Guiding = {},
    DroppedItem = {},
    Item = {},
    Objective = {},
    Player = {},
    HidingSpot = {},
    None = {}
}
Script.Functions.Minecart = {
    pathfindQueue = {},
    Pathfind = function(...) return true end,
    Teleport = function(...) return true end,
    DrawNodes = function(...) return true end,
    debug = function(...)
        print(...)
        local msg = {}
        for _, v in pairs({ ... }) do
            table.insert(msg, tostring(v))
        end
         shared.Notify:Alert({
         Title = "[Hệ thống]",
         Description = table.concat(msg, " "),
         Reason = ""
        })
    end
}
Script.Temp = {
    AnchorFinished = {},
    AutoWardrobeEntities = {},
    Bridges = {},
    PipeBridges = {},
    CollisionSize = Vector3.new(5.5, 3, 3),
    Guidance = {},
    PaintingDebounce = {},
    UsedBreakers = {},
    VoidGlitchNotifiedRooms = {}
}
Script.FakeRevive = {
    Debounce = false,
    Enabled = false,
    Connections = {}
}
Script.NoCharRaycastParam = RaycastParams.new()
Script.NoCharRaycastParam.FilterType = Enum.RaycastFilterType.Exclude
Script.WhitelistConfig = {
    [45] = {firstKeep = 3, lastKeep = 2},
    [46] = {firstKeep = 2, lastKeep = 2},
    [47] = {firstKeep = 2, lastKeep = 2},
    [48] = {firstKeep = 2, lastKeep = 2},
    [49] = {firstKeep = 2, lastKeep = 4},
}
Script.SuffixPrefixes = {
    ["Backdoor"] = "",
    ["Ceiling"] = "",
    ["Moving"] = "",
    ["Ragdoll"] = "",
    ["Rig"] = "",
    ["Wall"] = "",
    ["Clock"] = " Clock",
    ["Key"] = " Key",
    ["Pack"] = " Pack",
    ["Pointer"] = " Pointer",
    ["Swarm"] = " Swarm",
}
Script.PrettyFloorName = {
    ["Fools"] = "Super Hard Mode",
    ["Retro"] = "Retro Mode"
}
Script.FloorImages = {
    ["Hotel"] = 16875079348,
    ["Mines"] = 138779629462354,
    ["Retro"] = 16992279648,
    ["Rooms"] = 16874821428,
    ["Fools"] = 17045908353,
    ["Backdoor"] = 16874352892
}
Script.EntityTable = {
    ["Names"] = {"BackdoorRush", "BackdoorLookman", "RushMoving", "AmbushMoving", "Eyes", "JeffTheKiller", "Dread", "A60", "A120"},
    ["SideNames"] = {"FigureRig", "GiggleCeiling", "GrumbleRig", "Snare"},
    ["ShortNames"] = {
        ["BackdoorRush"] = "Blitz",
        ["JeffTheKiller"] = "Jeff The Killer"
    },
    ["NotifyMessage"] = {
        ["GloombatSwarm"] = "Gloombats in next room!"
    },
    ["Avoid"] = {
        "RushMoving",
        "AmbushMoving"
    },
    ["NotifyReason"] = {
        ["A60"] = {
            ["Image"] = "12350986086",
        },
        ["A120"] = {
            ["Image"] = "12351008553",
        },
        ["BackdoorRush"] = {
            ["Image"] = "11102256553",
        },
        ["RushMoving"] = {
            ["Image"] = "11102256553",
        },
        ["AmbushMoving"] = {
            ["Image"] = "10938726652",
        },
        ["Eyes"] = {
            ["Image"] = "10865377903",
            ["Spawned"] = true
        },
        ["BackdoorLookman"] = {
            ["Image"] = "16764872677",
            ["Spawned"] = true
        },
        ["JeffTheKiller"] = {
            ["Image"] = "98993343",
            ["Spawned"] = true
        },
        ["GloombatSwarm"] = {
            ["Image"] = "79221203116470",
            ["Spawned"] = true
        },
        ["HaltRoom"] = {
            ["Image"] = "11331795398",
            ["Spawned"] = true
        }
    },
    ["NoCheck"] = {
        "Eyes",
        "BackdoorLookman",
        "JeffTheKiller"
    },
    ["InfCrucifixVelocity"] = {
        ["RushMoving"] = {
            threshold = 52,
            minDistance = 55,
        },
        ["RushNew"] = {
            threshold = 52,
            minDistance = 55,
        },    
        ["AmbushMoving"] = {
            threshold = 70,
            minDistance = 80,
        }
    },
    ["AutoWardrobe"] = {
        ["Entities"] = {
            "RushMoving",
            "AmbushMoving",
            "BackdoorRush",
            "A60",
            "A120",
        },
        ["Distance"] = {
            ["RushMoving"] = {
                Distance = 100,
                Loader = 175
            },
            ["BackdoorRush"] = {
                Distance = 100,
                Loader = 175
            },
            ["AmbushMoving"] = {
                Distance = 155,
                Loader = 200
            },
            ["A60"] = {
                Distance = 200,
                Loader = 200
            },
            ["A120"] = {
                Distance = 200,
                Loader = 200
            }
        }
    }
}
Script.HidingPlaceName = {
    ["Hotel"] = "Closet",
    ["Backdoor"] = "Closet",
    ["Fools"] = "Closet",
    ["Retro"] = "Closet",
    ["Rooms"] = "Locker",
    ["Mines"] = "Locker"
}
Script.CutsceneExclude = {
    "FigureHotelChase",
    "Elevator1",
    "MinesFinale"
}
Script.SlotsName = {
    "Oval",
    "Square",
    "Tall",
    "Wide"
}
Script.PromptTable = {
    GamePrompts = {},
    Aura = {
        ["ActivateEventPrompt"] = false,
        ["AwesomePrompt"] = true,
        ["FusesPrompt"] = true,
        ["HerbPrompt"] = false,
        ["LeverPrompt"] = true,
        ["LootPrompt"] = false,
        ["ModulePrompt"] = true,
        ["SkullPrompt"] = false,
        ["UnlockPrompt"] = true,
        ["ValvePrompt"] = false,
        ["PropPrompt"] = true
    },
    AuraObjects = {
        "Lock",
        "Button"
    },
    Clip = {
        "AwesomePrompt",
        "FusesPrompt",
        "HerbPrompt",
        "HidePrompt",
        "LeverPrompt",
        "LootPrompt",
        "ModulePrompt",
        "Prompt",
        "PushPrompt",
        "SkullPrompt",
        "UnlockPrompt",
        "ValvePrompt"
    },
    ClipObjects = {
        "LeverForGate",
        "LiveBreakerPolePickup",
        "LiveHintBook",
        "Button",
    },
    Excluded = {
        Prompt = {
            "HintPrompt",
            "InteractPrompt"
        },
        Parent = {
            "KeyObtainFake",
            "Padlock"
        },
        ModelAncestor = {
            "DoorFake"
        }
    }
}
Script.HideTimeValues = {
    {min = 1, max = 5, a = -1/6, b = 1, c = 20},
    {min = 6, max = 19, a = -1/13, b = 6, c = 19},
    {min = 19, max = 22, a = -1/4, b = 19, c = 18},
    {min = 23, max = 26, a = 1/3, b = 23, c = 18},
    {min = 26, max = 30, a = -1/4, b = 26, c = 19},
    {min = 30, max = 35, a = -1/3, b = 30, c = 18},
    {min = 36, max = 60, a = -1/12, b = 36, c = 18},
    {min = 60, max = 90, a = -1/30, b = 60, c = 16},
    {min = 90, max = 99, a = -1/6, b = 90, c = 15}
}
Script.VoidThresholdValues = {
    ["Hotel"] = 3,
    ["Mines"] = 3,
    ["Retro"] = 3,
    ["Rooms"] = 4,
    ["Fools"] = 3,
    ["Backdoor"] = 2,
}
Script.MinecartPathNodeColor = {
    Disabled = nil,
    Red = Color3.new(1, 0, 0),
    Yellow = Color3.new(1, 1, 0),
    Purple = Color3.new(1, 0, 1),
    Green = Color3.new(0, 1, 0),
    Cyan = Color3.new(0, 1, 1),
    Orange = Color3.new(1, 0.5, 0),
    White = Color3.new(1, 1, 1),
}
Script.Anims = {}
Script.Anims.HoldAnim = Instance.new("Animation"); Script.Anims.HoldAnim.AnimationId = "rbxassetid://10479585177"
Script.Anims.ThrowAnim = Instance.new("Animation"); Script.Anims.ThrowAnim.AnimationId = "rbxassetid://10482563149"
Script.Tracks = {
    ItemHoldTrack = nil,
    ItemThrowTrack = nil,
}
function Script.Functions.Warn(message: string)
    warn("Cảnh báo - DươngApi:", message)
end
Script._mspaint_custom_captions = Instance.new("ScreenGui"); do
    local Frame = Instance.new("Frame", Script._mspaint_custom_captions)
    local TextLabel = Instance.new("TextLabel", Frame)
    local UITextSizeConstraint = Instance.new("UITextSizeConstraint", TextLabel)
    Script._mspaint_custom_captions.Parent = shared.ReplicatedStorage
    Script._mspaint_custom_captions.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Frame.AnchorPoint = Vector2.new(0.5, 0.5)
    Frame.BackgroundColor3 = shared.Library.MainColor
    Frame.BorderColor3 = shared.Library.AccentColor
    Frame.BorderSizePixel = 2
    Frame.Position = UDim2.new(0.5, 0, 0.8, 0)
    Frame.Size = UDim2.new(0, 200, 0, 75)
    shared.Library:AddToRegistry(Frame, {
        BackgroundColor3 = "MainColor",
        BorderColor3 = "AccentColor"
    })
    TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    TextLabel.BackgroundTransparency = 1.000
    TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
    TextLabel.BorderSizePixel = 0
    TextLabel.Size = UDim2.new(1, 0, 1, 0)
    TextLabel.Font = Enum.Font.Code
    TextLabel.Text = ""
    TextLabel.TextColor3 = shared.Library.FontColor
    TextLabel.TextScaled = true
    TextLabel.TextSize = 14
    TextLabel.TextWrapped = true
    shared.Library:AddToRegistry(TextLabel, {
        TextColor3 = "FontColor"
    })
    UITextSizeConstraint.MaxTextSize = 35
    local IsCaptionHidden = true
    local CaptionsLastUsed = os.time()   
    function Script.Functions.HideCaptions()
        IsCaptionHidden = true
        Script._mspaint_custom_captions.Parent = shared.ReplicatedStorage
    end
    function Script.Functions.Captions(caption: string)
        CaptionsLastUsed = os.time()
        if IsCaptionHidden then
            local success = pcall(function()
                Script._mspaint_custom_captions.Parent = if gethui then gethui() else shared.CoreGui
            end)
            if not success then
                Script._mspaint_custom_captions.Parent = shared.PlayerGui
            end 
            IsCaptionHidden = false
        end        
        TextLabel.Text = caption
        task.spawn(function()
            task.wait(5)
            if os.time() - CaptionsLastUsed >= 5 then
                Script.Functions.HideCaptions()
            end
        end)
    end
end
function Script.Functions.RandomString()
    local length = math.random(10,20)
    local array = {}
    for i = 1, length do
        array[i] = string.char(math.random(32, 126))
    end
    return table.concat(array)
end
function Script.Functions.NotifyGlitch()
    if Options.NotifyEntity.Value["Void/Glitch"] and Script.LatestRoom.Value > Script.CurrentRoom + Script.VoidThresholdValues[Script.Floor.Value] and Script.Alive and not table.find(Script.Temp.VoidGlitchNotifiedRooms, Script.CurrentRoom) then
        table.insert(Script.Temp.VoidGlitchNotifiedRooms, Script.CurrentRoom)
        local message = "Void/Glitch sẽ đến khi cánh cửa tiếp theo được mở ra."
        if Script.IsRooms then
            local roomsLeft = (6 - (Script.LatestRoom.Value - Script.CurrentRoom))
            message = "Void/Glitch sẽ đến " .. (if roomsLeft == 0 then "khi cánh cửa tiếp theo đã mở." else "trong " .. roomsLeft .. " phòng") .. "."
        end
        shared.Notify:Alert({
            Title = "ENTITIES",
            Description = message,
            Reason = "Sang phòng tiếp theo để né tránh nó.",
            Warning = true
        })
    end
end
function Script.Functions.UpdateRPC()
    if not wax.shared.BloxstrapRPC then return end
    local roomNumberPrefix = "Room "
    local prettifiedRoomNumber = Script.CurrentRoom
    if Script.IsBackdoor then
        prettifiedRoomNumber = -50 + Script.CurrentRoom
    end
    if Script.IsMines then
        prettifiedRoomNumber += 100
    end
    prettifiedRoomNumber = tostring(prettifiedRoomNumber)
    if Script.IsRooms then
        roomNumberPrefix = "A-"
        prettifiedRoomNumber = string.format("%03d", prettifiedRoomNumber)
    end
    wax.shared.BloxstrapRPC.SetRichPresence({
        details = "Chơi Doors [ Dương Api V2 ]",
        state = roomNumberPrefix .. prettifiedRoomNumber .. " (" .. if Script.PrettyFloorName[Script.Floor.Value] then Script.PrettyFloorName[Script.Floor.Value] else ("The " .. Script.Floor.Value)  .. ")",
        largeImage = {
            assetId = Script.FloorImages[Script.Floor.Value] or 16875079348,
            hoverText = "Sử dụng Dương Api V2"
        },
        smallImage = {
            assetId = 6925817108,
            hoverText = shared.LocalPlayer.Name
        }
    })
end
shared.Character = shared.LocalPlayer.Character or shared.LocalPlayer.CharacterAdded:Wait()
shared.Humanoid = nil
Script.Collision = nil
Script.CollisionClone = nil
Script.Alive = shared.LocalPlayer:GetAttribute("Alive")
Script.EntityModules = shared.ReplicatedStorage:WaitForChild("ClientModules"):WaitForChild("EntityModules")
Script.GameData = shared.ReplicatedStorage:WaitForChild("GameData")
Script.Floor = Script.GameData:WaitForChild("Floor")
Script.LatestRoom = Script.GameData:WaitForChild("LatestRoom")
Script.LiveModifiers = shared.ReplicatedStorage:WaitForChild("LiveModifiers")
Script.Voicelines = {}
if shared.ReplicatedStorage:FindFirstChild("VoiceActing") and shared.ReplicatedStorage.VoiceActing:FindFirstChild("Voicelines") then
    for _, voiceline: Sound in pairs(shared.ReplicatedStorage.VoiceActing.Voicelines:GetDescendants()) do
        if not voiceline:IsA("Sound") then continue end
        table.insert(Script.Voicelines, voiceline.SoundId)
    end
end
Script.IsMines = Script.Floor.Value == "Mines"
Script.IsRooms = Script.Floor.Value == "Rooms"
Script.IsHotel = Script.Floor.Value == "Hotel"
Script.IsBackdoor = Script.Floor.Value == "Backdoor"
Script.IsFools = Script.Floor.Value == "Fools"
Script.IsRetro = Script.Floor.Value == "Retro"
Script.FloorReplicated = if not Script.IsFools then shared.ReplicatedStorage:WaitForChild("FloorReplicated") else nil
Script.RemotesFolder = if not Script.IsFools then shared.ReplicatedStorage:WaitForChild("RemotesFolder") else shared.ReplicatedStorage:WaitForChild("EntityInfo")
Script.CurrentRoom = shared.LocalPlayer:GetAttribute("CurrentRoom") or 0
if not workspace.CurrentRooms:FindFirstChild(tostring(Script.CurrentRoom)) then
    Script.CurrentRoom = Script.LatestRoom.Value
    shared.LocalPlayer:SetAttribute("CurrentRoom", Script.CurrentRoom)
end
Script.NextRoom = Script.CurrentRoom + 1
Script.MainUI = shared.PlayerGui:WaitForChild("MainUI")
Script.MainGame = Script.MainUI:WaitForChild("Initiator"):WaitForChild("Main_Game")
Script.MainGameSrc = if wax.shared.ExecutorSupport["require"] then wax.require(Script.MainGame) else nil
Script.SpeedBypassing = false
Script.LastSpeed = 0
Script.Bypassed = false
shared.Load("Utils", "Player")
shared.Load("Utils", "ESP")
shared.Load("Utils", "Assets")
shared.Load("Utils", "Entities")
shared.Load("Utils", "AutoWardrobe")
shared.Load("Utils", "BreakerBox")
shared.Load("Utils", "Padlock")
shared.Load("Utils", "Minecarts")
shared.Load("Utils", "ConnectionsFuncs")
Script.Tabs = {
    Main = shared.Window:AddTab("Chính"),
    Exploits = shared.Window:AddTab("Tính năng"),
    Visuals = shared.Window:AddTab("Tầm nhìn"),
    Floor = shared.Window:AddTab("Thêm")
}
shared.Load("Tabs", "Main")
shared.Load("Tabs", "Exploits")
shared.Load("Tabs", "Visuals")
task.spawn(shared.Load, "Tabs", "Floor")
if wax.shared.ExecutorSupport["hookmetamethod"] and wax.shared.ExecutorSupport["getnamecallmethod"] then
    shared.Hooks.mtHook = hookmetamethod(game, "__namecall", function(self, ...)
        local args = {...}
        local namecallMethod = getnamecallmethod()
        if namecallMethod == "FireServer" then
            if self.Name == "ClutchHeartbeat" and Toggles.AutoHeartbeat.Value then
                return
            elseif self.Name == "Crouch" and Toggles.AntiHearing.Value then
                args[1] = true
                return shared.Hooks.mtHook(self, unpack(args))
            end
        elseif namecallMethod == "Destroy" and self.Name == "RunnerNodes" then
            return
        end
        return shared.Hooks.mtHook(self, ...)
    end)
end
shared.Connect:GiveSignal(shared.ProximityPromptService.PromptTriggered:Connect(function(prompt, player)
    if not Toggles.InfItems.Value or player ~= shared.LocalPlayer or not shared.Character or Script.IsFools then return end
    local isDoorLock = prompt.Name == "UnlockPrompt" and prompt.Parent.Name == "Lock" and not prompt.Parent.Parent:GetAttribute("Opened")
    local isSkeletonDoor = prompt.Name == "SkullPrompt" and prompt.Parent.Name == "SkullLock" and not (prompt.Parent:FindFirstChild("Door") and prompt.Parent.Door.Transparency == 1)
    local isChestBox = prompt.Name == "ActivateEventPrompt" and prompt.Parent:GetAttribute("Locked") and (prompt.Parent.Name:match("Chest") or prompt.Parent:GetAttribute("LockAttribute") == "CanCutVines" or prompt.Parent.Name == "CuttableVines")
    local isRoomsDoorLock = prompt.Parent.Parent.Parent.Name == "RoomsDoor_Entrance" and prompt.Enabled
    if isDoorLock or isSkeletonDoor or isChestBox or isRoomsDoorLock then
        local equippedTool = shared.Character:FindFirstChildOfClass("Tool")
        if equippedTool and (equippedTool:GetAttribute("UniversalKey") or equippedTool:GetAttribute("CanCutVines")) then
            if not isChestBox then task.wait() end
            Script.RemotesFolder.DropItem:FireServer(equippedTool)
            task.spawn(function()
                workspace.Drops.ChildAdded:Wait()
                task.wait(0.05)
                local itemPickupPrompt = Script.Functions.GetNearestPromptWithCondition(function(prompt)
                    return prompt.Name == "ModulePrompt" and prompt:IsDescendantOf(workspace.Drops)
                end)
                if itemPickupPrompt then
                    if isChestBox then
                        shared.fireproximityprompt(prompt)
                    end
                    shared.fireproximityprompt(itemPickupPrompt)
                end
            end)
        end
    end
end))
shared.Connect:GiveSignal(workspace.ChildAdded:Connect(function(child)
    if not child:IsA("Model") then return end
    task.delay(0.1, function()
        local shortName = Script.Functions.GetShortName(child.Name)
        if table.find(Script.EntityTable.Names, child.Name) then
            task.spawn(function()
                repeat
                    task.wait()
                until Script.Functions.DistanceFromCharacter(child) < 750 or not child:IsDescendantOf(workspace)
                if child:IsDescendantOf(workspace) then
                    if Script.IsHotel and Toggles.AvoidRushAmbush.Value and table.find(Script.EntityTable.Avoid, child.Name) then
                        local oldNoclip = Toggles.Noclip.Value
                        local distance = Script.Functions.DistanceFromCharacter(child)
                        task.spawn(function()
                            repeat 
                                shared.RunService.Heartbeat:Wait()
                                distance = Script.Functions.DistanceFromCharacter(child)
                            until distance <= 150 or not child:IsDescendantOf(workspace)
                            if child:IsDescendantOf(workspace) then
                                Script.Functions.AvoidEntity(true)
                                repeat task.wait() until not child:IsDescendantOf(workspace)
                                Script.Functions.AvoidEntity(false, oldNoclip)
                            end
                        end)
                    end
                    if table.find(Script.EntityTable.AutoWardrobe.Entities, child.Name) then
                        local distance = Script.EntityTable.AutoWardrobe.Distance[child.Name].Loader
                        task.spawn(function()
                            repeat shared.RunService.Heartbeat:Wait() until not child:IsDescendantOf(workspace) or Script.Functions.DistanceFromCharacter(child) <= distance
                            if child:IsDescendantOf(workspace) and Toggles.AutoWardrobe.Value then
                                Script.Functions.AutoWardrobe(child)
                            end
                        end)
                    end
                    if Script.IsFools and child.Name == "RushMoving" then
                        shortName = child.PrimaryPart.Name:gsub("New", "")
                    end
                    if Toggles.EntityESP.Value then
                        Script.Functions.EntityESP(child)  
                    end
                    if Options.NotifyEntity.Value[shortName] then
                        shared.Notify:Alert({
                            Title = "Thần tài đến",
                            Description = string.format("%s %s", shortName, Options.NotifyEntityMessage.Value),
                            Reason = (not Script.EntityTable.NotifyReason[child.Name].Spawned and "Tìm chỗ trốn nhanh còn kịp :))!" or nil),
                            Image = Script.EntityTable.NotifyReason[child.Name].Image,
                            Warning = true
                        })
                        if Toggles.NotifyChat.Value then
                            shared.RBXGeneral:SendAsync(string.format("%s %s", shortName, Options.NotifyEntityMessage.Value))
                        end
                    end
                end
            end)
        elseif Script.EntityTable.NotifyMessage[child.Name] and Options.NotifyEntity.Value[shortName] then
            shared.Notify:Alert({
                Title = "Thần tài đến",
                Description = string.format("%s %s", shortName, Options.NotifyEntityMessage.Value),
                Reason = (not Script.EntityTable.NotifyReason[child.Name].Spawned and "Tìm chỗ trốn nhanh còn kịp :))!" or nil),
                Image = Script.EntityTable.NotifyReason[child.Name].Image,
                Warning = true
            })
            if Toggles.NotifyChat.Value then
                shared.RBXGeneral:SendAsync(Script.EntityTable.NotifyMessage[child.Name])     
            end
        end
        if Script.IsFools then
            if Toggles.AntiBananaPeel.Value and child.Name == "BananaPeel" then
                child.CanTouch = false
            end
            if Toggles.AntiJeffClient.Value and child.Name == "JeffTheKiller" then
                for i, v in pairs(child:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v.CanTouch = false
                    end
                end
            end
            if Toggles.AntiJeffServer.Value and child.Name == "JeffTheKiller" then
                task.spawn(function()
                    repeat task.wait() until shared.isnetworkowner(child.PrimaryPart)
                    child:FindFirstChildOfClass("Humanoid").Health = 0
                end)
            end
        end
        if (child.Name == "RushMoving" or child.Name == "AmbushMoving") and Toggles.InfCrucifix.Value and Script.Alive and shared.Character then
            task.wait(1.5)
            local hasStoppedMoving = false --entity has stoped
            local lastPosition = child:GetPivot().Position
            local lastVelocity = Vector3.new(0, 0, 0)
            local frameCount = 0
            local nextTimer = tick()
            local maxSavedFrames = 10 --after that we can ignore velocity by 0
            local currentSavedFrames = 0
            local physicsTickRate = (1 / 60) * 0.90 --usually is stable also wtf roblox why 60 Hz isn't (1 / 60) ????
            local oldFrameHz = 0
            local frameHz = 0
            local frameRate = 1 -- in seconds
            local nextTimerHz = tick()
            local entityName = child.Name
            local crucifixConnection; crucifixConnection = shared.RunService.RenderStepped:Connect(function(deltaTime)
                if not Toggles.InfCrucifix.Value or not Script.Alive or not shared.Character then crucifixConnection:Disconnect() return end
                local currentTimer = tick()
                frameCount += 1 
                frameHz += 1
                -- get the client FPS
                if currentTimer - nextTimerHz >= frameRate then
                    oldFrameHz = frameHz;
                    frameHz = 0
                    nextTimerHz = currentTimer
                    physicsTickRate = (1 / oldFrameHz) * 0.90
                end
                -- refresh rate (client) must be equal to the physics rate (server) for making the calculations properly.
                if physicsTickRate == 0 or not (currentTimer - nextTimer >= physicsTickRate) then
                    return
                end
                frameCount = 0
                nextTimer = currentTimer
                local currentPosition = child:GetPivot().Position
                -- Calculate velocity
                local velocity = (currentPosition - lastPosition) / deltaTime
                velocity = Vector3.new(velocity.X, 0, velocity.Z) -- Ignore Y
                -- Smooth velocity
                local smoothedVelocity = lastVelocity:Lerp(velocity, 0.3) --we do math stuff
                local entityVelocity = math.floor(smoothedVelocity.Magnitude)
                lastVelocity = smoothedVelocity
                lastPosition = currentPosition
                local inView = Script.Functions.IsInViewOfPlayer(child, Script.EntityTable.InfCrucifixVelocity[entityName].minDistance)
                local distanceFromPlayer = (child:GetPivot().Position - shared.Character:GetPivot().Position).Magnitude
                local isInRangeOfPlayer = distanceFromPlayer <= Script.EntityTable.InfCrucifixVelocity[entityName].minDistance
                if currentSavedFrames < maxSavedFrames then
                    print(string.format("[In range: %s | In view: %s] [Hz: %d] - Entity velocity is: %.2f | Distance: %.2f | Delta: %.2f", tostring(isInRangeOfPlayer), tostring(inView), oldFrameHz, entityVelocity, distanceFromPlayer, 0))
                end
                if entityVelocity <= Script.EntityTable.InfCrucifixVelocity[entityName].threshold then
                    if entityVelocity <= 0.5 and currentSavedFrames <= maxSavedFrames then
                        currentSavedFrames += 1
                    end
                    --switch and trigger a print
                    if not hasStoppedMoving then
                        --print("Entity has stopped moving!")
                        hasStoppedMoving = true
                    end
                    -- --ignore if raycast is false
                    if not inView then
                        return
                    end
                    --ignore if distance is greater than X
                    if not isInRangeOfPlayer then
                        return
                    end
                    if shared.Character:FindFirstChild("Crucifix") then
                        workspace.Drops.ChildAdded:Once(function(droppedItem)
                            if droppedItem.Name == "Crucifix" then
                                local targetProximityPrompt = droppedItem:WaitForChild("ModulePrompt", 3) or droppedItem:FindFirstChildOfClass("ProximityPrompt")
                                repeat task.wait()
                                    shared.fireproximityprompt(targetProximityPrompt)
                                until not droppedItem:IsDescendantOf(workspace)
                            end
                        end)
                        Script.RemotesFolder.DropItem:FireServer(shared.Character.Crucifix);
                    end
                    return
                end
                currentSavedFrames = 0
                if hasStoppedMoving then
                    --print("Entity started moving!")
                    hasStoppedMoving = false
                end
            end)
            local childRemovedConnection; childRemovedConnection = workspace.ChildRemoved:Connect(function(model: Model)
                if model ~= child then return end
                crucifixConnection:Disconnect()
                childRemovedConnection:Disconnect()
            end)
            shared.Connect:GiveSignal(crucifixConnection)
            shared.Connect:GiveSignal(childRemovedConnection)
        end
    end)
    if shared.CheckToggle("NoVoiceActing", true) and table.find(Script.EntityTable.Names, child.Name) then
        for _, sound in pairs(child:GetDescendants()) do
            if Script.Functions.VoiceCondition(sound) then sound:Destroy() end
        end
        shared.Connect:GiveSignal(child.DescendantAdded:Connect(function(child)
            if Script.Functions.VoiceCondition(child) then child:Destroy() end
        end))
    end
end))
--// Drops Connection \\--
for _, drop in pairs(workspace.Drops:GetChildren()) do
    task.spawn(Script.Functions.SetupDropConnection, drop)
end
shared.Connect:GiveSignal(workspace.Drops.ChildAdded:Connect(function(child)
    task.spawn(Script.Functions.SetupDropConnection, child)
end))
--// Rooms Connection \--
for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
    task.spawn(Script.Functions.SetupRoomConnection, room)
    if Script.IsMines then
        task.spawn(Script.Functions.Minecart.Pathfind, room)
    end
end
shared.Connect:GiveSignal(workspace.CurrentRooms.ChildAdded:Connect(function(room)
    task.spawn(Script.Functions.SetupRoomConnection, room)
    if Script.IsMines then
        task.spawn(Script.Functions.Minecart.Pathfind, room)
    end
end))
if Script.IsMines then
    shared.Connect:GiveSignal(Script.RemotesFolder.SendRunnerNodes.OnClientEvent:Connect(function(nodetree) --yea let's just not touch on that for now.
        Script.Functions.Minecart.debug("[SendRunnerNodes] Nodes created for room: " .. tostring(Script.NextRoom))
        table.insert(Script.Functions.Minecart.pathfindQueue, Script.NextRoom)
    end))
end
--// Camera Connection \\--
if shared.Camera then task.spawn(Script.Functions.SetupCameraConnection, shared.Camera) end
shared.Connect:GiveSignal(workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
    if workspace.CurrentCamera then
        shared.Camera = workspace.CurrentCamera
        task.spawn(Script.Functions.SetupCameraConnection, shared.Camera)
    end
end))
--// Players Connection \\--
for _, player in pairs(shared.Players:GetPlayers()) do
    if player == shared.LocalPlayer then continue end
    Script.Functions.SetupOtherPlayerConnection(player)
end
shared.Connect:GiveSignal(shared.Players.PlayerAdded:Connect(Script.Functions.SetupOtherPlayerConnection))
--// Local Player Connection \\--
shared.Connect:GiveSignal(shared.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    task.delay(1, Script.Functions.SetupCharacterConnection, newCharacter)
    if Script.FakeRevive.Enabled then
        Script.FakeRevive.Enabled = false
        for _, connection in pairs(Script.FakeRevive.Connections) do
            connection:Disconnect()
        end
        table.clear(Script.FakeRevive.Connections)
        if Toggles.FakeRevive.Value then
            shared.Notify:Alert({
                Title = "Giả hồi sinh",
                Description = "Bạn đã hồi sinh, tính năng này đã dừng hoạt động.",
                Reason = "Bật nó để giả hồi sing lại",
                LinoriaMessage = "Tính năng này đã dùng hoạt động, bật nó để chạy lại",
            })
            Toggles.FakeRevive:SetValue(false)
        end
        if Script.IsMines and Toggles.EnableJump.Value then
            Options.WalkSpeed:SetMax((Toggles.TheMinesAnticheatBypass.Value and Script.Bypassed) and 75 or 18)
        else
            Options.WalkSpeed:SetMax((Script.IsMines and Toggles.TheMinesAnticheatBypass.Value and Script.Bypassed) and 75 or 22)
        end
        Options.FlySpeed:SetMax((Script.IsMines and Toggles.TheMinesAnticheatBypass.Value and Script.Bypassed) and 75 or 22)
    end
end))
shared.Connect:GiveSignal(shared.LocalPlayer:GetAttributeChangedSignal("Alive"):Connect(function()
    Script.Alive = shared.LocalPlayer:GetAttribute("Alive")
    if not Script.Alive and Script.IsFools and Toggles.InfRevives.Value then
        task.delay(1.25, function()
            Script.RemotesFolder.Revive:FireServer()
        end)
    end
end))
shared.Connect:GiveSignal(shared.PlayerGui.ChildAdded:Connect(function(child)
    if child.Name == "MainUI" then
        Script.MainUI = child
        task.delay(1, function()
            if Script.MainUI then
                Script.MainGame = Script.MainUI:WaitForChild("Initiator"):WaitForChild("Main_Game")
                if Script.MainGame then
                    if wax.shared.ExecutorSupport["require"] then Script.MainGameSrc = wax.require(Script.MainGame) end
                    if Script.MainGame:WaitForChild("Health", 5) then
                        if Script.IsHotel and Toggles.NoJammin.Value and Script.LiveModifiers:FindFirstChild("Jammin") then
                            local jamSound = Script.MainGame:FindFirstChild("Jam", true)
                            if jamSound then jamSound.Playing = false end
                        end
                    end
                    if Script.MainGame:WaitForChild("RemoteListener", 5) then
                        if Toggles.NoEntityJumpscare.Value then
                            local jumpscaresFolder = Script.MainGame:FindFirstChild("Jumpscares", true)
                            if jumpscaresFolder then
                                jumpscaresFolder.Name = "_Jumpscares"
                            end
                        end
                        local modules = Script.MainGame:FindFirstChild("Modules", true)
                        if not modules then return end
                        if Toggles.AntiDread.Value then
                            local module = modules:FindFirstChild("Dread", true)
                            if module then
                                module.Name = "_Dread"
                            end
                        end
                        if Toggles.AntiScreech.Value then
                            local module = modules:FindFirstChild("Screech", true)
                            if module then
                                module.Name = "_Screech"
                            end
                        end
                        if Toggles.NoSpiderJumpscare.Value then
                            local module = modules:FindFirstChild("SpiderJumpscare", true)
                            if module then
                                module.Name = "_SpiderJumpscare"
                            end
                        end
                        if (Script.IsHotel or Script.IsRooms) and Toggles.AntiA90.Value then
                            local module = modules:FindFirstChild("A90", true)
                            if module then
                                module.Name = "_A90"
                            end
                        end
                    end
                end
            end
        end)
    end
end))
--// ESP Handler \\--
shared.Connect:GiveSignal(Script.LatestRoom:GetPropertyChangedSignal("Value"):Connect(function()
    Script.Functions.NotifyGlitch()
end))
shared.Connect:GiveSignal(shared.LocalPlayer:GetAttributeChangedSignal("CurrentRoom"):Connect(function()
    if Script.CurrentRoom == shared.LocalPlayer:GetAttribute("CurrentRoom") then return end
    Script.CurrentRoom = shared.LocalPlayer:GetAttribute("CurrentRoom")
    Script.NextRoom = Script.CurrentRoom + 1
    task.spawn(Script.Functions.UpdateRPC)
    Script.Functions.NotifyGlitch()
    local currentRoomModel = workspace.CurrentRooms:FindFirstChild(Script.CurrentRoom)
    local nextRoomModel = workspace.CurrentRooms:FindFirstChild(Script.NextRoom)
    if Script.IsMines and Script.Bypassed and currentRoomModel:GetAttribute("RawName") == "HaltHallway" then
        Script.Bypassed = false
        shared.Notify:Alert({
            Title = "Bỏ qua anticheat",
            Description = "Halt đã làm hỏng tính năng này.",
            Reason = "Tiếp cận cái thang để bật lại.",
            LinoriaMessage = "Halt đã làm hỏng tính năng này, tiếp cận cái thang để bật lại.",
        })
        Options.WalkSpeed:SetMax(Toggles.SpeedBypass.Value and 75 or (Toggles.EnableJump.Value and 18 or 22))
        Options.FlySpeed:SetMax(Toggles.SpeedBypass.Value and 75 or 22)
    end
    if Toggles.DoorESP.Value then
        for _, doorEsp in pairs(Script.ESPTable.Door) do
            doorEsp.Destroy()
        end
        if currentRoomModel then
            task.spawn(Script.Functions.DoorESP, currentRoomModel)
        end
        if nextRoomModel then
            task.spawn(Script.Functions.DoorESP, nextRoomModel)
        end
    end
    if Toggles.ObjectiveESP.Value then
        for _, objectiveEsp in pairs(Script.ESPTable.Objective) do
            objectiveEsp.Destroy()
        end
    end
    if Toggles.EntityESP.Value then
        for _, sideEntityESP in pairs(Script.ESPTable.SideEntity) do
            sideEntityESP.Destroy()
        end
    end
    if Toggles.ItemESP.Value then
        for _, itemEsp in pairs(Script.ESPTable.Item) do
            itemEsp.Destroy()
        end
    end
    if Toggles.ChestESP.Value then
        for _, chestEsp in pairs(Script.ESPTable.Chest) do
            chestEsp.Destroy()
        end
    end
    if Toggles.HidingSpotESP.Value then
        for _, hidingSpotEsp in pairs(Script.ESPTable.HidingSpot) do
            hidingSpotEsp.Destroy()
        end
    end
    if Toggles.GoldESP.Value then
        for _, goldEsp in pairs(Script.ESPTable.Gold) do
            goldEsp.Destroy()
        end
    end
    if currentRoomModel then
        for _, asset in pairs(currentRoomModel:GetDescendants()) do
            if Toggles.ObjectiveESP.Value then
                task.spawn(Script.Functions.ObjectiveESP, asset)
            end
            if Toggles.EntityESP.Value and table.find(Script.EntityTable.SideNames, asset.Name) then    
                task.spawn(Script.Functions.SideEntityESP, asset)
            end
            if Toggles.ItemESP.Value and Script.Functions.ItemCondition(asset) then
                task.spawn(Script.Functions.ItemESP, asset)
            end
            if Toggles.ChestESP.Value and (asset:GetAttribute("Storage") == "ChestBox" or asset.Name == "Toolshed_Small") then
                task.spawn(Script.Functions.ChestESP, asset)
            end
            if Toggles.HidingSpotESP.Value and (asset:GetAttribute("LoadModule") == "Wardrobe" or asset:GetAttribute("LoadModule") == "Bed" or asset.Name == "Rooms_Locker" or asset.Name == "RetroWardrobe") then
                Script.Functions.HidingSpotESP(asset)
            end
            if Toggles.GoldESP.Value and asset.Name == "GoldPile" then
                Script.Functions.GoldESP(asset)
            end
        end
    end
end))
--// UIS Connection \\--
shared.Connect:GiveSignal(shared.UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if shared.UserInputService:GetFocusedTextBox() then return end
    if shared.CheckToggle("GrabBananaJeffToggle", true) and shared.Library.IsMobile and input.UserInputType == Enum.UserInputType.Touch then
        if Script.Temp.HoldingItem then
            return Script.Functions.ThrowBananaJeff()
        end
        local touchPos = input.Position
        local ray = workspace.CurrentCamera:ViewportPointToRay(touchPos.X, touchPos.Y)
        local result = workspace:Raycast(ray.Origin, ray.Direction * 500, RaycastParams.new())
        local target = result and result.Instance
        if target and shared.isnetworkowner(target) then
            if target.Name == "BananaPeel" then
                Script.Tracks.ItemHoldTrack:Play()
                if not target:FindFirstChildOfClass("BodyGyro") then
                    Instance.new("BodyGyro", target)
                end
                if not target:GetAttribute("Clip") then target:SetAttribute("Clip", target.CanCollide) end
                target.CanTouch = false
                target.CanCollide = false
                Script.Temp.HoldingItem = target
            elseif target:FindFirstAncestorWhichIsA("Model").Name == "JeffTheKiller" then
                Script.Tracks.ItemHoldTrack:Play()
                local jeff = target:FindFirstAncestorWhichIsA("Model")
                for _, part in ipairs(jeff:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if not part:GetAttribute("Clip") then part:SetAttribute("Clip", target.CanCollide) end
                        part.CanTouch = false
                        part.CanCollide = false
                    end
                end
                if not jeff.PrimaryPart:FindFirstChildOfClass("BodyGyro") then
                    Instance.new("BodyGyro", jeff.PrimaryPart)
                end
                Script.Temp.HoldingItem = jeff.PrimaryPart
            end
        end
    end
end))
shared.Connect:GiveSignal(shared.RunService.RenderStepped:Connect(function()
    local isThirdPersonEnabled = Toggles.ThirdPerson.Value and (shared.Library.IsMobile or Options.ThirdPersonKey:GetState())
    if Script.MainGameSrc then
        if isThirdPersonEnabled then
            shared.Camera.CFrame = Script.MainGameSrc.finalCamCFrame * CFrame.new(1.5, -0.5, 6.5)
        end
        Script.MainGameSrc.fovtarget = Options.FOV.Value
        if Toggles.NoCamBob.Value then
            Script.MainGameSrc.bobspring.Position = Vector3.zero
            Script.MainGameSrc.spring.Position = Vector3.zero
        end
        if Toggles.NoCamShake.Value then
            Script.MainGameSrc.csgo = CFrame.new()
        end
        if Toggles.ViewmodelOffset.Value then
            Script.MainGameSrc.tooloffset = Vector3.new(Options.ToolOffsetX.Value, Options.ToolOffsetY.Value, Options.ToolOffsetZ.Value)
        end
    elseif shared.Camera then
        if isThirdPersonEnabled then
            shared.Camera.CFrame = shared.Camera.CFrame * CFrame.new(1.5, -0.5, 6.5)
        end
        shared.Camera.FieldOfView = Options.FOV.Value
    end
    if shared.Character then
        if shared.Character:FindFirstChild("Head") and 
            not (
                Script.MainGameSrc and Script.MainGameSrc.stopcam or (shared.RootPart and shared.RootPart.Anchored) and not shared.Character:GetAttribute("Hiding")
            ) 
        then
            shared.Character:SetAttribute("ShowInFirstPerson", isThirdPersonEnabled)
            shared.Character.Head.LocalTransparencyModifier = isThirdPersonEnabled and 0 or 1
        end
        if shared.Humanoid and Toggles.EnableSpeedHack.Value then
            shared.Humanoid.WalkSpeed = if shared.Character:GetAttribute("Climbing") then Options.LadderSpeed.Value else Options.WalkSpeed.Value
        end
        if shared.RootPart then
            shared.RootPart.CanCollide = not Toggles.Noclip.Value
        end
        if Script.Collision then
            if Toggles.Noclip.Value then
                Script.Collision.CanCollide = not Toggles.Noclip.Value and not (Toggles.CollisionOffsetGodmode.Value or shared.Library.IsMobile or Options.CollisionOffsetGodmodeKey:GetState())
                if Script.Collision:FindFirstChild("CollisionCrouch") then
                    Script.Collision.CollisionCrouch.CanCollide = not Toggles.Noclip.Value and not (Toggles.CollisionOffsetGodmode.Value or shared.Library.IsMobile or Options.CollisionOffsetGodmodeKey:GetState())
                end
            end
            if (Toggles.CollisionOffsetGodmode.Value and (shared.Library.IsMobile or Options.CollisionOffsetGodmodeKey:GetState())) and Script.CollisionClone then
                local raycast = workspace:Raycast(shared.RootPart.Position, Vector3.new(0, -1000, 0), Script.NoCharRaycastParam)
                if raycast then
                    Script.Collision.Position = shared.RootPart.Position - Vector3.new(0, raycast.Distance - 0.9, 0)
                    Script.CollisionClone.Position = Script.Collision.Position + Vector3.new(0, 2.5, 0)
                end
            end
        end
        if shared.Character:FindFirstChild("UpperTorso") then
            shared.Character.UpperTorso.CanCollide = not Toggles.Noclip.Value
        end
        if shared.Character:FindFirstChild("LowerTorso") then
            shared.Character.LowerTorso.CanCollide = not Toggles.Noclip.Value
        end
        if Toggles.DoorReach.Value and workspace.CurrentRooms:FindFirstChild(Script.LatestRoom.Value) then
            local door = workspace.CurrentRooms[Script.LatestRoom.Value]:FindFirstChild("Door")
            if door and door:FindFirstChild("ClientOpen") then
                door.ClientOpen:FireServer()
            end
        end
        if Toggles.AutoInteract.Value and (shared.Library.IsMobile or Options.AutoInteractKey:GetState()) then
            local prompts = Script.Functions.GetAllPromptsWithCondition(function(prompt)
                if not prompt.Parent then return false end
                if Options.AutoInteractIgnore.Value["Jeff Items"] and prompt.Parent:GetAttribute("JeffShop") then return false end
                if Options.AutoInteractIgnore.Value["Unlock w/ Lockpick"] and (prompt.Name == "UnlockPrompt" or prompt.Parent:GetAttribute("Locked")) and shared.Character:FindFirstChild("Lockpick") then return false end
                if Options.AutoInteractIgnore.Value["Paintings"] and prompt.Name == "PropPrompt" then return false end
                if Options.AutoInteractIgnore.Value["Gold"] and prompt.Name == "LootPrompt" then return false end
                if Options.AutoInteractIgnore.Value["Light Source Items"] and prompt.Parent:GetAttribute("Tool_LightSource") and not prompt.Parent:GetAttribute("Tool_CanCutVines") then return false end
                if Options.AutoInteractIgnore.Value["Skull Prompt"] and prompt.Name == "SkullPrompt" then return false end
                if prompt.Parent:GetAttribute("PropType") == "Battery" and not (shared.Character:FindFirstChildOfClass("Tool") and (shared.Character:FindFirstChildOfClass("Tool"):GetAttribute("RechargeProp") == "Battery" or shared.Character:FindFirstChildOfClass("Tool"):GetAttribute("StorageProp") == "Battery")) then return false end 
                if prompt.Parent:GetAttribute("PropType") == "Heal" and shared.Humanoid and shared.Humanoid.Health == shared.Humanoid.MaxHealth then return false end
                if prompt.Parent.Name == "MinesAnchor" then return false end
                if Script.IsRetro and prompt.Parent.Parent.Name == "RetroWardrobe" then return false end
                return Script.PromptTable.Aura[prompt.Name] ~= nil
            end)
            for _, prompt: ProximityPrompt in pairs(prompts) do
                task.spawn(function()
                    -- checks if distance can interact with prompt and if prompt can be interacted again
                    if Script.Functions.DistanceFromCharacter(prompt.Parent) < prompt.MaxActivationDistance and (not prompt:GetAttribute("Interactions" .. shared.LocalPlayer.Name) or Script.PromptTable.Aura[prompt.Name] or table.find(Script.PromptTable.AuraObjects, prompt.Parent.Name)) then
                        if prompt.Parent.Name == "Slot" and prompt.Parent:GetAttribute("Hint") then
                            if Script.Temp.PaintingDebounce[prompt] then return end
                            local currentPainting = shared.Character:FindFirstChild("Prop")
                            local slotPainting = prompt.Parent:FindFirstChild("Prop")
                            local currentHint = (currentPainting and currentPainting:GetAttribute("Hint"))
                            local slotHint = (slotPainting and slotPainting:GetAttribute("Hint"))
                            local promptHint = prompt.Parent:GetAttribute("Hint")
                            --print(currentHint, slotHint, promptHint)
                            if slotHint ~= promptHint and (currentHint == promptHint or slotPainting) then
                                Script.Temp.PaintingDebounce[prompt] = true
                                shared.fireproximityprompt(prompt)
                                task.wait(0.3)
                                Script.Temp.PaintingDebounce[prompt] = false    
                            end
                            return
                        end
                        shared.fireproximityprompt(prompt)
                    end
                end)
            end
        end
        if Toggles.SpamOtherTools.Value and (shared.Library.IsMobile or Options.SpamOtherTools:GetState()) then
            for _, player in pairs(shared.Players:GetPlayers()) do
                if player == shared.LocalPlayer then continue end
                for _, tool in pairs(player.Backpack:GetChildren()) do
                    tool:FindFirstChildOfClass("RemoteEvent"):FireServer()
                end
                local toolRemote = player.Character:FindFirstChild("Remote", true)
                if toolRemote then
                    toolRemote:FireServer()
                end
            end
        end
        if Toggles.AnticheatManipulation.Value and (shared.Library.IsMobile or Options.AnticheatManipulationKey:GetState()) then
            shared.Character:PivotTo(shared.Character:GetPivot() * CFrame.new(0, 0, 1000))
        end
        if Script.IsMines then
            if Toggles.AutoAnchorSolver.Value and Script.LatestRoom.Value == 50 and Script.MainUI.MainFrame:FindFirstChild("AnchorHintFrame") then
                local prompts = Script.Functions.GetAllPromptsWithCondition(function(prompt)
                    return prompt.Name == "ActivateEventPrompt" and prompt.Parent:IsA("Model") and prompt.Parent.Name == "MinesAnchor" and not prompt.Parent:GetAttribute("Activated")
                end)
                local CurrentGameState = {
                    DesignatedAnchor = Script.MainUI.MainFrame.AnchorHintFrame.AnchorCode.Text,
                    AnchorCode = Script.MainUI.MainFrame.AnchorHintFrame.Code.Text
                }
                for _, prompt in pairs(prompts) do
                    task.spawn(function()
                        local Anchor = prompt.Parent
                        local CurrentAnchor = Anchor.Sign.TextLabel.Text
                        if not (Script.Functions.DistanceFromCharacter(prompt.Parent) < prompt.MaxActivationDistance) then return end
                        if CurrentAnchor ~= CurrentGameState.DesignatedAnchor then return end
                        local result = Anchor:FindFirstChildOfClass("RemoteFunction"):InvokeServer(CurrentGameState.AnchorCode)
                        if result then
                            shared.Notify:Alert({
                                Title = "Tự động giải mã trụ điện",
                                Description = "Giải mã trụ điện " .. CurrentAnchor .. " thành công!",
                                Reason = "Code giải mã: " .. CurrentGameState.AnchorCode,
                            })
                        end
                    end)
                end
            end
        elseif Script.IsFools then
            local HoldingItem = Script.Temp.HoldingItem
            if HoldingItem and not shared.isnetworkowner(HoldingItem) then
                shared.Notify:Alert({
                    Title = "ném Banana/Jeff",
                    Description = "Bạn không thể cầm vật phẩm này lâu nếu mạng lag",
                })
                Script.Temp.HoldingItem = nil
            end
            if HoldingItem and Toggles.GrabBananaJeffToggle.Value then
                if HoldingItem:FindFirstChildOfClass("BodyGyro") then
                    HoldingItem.CanTouch = false
                    HoldingItem.CFrame = shared.Character.RightHand.CFrame * CFrame.Angles(math.rad(-90), 0, 0)
                end
            end
            if not shared.Library.IsMobile then
                local isGrabbing = Options.GrabBananaJeff:GetState() and Toggles.GrabBananaJeffToggle.Value
                local isThrowing = Options.ThrowBananaJeff:GetState()
                if isThrowing and HoldingItem and shared.isnetworkowner(HoldingItem) then
                    Script.Functions.ThrowBananaJeff()
                end
                local target = shared.LocalPlayer:GetMouse().Target
                if not target then return end
                if isGrabbing and shared.isnetworkowner(target) then
                    if target.Name == "BananaPeel" then
                        Script.Tracks.ItemHoldTrack:Play()
                        if not target:FindFirstChildOfClass("BodyGyro") then
                            Instance.new("BodyGyro", target)
                        end
                        if not target:GetAttribute("Clip") then target:SetAttribute("Clip", target.CanCollide) end
                        target.CanTouch = false
                        target.CanCollide = false
                        Script.Temp.HoldingItem = target
                    elseif target:FindFirstAncestorWhichIsA("Model").Name == "JeffTheKiller" then
                        Script.Tracks.ItemHoldTrack:Play()
                        local jeff = target:FindFirstAncestorWhichIsA("Model")
                        for _, i in ipairs(jeff:GetDescendants()) do
                            if i:IsA("BasePart") then
                                if not i:GetAttribute("Clip") then i:SetAttribute("Clip", target.CanCollide) end
                                i.CanTouch = false
                                i.CanCollide = false
                            end
                        end
                        if not jeff.PrimaryPart:FindFirstChildOfClass("BodyGyro") then
                            Instance.new("BodyGyro", jeff.PrimaryPart)
                        end
                        Script.Temp.HoldingItem = jeff.PrimaryPart
                    end
                end
            end
        end
        if Toggles.AntiEyes.Value and (workspace:FindFirstChild("Eyes") or workspace:FindFirstChild("BackdoorLookman")) then
            if not Script.IsFools then
                -- lsplash meanie for removing other args in motorreplication
                Script.RemotesFolder.MotorReplication:FireServer(-649)
            else
                Script.RemotesFolder.MotorReplication:FireServer(0, -90, 0, false)
            end
        end
    end
    task.spawn(function()
        for guidance, part in pairs(Script.Temp.Guidance) do
            if not guidance:IsDescendantOf(workspace) then continue end
            part.CFrame = guidance.CFrame
        end
    end)
end))
shared.Connect:GiveSignal(shared.RunService.RenderStepped:Connect(function()
    if Toggles["ShowCustomCursor"] and not Toggles.ShowCustomCursor.Value and shared.Library.Toggled then
        shared.UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        shared.UserInputService.MouseIcon = "rbxassetid://2833720882"
        shared.UserInputService.MouseIconEnabled = true
    end
end))
--// Load \\--
task.spawn(Script.Functions.SetupCharacterConnection, shared.Character)
shared.Library:OnUnload(function()
    print("Unloading DOORS...")
    if shared.Hooks.mtHook then hookmetamethod(game, "__namecall", shared.Hooks.mtHook) end
    if shared.Hooks._fixDistanceFromCharacter then hookmetamethod(shared.Hooks.LocalPlayer, "__namecall", shared.Hooks._fixDistanceFromCharacter) end
    if Script.FakeRevive.Enabled then
        for _, connection in pairs(Script.FakeRevive.Connections) do
            if connection.Connected then connection:Disconnect() end
        end
        table.clear(Script.FakeRevive.Connections)
    end
    if shared.Character and shared.Character:FindFirstChildOfClass("Tool") and Script.MainGameSrc then
        local tool = shared.Character:FindFirstChildOfClass("Tool")
        if not tool:GetAttribute("ToolOffset") then return end
        Script.MainGameSrc.tooloffset = tool:GetAttribute("ToolOffset")
    end
    if wax.shared.BloxstrapRPC then
        wax.shared.BloxstrapRPC.SetRichPresence({
            details = "<reset>",
            state = "<reset>",
            largeImage = {
                reset = true
            },
            smallImage = {
                reset = true
            }
        })
    end
    if shared.Character then
        shared.Character:SetAttribute("CanJump", false)
        local speedBoostAssignObj = Script.IsFools and shared.Humanoid or shared.Character
        speedBoostAssignObj:SetAttribute("SpeedBoostBehind", 0)
        if (Toggles.CollisionOffsetGodmode.Value and (shared.Library.IsMobile or Options.CollisionOffsetGodmodeKey:GetState())) and Script.Collision and shared.RootPart then
            if Script.Collision.Position ~= shared.RootPart.Position then
                Script.Collision.Position = shared.RootPart.Position
                Script.CollisionClone.Position = Script.Collision.Position + Vector3.new(0, 2.5, 0) --idk what is the correct distance xD
            end
        end
    end
    if Script.Alive then
        shared.Lighting.Ambient = workspace.CurrentRooms[Script.CurrentRoom]:GetAttribute("Ambient")
    else
        shared.Lighting.Ambient = Color3.new(0, 0, 0)
    end
    if Script.EntityModules then
        local haltModule = Script.EntityModules:FindFirstChild("_Shade")
        local glitchModule = Script.EntityModules:FindFirstChild("_Glitch")
        local voidModule = Script.EntityModules:FindFirstChild("_Void")
        if haltModule then
            haltModule.Name = "Shade"
        end
        if glitchModule then
            glitchModule.Name = "Glitch"
        end
        if voidModule then
            voidModule.Name = "Void"
        end
    end
    local voicelines = shared.ReplicatedStorage:FindFirstChild("_Voicelines", true)
    if voicelines then
        voicelines.Name = "Voicelines"
    end
    if Script.MainGame then
        local modules = Script.MainGame:FindFirstChild("Modules", true)
        local dreadModule = modules and modules:FindFirstChild("_Dread", true)
        local screechModule = modules and modules:FindFirstChild("_Screech", true)
        local spiderModule = modules and modules:FindFirstChild("_SpiderJumpscare", true)
        if dreadModule then
            dreadModule.Name = "Dread"
        end
        if screechModule then
            screechModule.Name = "Screech"
        end
        if spiderModule then
            spiderModule.Name = "SpiderJumpscare"
        end
    end
    if Script.MainGameSrc then
        Script.MainGameSrc.fovtarget = 70
    else
        shared.Camera.FieldOfView = 70
    end
    if shared.RootPart then
        local existingProperties = shared.RootPart.CustomPhysicalProperties
        shared.RootPart.CustomPhysicalProperties = PhysicalProperties.new(Script.Temp.NoAccelValue, existingProperties.Friction, existingProperties.Elasticity, existingProperties.FrictionWeight, existingProperties.ElasticityWeight)
    end
    if Script.Tracks.ItemHoldTrack then Script.Tracks.ItemHoldTrack:Stop() end
    if Script.Tracks.ItemThrowTrack then Script.Tracks.ItemThrowTrack:Stop() end
    shared.Twerk:Disable()
    for _, animation in pairs(Script.Anims) do
        animation:Destroy()
    end
    if Script.IsBackdoor then
        local clientRemote = Script.FloorReplicated.ClientRemote
        local internal_temp_mspaint = clientRemote:FindFirstChild("_mspaint")
        if internal_temp_mspaint and #internal_temp_mspaint:GetChildren() ~= 0 then
            for i,v in pairs(internal_temp_mspaint:GetChildren()) do
                v.Parent = clientRemote.Haste
            end
        end
        internal_temp_mspaint:Destroy()
    end
    if Script.IsMines then
        local acbypasspart = workspace:FindFirstChild("_internal_mspaint_acbypassprogress")
        if acbypasspart then acbypasspart:Destroy() end
    end
    if Script.IsRooms then
        if workspace:FindFirstChild("_internal_mspaint_pathfinding_nodes") then
            workspace:FindFirstChild("_internal_mspaint_pathfinding_nodes"):Destroy()
        end
        if workspace:FindFirstChild("_internal_mspaint_pathfinding_block") then
            workspace:FindFirstChild("_internal_mspaint_pathfinding_block"):Destroy()
        end
    end
    if Script._mspaint_custom_captions then
        Script._mspaint_custom_captions:Destroy()
    end
    if Script.Collision and not (Toggles.CollisionOffsetGodmode.Value and (shared.Library.IsMobile or Options.CollisionOffsetGodmodeKey:GetState())) then
        Script.Collision.CanCollide = Script.MainGameSrc and not Script.MainGameSrc.crouching or not shared.Character:GetAttribute("Crouching")
        if Script.Collision:FindFirstChild("CollisionCrouch") then
            Script.Collision.CollisionCrouch.CanCollide = if Script.MainGameSrc then Script.MainGameSrc.crouching else shared.Character:GetAttribute("Crouching")
        end
    end
    if Script.CollisionClone then Script.CollisionClone:Destroy() end
    for _, antiBridge in pairs(Script.Temp.Bridges) do antiBridge:Destroy() end
    for _, antiBridge in pairs(Script.Temp.PipeBridges) do antiBridge:Destroy() end
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Destroy()
        end
    end
    for _, category in pairs(Script.FeatureConnections) do
        for _, connection in pairs(category) do
            connection:Disconnect()
        end
    end
    for _, object in pairs(workspace.CurrentRooms:GetDescendants()) do
        if Script.Functions.PromptCondition(object) then
            if not object:GetAttribute("Hold") then object:SetAttribute("Hold", object.HoldDuration) end
            if not object:GetAttribute("Distance") then object:SetAttribute("Distance", object.MaxActivationDistance) end
            if not object:GetAttribute("Clip") then object:SetAttribute("Clip", object.RequiresLineOfSight) end
            object.HoldDuration = object:GetAttribute("Hold")
            object.MaxActivationDistance = object:GetAttribute("Distance")
            object.RequiresLineOfSight = object:GetAttribute("Clip")
        elseif object:IsA("BasePart") then
            if not object:GetAttribute("Material") then object:SetAttribute("Material", object.Material) end
            if not object:GetAttribute("Reflectance") then object:SetAttribute("Reflectance", object.Reflectance) end
            object.Material = object:GetAttribute("Material")
            object.Reflectance = object:GetAttribute("Reflectance")
        elseif object:IsA("Decal") then
            if not object:GetAttribute("Transparency") then object:SetAttribute("Transparency", object.Transparency) end
            if not table.find(Script.SlotsName, object.Name) then
                object.Transparency = object:GetAttribute("Transparency")
            end
        end
    end
    workspace.Terrain.WaterReflectance = 1
    workspace.Terrain.WaterTransparency = 1
    workspace.Terrain.WaterWaveSize = 0.05
    workspace.Terrain.WaterWaveSpeed = 8
    shared.Lighting.GlobalShadows = true
    print("Ngừng tải doors!")
end)
shared.SubFolder = Script.Floor.Value
getgenv().mspaint_loaded = true
end)() end,
    [7] = function()local wax,script,require=ImportGlobals(7)local ImportGlobals return (function(...)--// Loading Wait \\--
if shared.LocalPlayer.PlayerGui:FindFirstChild("LoadingUI") and shared.LocalPlayer.PlayerGui.LoadingUI.Enabled then
    repeat task.wait() until not shared.LocalPlayer.PlayerGui.LoadingUI.Enabled
end
shared.Character = shared.LocalPlayer.Character or shared.LocalPlayer.CharacterAdded:Wait()
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
Script.CurrentBadge = 0
Script.Achievements = {
    "SurviveWithoutHiding",
    "SurviveGloombats",
    "SurviveSeekMinesSecond",
    "TowerHeroesGoblino",
    "EscapeBackdoor",
    "SurviveFiredamp",
    "CrucifixDread",
    "EnterRooms",
    "EncounterVoid",
    "Join",
    "DeathAmt100",
    "UseCrucifix",
    "EncounterSpider",
    "SurviveHalt",
    "SurviveRush",
    "DeathAmt10",
    "Revive",
    "PlayFriend",
    "SurviveNest",
    "CrucifixFigure",
    "CrucifixAmbush",
    "PlayerBetrayal",
    "SurviveEyes",
    "KickGiggle",
    "EscapeMines",
    "GlowstickGiggle",
    "DeathAmt1",
    "SurviveSeek",
    "UseRiftMutate",
    "CrucifixGloombatSwarm",
    "SurviveScreech",
    "SurviveDread",
    "SurviveSeekMinesFirst",
    "CrucifixHalt",
    "TowerHeroesVoid",
    "JoinLSplash",
    "CrucifixDupe",
    "EncounterGlitch",
    "JeffShop",
    "CrucifixScreech",
    "SurviveGiggle",
    "EscapeHotelMod1",
    "SurviveDupe",
    "CrucifixRush",
    "EscapeBackdoorHunt",
    "EscapeHotel",
    "CrucifixGiggle",
    "EscapeFools",
    "UseRift",
    "SpecialQATester",
    "EscapeRetro",
    "TowerHeroesHard",
    "EnterBackdoor",
    "EscapeRooms1000",
    "EscapeRooms",
    "EscapeHotelMod2",
    "EncounterMobble",
    "CrucifixGrumble",
    "UseHerbGreen",
    "CrucifixSeek",
    "JeffTipFull",
    "SurviveFigureLibrary",
    "TowerHeroesHotel",
    "CrucifixEyes",
    "BreakerSpeedrun",
    "SurviveAmbush",
    "SurviveHide",
    "JoinAgain"
}
Script.RemotesFolder = shared.ReplicatedStorage:WaitForChild("RemotesFolder")
Script.CreateElevator = Script.RemotesFolder:WaitForChild("CreateElevator")
Script.MainUI = shared.PlayerGui:WaitForChild("MainUI")
Script.LobbyFrame = Script.MainUI:WaitForChild("LobbyFrame")
Script.AchievementsFrame = Script.LobbyFrame:WaitForChild("Achievements")
Script.CreateElevatorFrame = Script.LobbyFrame:WaitForChild("CreateElevator")
Script.LobbyElevators = workspace:WaitForChild("Lobby"):WaitForChild("LobbyElevators")
function Script.Functions.SetupVariables()
    if wax.shared.ExecutorSupport["require"] then
        for achievementName, _ in pairs(wax.require(shared.ReplicatedStorage.Achievements)) do
            if table.find(Script.Achievements, achievementName) then continue end
            table.insert(Script.Achievements, achievementName)
        end
    else
        local badgeList = Script.AchievementsFrame:WaitForChild("List", math.huge)
        if badgeList then
            repeat task.wait(0.5) until #badgeList:GetChildren() ~= 0
            shared.Connect:GiveSignal(badgeList.ChildAdded:Connect(function(badge)
                if not badge:IsA("ImageButton") then return end
                if table.find(Script.Achievements, badge.Name) then return end
                table.insert(Script.Achievements, badge.Name)
            end))
            for _, badge in pairs(badgeList:GetChildren()) do
                if not badge:IsA("ImageButton") then continue end
                if table.find(Script.Achievements, badge.Name) then continue end
                table.insert(Script.Achievements, badge.Name)
            end
        end
    end
end
function Script.Functions.LoopAchievements()
    task.spawn(function()
        while Toggles.LoopAchievements.Value and not shared.Library.Unloaded do
            if Script.CurrentBadge >= #Script.Achievements then Script.CurrentBadge = 0 end
            Script.CurrentBadge += 1
            local random = Script.Achievements[Script.CurrentBadge]
            Script.RemotesFolder.FlexAchievement:FireServer(random)
            task.wait(Options.LoopAchievementsSpeed.Value)
        end
    end)
end
function Script.Functions.SetupCharacterConnection(newCharacter)
    shared.Character = newCharacter
    shared.Humanoid = shared.Character:FindFirstChildWhichIsA("Humanoid")
    shared.RootPart = shared.Character:FindFirstChild("HumanoidRootPart") or shared.Character.PrimaryPart
    if shared.Humanoid then
        shared.Twerk:Setup()
        if Toggles.Twerk.Value then
            shared.Twerk:Enable()
        end
    end
end
shared.Load("Utils", "Preset")
--// Tabs \\--
Script.Tabs = {
    Main = shared.Window:AddTab("Main")
}
shared.Load("Tabs", "Main")
--// Code \\--
task.spawn(Script.Functions.SetupVariables)
task.spawn(Script.Functions.LoadPresets)
task.spawn(Script.Functions.SetupCharacterConnection, shared.Character)
shared.Connect:GiveSignal(shared.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    task.delay(1, Script.Functions.SetupCharacterConnection, newCharacter)
end))
getgenv().mspaint_loaded = true
end)() end,
    [9] = function()local wax,script,require=ImportGlobals(9)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
Script.LoadedRooms = {}
Script.FeatureConnections = {
    Door = {},
    Shell = {},
    Room = {}
}
Script.ESPTable = {
    Door = {},
    Entity = {},
    Battery = {},
    Locker = {},
    Player = {},
    Table = {},
    None = {}
}
Script.EntityNames = {
    ["monster"] = "A-60",
    ["monster2"] = "A-120",
    ["Spirit"] = "Pnevma"
}
Script.CurrentAmbient = shared.Lighting.Ambient
Script._mspaint_custom_captions = Instance.new("ScreenGui") do
    local Frame = Instance.new("Frame", Script._mspaint_custom_captions)
    local TextLabel = Instance.new("TextLabel", Frame)
    local UITextSizeConstraint = Instance.new("UITextSizeConstraint", TextLabel)
    Script._mspaint_custom_captions.Parent = shared.ReplicatedStorage
    Script._mspaint_custom_captions.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Frame.AnchorPoint = Vector2.new(0.5, 0.5)
    Frame.BackgroundColor3 = shared.Library.MainColor
    Frame.BorderColor3 = shared.Library.AccentColor
    Frame.BorderSizePixel = 2
    Frame.Position = UDim2.new(0.5, 0, 0.8, 0)
    Frame.Size = UDim2.new(0, 200, 0, 75)
    shared.Library:AddToRegistry(Frame, {
        BackgroundColor3 = "MainColor",
        BorderColor3 = "AccentColor"
    })
    TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    TextLabel.BackgroundTransparency = 1.000
    TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
    TextLabel.BorderSizePixel = 0
    TextLabel.Size = UDim2.new(1, 0, 1, 0)
    TextLabel.Font = Enum.Font.Code
    TextLabel.Text = ""
    TextLabel.TextColor3 = shared.Library.FontColor
    TextLabel.TextScaled = true
    TextLabel.TextSize = 14
    TextLabel.TextWrapped = true
    shared.Library:AddToRegistry(TextLabel, {
        TextColor3 = "FontColor"
    })
    UITextSizeConstraint.MaxTextSize = 35
    function Script.Functions.HideCaptions()
        Script._mspaint_custom_captions.Parent = shared.ReplicatedStorage
    end
    local CaptionsLastUsed = os.time()
    function Script.Functions.Captions(caption: string)
        CaptionsLastUsed = os.time()
        if Script._mspaint_custom_captions.Parent == shared.ReplicatedStorage then
            local success = pcall(function()
                Script._mspaint_custom_captions.Parent = if gethui then gethui() else shared.CoreGui
            end)
            if not success then
                Script._mspaint_custom_captions.Parent = shared.PlayerGui
            end 
        end
        TextLabel.Text = caption
        task.spawn(function()
            task.wait(5)
            if os.time() - CaptionsLastUsed >= 5 then
                Script.Functions.HideCaptions()
            end
        end)
    end
end
--// Player Variables \\--
shared.Character = shared.LocalPlayer.Character or shared.LocalPlayer.CharacterAdded:Wait()
shared.Humanoid = nil
Script.MainUI = shared.PlayerGui:WaitForChild("MainGui")
--// Functions \--
function Script.Functions.RandomString()
    local length = math.random(10,20)
    local array = {}
    for i = 1, length do
        array[i] = string.char(math.random(32, 126))
    end
    return table.concat(array)
end
shared.Load("Utils", "Assets")
shared.Load("Utils", "Chat")
shared.Load("Utils", "ESP")
shared.Load("Utils", "ConnectionsFuncs")
--// Tabs \\--
Script.Tabs = {
    Main = shared.Window:AddTab("Main"),
    Visuals = shared.Window:AddTab("Visuals")
}
shared.Load("Tabs", "Main")
shared.Load("Tabs", "Visuals")
--// Metamethod hooks \\--
if wax.shared.ExecutorSupport["hookmetamethod"] and wax.shared.ExecutorSupport["getnamecallmethod"] then
    shared.Hooks.mtHook = hookmetamethod(game, "__namecall", function(self, ...)
        local args = {...}
        local namecall = getnamecallmethod()
        if getcallingscript() and namecall == "SetCore" and args[1] == "DevConsoleVisible" and args[2] == false then
            args[2] = game:GetService("StarterGui"):GetCore("DevConsoleVisible")
            return shared.Hooks.mtHook(self, table.unpack(args))
        end
        return shared.Hooks.mtHook(self, ...)
    end)
end
--// Connections \\--
shared.Connect:GiveSignal(shared.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    task.delay(1, Script.Functions.SetupCharacterConnection, newCharacter)
end))
shared.Connect:GiveSignal(shared.PlayerGui.ChildAdded:Connect(function(child)
    if child.Name == "MainGui" then
        task.delay(1, Script.Functions.SetupUIConnection, child)
    end
end))
shared.Connect:GiveSignal(workspace.rooms.ChildAdded:Connect(function(room)
    Script.Functions.SetupRoomConnection(room)
end))
shared.Connect:GiveSignal(workspace.next.ChildAdded:Connect(function(room)
    Script.Functions.SetupRoomConnection(room)
end))
--// Entity Handler
shared.Connect:GiveSignal(workspace.ChildAdded:Connect(function(child)
    local entityName = Script.EntityNames[child.Name]
    if not entityName then return end
    if child:FindFirstChild("wind") then
        entityName = "A-200"
    end
    if Toggles.EntityESP.Value then
        Script.Functions.EntityESP(child, entityName)
    end
    if Toggles.NotifyEntity.Value then
        shared.Notify:Alert({
            Title = "ENTITIES",
            Description = entityName .. " Đã xuất hiện!"
        })
        if Toggles.NotifyChat.Value then
            Script.Functions.Chat(string.format("%s %s", entityName, Options.NotifyEntityMessage.Value))
        end
    end
end))
shared.Connect:GiveSignal(shared.RunService.RenderStepped:Connect(function()
    if shared.Character then
        if shared.Humanoid then
            if Toggles.SpeedHack.Value then shared.Humanoid.WalkSpeed = Options.WalkSpeed.Value end
        end
    end
    if wax.shared.ExecutorSupport["getrenv"] then
        if Toggles.InfStamina.Value then
            getrenv()._G.stamina = 100
        end
        if Toggles.InfFlashlight.Value then
            getrenv()._G.flashlightcharge = 100
        end
    end
end))
--// Load \\--
Instance.new("BoolValue", shared.LocalPlayer).Name = "cheats"
task.spawn(Script.Functions.SetupCharacterConnection, shared.Character)
task.spawn(Script.Functions.SetupLightingConnection)
task.spawn(Script.Functions.SetupUIConnection)
--// Unload \\--
shared.Library:OnUnload(function()
    if shared.Hooks.mtHook then hookmetamethod(game, "__namecall", shared.Hooks.mtHook) end
    local slender = Script.MainUI and Script.MainUI:FindFirstChild("slender")
    if slender then
        slender.ImageTransparency = 0
        for _, bar in pairs(slender:GetChildren()) do
            bar.Visible = true
        end
    end
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Destroy()
        end
    end
    for _, category in pairs(Script.FeatureConnections) do
        for _, connection in pairs(category) do
            connection:Disconnect()
        end
    end
    print("Unloading " .. shared.ScriptName .. "...")
end)
getgenv().mspaint_loaded = true
end)() end,
    [10] = function()local wax,script,require=ImportGlobals(10)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
--// Player Variables \\--
shared.Character = shared.LocalPlayer.Character or shared.LocalPlayer.CharacterAdded:Wait()
shared.Humanoid = nil
Script._mspaint_custom_captions = Instance.new("ScreenGui") do
    local Frame = Instance.new("Frame", Script._mspaint_custom_captions)
    local TextLabel = Instance.new("TextLabel", Frame)
    local UITextSizeConstraint = Instance.new("UITextSizeConstraint", TextLabel)
    Script._mspaint_custom_captions.Parent = shared.ReplicatedStorage
    Script._mspaint_custom_captions.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Frame.AnchorPoint = Vector2.new(0.5, 0.5)
    Frame.BackgroundColor3 = shared.Library.MainColor
    Frame.BorderColor3 = shared.Library.AccentColor
    Frame.BorderSizePixel = 2
    Frame.Position = UDim2.new(0.5, 0, 0.8, 0)
    Frame.Size = UDim2.new(0, 200, 0, 75)
    shared.Library:AddToRegistry(Frame, {
        BackgroundColor3 = "MainColor",
        BorderColor3 = "AccentColor"
    })
    TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    TextLabel.BackgroundTransparency = 1.000
    TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
    TextLabel.BorderSizePixel = 0
    TextLabel.Size = UDim2.new(1, 0, 1, 0)
    TextLabel.Font = Enum.Font.Code
    TextLabel.Text = ""
    TextLabel.TextColor3 = shared.Library.FontColor
    TextLabel.TextScaled = true
    TextLabel.TextSize = 14
    TextLabel.TextWrapped = true
    shared.Library:AddToRegistry(TextLabel, {
        TextColor3 = "FontColor"
    })
    UITextSizeConstraint.MaxTextSize = 35
    function Script.Functions.HideCaptions()
        Script._mspaint_custom_captions.Parent = shared.ReplicatedStorage
    end
    local CaptionsLastUsed = os.time()
    function Script.Functions.Captions(caption: string)
        CaptionsLastUsed = os.time()
        if Script._mspaint_custom_captions.Parent == shared.ReplicatedStorage then
            local success = pcall(function()
                Script._mspaint_custom_captions.Parent = if gethui then gethui() else shared.CoreGui
            end)
            if not success then
                Script._mspaint_custom_captions.Parent = shared.PlayerGui
            end 
        end
        TextLabel.Text = caption
        task.spawn(function()
            task.wait(5)
            if os.time() - CaptionsLastUsed >= 5 then
                Script.Functions.HideCaptions()
            end
        end)
    end
end
shared.Load("Utils", "ConnectionsFuncs")
--// Tabs \\--
Script.Tabs = {
    Main = shared.Window:AddTab("Main"),
}
shared.Load("Tabs", "Main")
--// Metamethod hooks \\--
--// Connections \\--
shared.Connect:GiveSignal(shared.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    task.delay(1, Script.Functions.SetupCharacterConnection, newCharacter)
end))
--// Load \\--
task.spawn(Script.Functions.SetupCharacterConnection, shared.Character)
--// Unload \\--
shared.Library:OnUnload(function()
    print("Unloading " .. shared.ScriptName .. "...")
end)
getgenv().mspaint_loaded = true
end)() end,
    [14] = function()local wax,script,require=ImportGlobals(14)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
local Tabs = Script.Tabs
--// Exploits \\--
local AntiEntityGroupBox = Tabs.Exploits:AddLeftGroupbox("Xóa quái") do
    AntiEntityGroupBox:AddToggle("AntiDread", {
        Text = "Xóa Dread",
        Default = false
    })
    AntiEntityGroupBox:AddToggle("AntiHalt", {
        Text = "Xóa Halt",
        Default = false
    })
    AntiEntityGroupBox:AddToggle("AntiScreech", {
        Text = "Xóa Screech",
        Default = false
    })
    AntiEntityGroupBox:AddToggle("AntiDupe", {
        Text = "Chống " .. (Script.IsBackdoor and "Vacuum" or "Dupe"),
        Default = false
    })
    AntiEntityGroupBox:AddToggle("AntiEyes", {
        Text = "Chống " .. (Script.IsBackdoor and "Lookman" or "Eyes"),
        Default = false
    })
    AntiEntityGroupBox:AddToggle("AntiSnare", {
        Text = "Tránh bẫy",
        Default = false
    })
    AntiEntityGroupBox:AddToggle("AntiHearing", {
        Text = "Chống figure nghe thấy",
        Default = false,
        Visible = not Script.IsFools
    })
end
local FigureGroupBox = Tabs.Exploits:AddLeftGroupbox("Xóa Figure + Glumble") do
    FigureGroupBox:AddLabel("Để xóa figure bạn hãy ấn vô tính")
    FigureGroupBox:AddLabel("năng rồi đặt đồng hồ báo thức ra")
    FigureGroupBox:AddLabel("rồi chờ 1 lúc")
    FigureGroupBox:AddButton("Xóa figure", function()
            if _G.DeletingFigure then
                getgenv().Library:Notify("Đang chạy tính năng..", 1)
                return
            end
            getgenv().Library:Notify("Đang xóa figure vui lòng chờ đợi", 3)
            local room = game.Players.LocalPlayer:GetAttribute("CurrentRoom")
            local crooms = workspace.CurrentRooms
            _G.notsuccess = 0
            _G.DeletingFigure = true
            local Part = Instance.new("Part", workspace)
            local Attachment1 = Instance.new("Attachment", Part)
            Part.Anchored = true
            Part.Position = Vector3.new(0, 0, 0)
            Attachment1.Position = Vector3.new(0, -49000, 0)
            if crooms:WaitForChild(room):FindFirstChild("FigureSetup") then
                if crooms:WaitForChild(room).FigureSetup.FigureRig:FindFirstChild("Root") then
                    local figure = crooms:WaitForChild(room).FigureSetup.FigureRig
                    local Torque = Instance.new("Torque")
                    Torque.Parent = figure.Hitbox
                    Torque.Torque = Vector3.new(100000, 100000, 100000)
                    local AlignPosition = Instance.new("AlignPosition")
                    local Attachment2 = Instance.new("Attachment")
                    AlignPosition.Parent = figure.Hitbox
                    Attachment2.Parent = figure.Hitbox
                    Torque.Attachment0 = Attachment2
                    AlignPosition.MaxForce = 9999999999999999
                    AlignPosition.MaxVelocity = math.huge
                    AlignPosition.Responsiveness = 100
                    AlignPosition.Attachment0 = Attachment2
                    AlignPosition.Attachment1 = Attachment1
                    task.wait(1.5)
                    Part:Destroy()
                    Attachment1:Destroy()
                    Torque:Destroy()
                    AlignPosition:Destroy()
                    Attachment2:Destroy()
                    repeat
                        _G.notsuccess = _G.notsuccess + 1
                        task.wait(0.1)
                    until figure.Hitbox.Position == Vector3.new() or _G.notsuccess == 100
                    if _G.notsuccess == 100 then
                        getgenv().Library:Notify("Lỗi, thất bại khi xóa figure", 4)
                    else
                        getgenv().Library:Notify("Đã xóa thành công", 4)
                    end
                else
                    getgenv().Library:Notify("Lỗi, không phát hiện thấy figure", 3)
                end
            else
                getgenv().Library:Notify("Lỗi, không phát hiện thấy figure", 3)
            end
            _G.DeletingFigure = false
        end)
        -- Thêm Toggle để bật/tắt "Invisible Grumbles"
        FigureGroupBox:AddToggle("Làm glumble vô hình", {
            Text = "Glumble vô hình",
            Default = false,
            Callback = function(value)
                local room = game.Players.LocalPlayer:GetAttribute("CurrentRoom")
                local crooms = workspace.CurrentRooms
                if value then
                    getgenv().Library:Notify("Đang chạy tính năng...", 3)
                    if crooms:WaitForChild(room):FindFirstChild("_NestHandler") then
                        if crooms:WaitForChild(room):WaitForChild("_NestHandler"):FindFirstChild("Grumbles") then
                            _G.InvisGrumbles = true
                            for _, grumble in ipairs(crooms:WaitForChild(room):WaitForChild("_NestHandler").Grumbles:GetChildren()) do
                                grumble.MainPart.GrumbleAttach.CFrame = CFrame.new(Vector3.new(0, 500, 0))
                            end
                        else
                            getgenv().Library:Notify("Lỗi, không phát hiện glumble", 3)
                            task.wait()
                            Toggles["TplaysAddonDoors_InvisibleGrumbles"]:SetValue(false)
                        end
                    else
                        getgenv().Library:Notify("Lỗi không phát hiện glumble", 3)
                        task.wait()
                        Toggles["TplaysAddonDoors_InvisibleGrumbles"]:SetValue(false)
                    end
                else
                    if _G.InvisGrumbles == true then
                        _G.InvisGrumbles = false
                        if crooms:WaitForChild(room):FindFirstChild("_NestHandler") then
                            if crooms:WaitForChild(room):WaitForChild("_NestHandler"):FindFirstChild("Grumbles") then
                                for _, grumble in ipairs(crooms:WaitForChild(room):WaitForChild("_NestHandler").Grumbles:GetChildren()) do
                                    grumble.MainPart.GrumbleAttach.CFrame = CFrame.new(Vector3.new(0, 0, 0))
                                end
                            end
                        end
                    end
                end
            end
        })
    end    
local TrollingGroupBox = Tabs.Floor:AddRightGroupbox("Trôn vn") do
    TrollingGroupBox:AddToggle("SpamOtherTools", {
        Text = "Tạo một số công cụ",
        Default = false
    }):AddKeyPicker("SpamOtherTools", {
        Default = "X",
        Text = "Tạo một số công cụ",
        Mode = shared.Library.IsMobile and "Toggle" or "Hold",
        SyncToggleState = shared.Library.IsMobile
    })
    TrollingGroupBox:AddToggle("UpsideDown", {
        Text = "Lộn ngược",
        Default = false
    })
    TrollingGroupBox:AddToggle("Twerk", {
        Text = "Nhảy",
        Default = false
    })
end
local BypassGroupBox = Tabs.Exploits:AddRightGroupbox("Tính năng mở") do
    BypassGroupBox:AddToggle("SpeedBypass", {
        Text = "Tăng thêm tốc độ",
        Default = false
    })
    BypassGroupBox:AddSlider("SpeedBypassDelay", {
        Text = "Độ trễ của tốc độ",
        Default = 0.23,
        Min = 0.22,
        Max = 0.25,
        Rounding = 3,
        Compact = true
    })
    BypassGroupBox:AddDivider()
    BypassGroupBox:AddToggle("AnticheatManipulation", {
        Text = "Thao tác chống gian lận",
        Default = false,
    }):AddKeyPicker("AnticheatManipulationKey", {
        Default = "T",
        Text = "Thao tác chống gian lận",
        Mode = shared.Library.IsMobile and "Toggle" or "Hold",
        SyncToggleState = shared.Library.IsMobile
    })
    BypassGroupBox:AddToggle("CollisionOffsetGodmode", {
        Text = "Bât tử",
        Default = false,
        Risky = true,
        Tooltip = "Có thể gây lag cho bạn",
    }):AddKeyPicker("CollisionOffsetGodmodeKey", {
        Mode = "Toggle",
        Default = "K",
        Text = "Bất tử",
        SyncToggleState = true
    })
    BypassGroupBox:AddDivider()
    BypassGroupBox:AddToggle("InfItems", {
        Text = "Vô hạn vật phẩm",
        Default = false,
        Visible = not Script.IsFools
    })
    BypassGroupBox:AddToggle("InfCrucifix", {
        Text = "Vô hạn thánh giá",
        Default = false,
        Visible = not Script.IsFools,
        Tooltip = "Rất rủi ro, không đảm bảo 100% hoạt động tốt",
        Risky = true
    })
    BypassGroupBox:AddDivider()
    BypassGroupBox:AddToggle("FakeRevive", {
        Text = "Giả hồi sinh",
        Default = false
    })
    BypassGroupBox:AddToggle("DeleteSeek", {
        Text = "Xóa seek (FE)",
        Default = false
    })
end
--// Anti Entity \\--
Toggles.AntiDread:OnChanged(function(value)
    if not Script.MainGame then return end
    local modules = Script.MainGame:FindFirstChild("Modules", true)
    local module = modules and (modules:FindFirstChild("Dread", true) or modules:FindFirstChild("_Dread", true))
    if module then
        module.Name = if value then "_Dread" else "Dread"
    end
end)
Toggles.AntiHalt:OnChanged(function(value)
    if not Script.EntityModules then return end
    local module = Script.EntityModules:FindFirstChild("Shade") or Script.EntityModules:FindFirstChild("_Shade")
    if module then
        module.Name = if value then "_Shade" else "Shade"
    end
end)
Toggles.AntiScreech:OnChanged(function(value)
    if not Script.MainGame then return end
    local module = Script.MainGame:FindFirstChild("Screech", true) or Script.MainGame:FindFirstChild("_Screech", true)
    if module then
        module.Name = if value then "_Screech" else "Screech"
    end
end)
Toggles.AntiDupe:OnChanged(function(value)
    for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
        for _, dupeRoom in pairs(room:GetChildren()) do
            if dupeRoom:GetAttribute("LoadModule") == "DupeRoom" or dupeRoom:GetAttribute("LoadModule") == "SpaceSideroom" then
                task.spawn(function() Script.Functions.DisableDupe(dupeRoom, value, dupeRoom:GetAttribute("LoadModule") == "SpaceSideroom") end)
            end
        end
    end
end)
Toggles.AntiSnare:OnChanged(function(value)
    for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
        if not room:FindFirstChild("Assets") then continue end
        for _, snare in pairs(room.Assets:GetChildren()) do
            if snare.Name == "Snare" then
                snare:WaitForChild("Hitbox", 5).CanTouch = not value
            end
        end
    end
end)
Toggles.AntiHearing:OnChanged(function(value)
    if Script.IsFools then return end
    Script.RemotesFolder.Crouch:FireServer(value)
end)
--// Trolling \\--
Toggles.UpsideDown:OnChanged(function(value)
    if not Script.Collision then return end
    -- im sorry deivid
    if value then
        local rotation = Script.Collision.Rotation
        Script.Collision.Rotation = Vector3.new(rotation.X, rotation.Y, -90)
        task.spawn(function()
            repeat task.wait() until not Toggles.UpsideDown.Value or shared.Library.Unloaded
            if Script.Collision and shared.Library.Unloaded ~= true then
                rotation = Script.Collision.Rotation
                Script.Collision.Rotation = Vector3.new(rotation.X, rotation.Y, 90)
            end
        end)
    end
end)
Toggles.Twerk:OnChanged(function(value)
    shared.Twerk:Set(value)
end)
--// Bypass \\--
function Script.Functions.SpeedBypass()
    if Script.SpeedBypassing or not Script.CollisionClone then return end
    Script.SpeedBypassing = true
    task.spawn(function()
        while Toggles.SpeedBypass.Value and Script.CollisionClone and not shared.Library.Unloaded and not Script.FakeRevive.Enabled do
            if shared.RootPart.Anchored then
                Script.CollisionClone.Massless = true
                repeat task.wait() until not shared.RootPart.Anchored
                task.wait(0.15)
            else
                Script.CollisionClone.Massless = not Script.CollisionClone.Massless
            end
            task.wait(Options.SpeedBypassDelay.Value)
        end
        Script.SpeedBypassing = false
        if Script.CollisionClone then
            Script.CollisionClone.Massless = true
        end
    end)
end
Toggles.SpeedBypass:OnChanged(function(value)
    if value then
        Options.WalkSpeed:SetMax(75)
        Options.FlySpeed:SetMax(75)
        Script.Functions.SpeedBypass()
    else
        if Script.FakeRevive.Enabled then return end
        local speed = if Script.Bypassed then 75 elseif Toggles.EnableJump.Value then 18 else 22
        local flySpeed = if Script.Bypassed then 75 else 22
        Options.WalkSpeed:SetMax(speed)
        Options.FlySpeed:SetMax(flySpeed)
    end
end)
Toggles.FakeRevive:OnChanged(function(value)
    if value and Script.Alive and shared.Character and not Script.FakeRevive.Enabled then
        if Script.LatestRoom and Script.LatestRoom.Value == 0 then
            shared.Notify:Alert({
                Title = "Dương Api",
                Description = "Bạn phải mỏ cửa tiếp theo để chạy tính năng này",
                Reason = "Bạn đang ở cửa 1"
            })
            repeat task.wait() until Script.LatestRoom.Value > 0
        end
        shared.Notify:Alert({
            Title = "Dương Api",
            Description = "Tìm mơi nào đó để chết hoặc chờ 20 giây sẽ hoạt động",
            Reason = "Bạn vẫn chưa hẹo",
            Time = 20
        })
        local oxygenModule = Script.MainGame:FindFirstChild("Oxygen")
        local healthModule = Script.MainGame:FindFirstChild("Health")
        local cameraModule = Script.MainGame:FindFirstChild("Camera")
        local inventoryModule = Script.MainGame:FindFirstChild("Inventory")
        if oxygenModule and healthModule then
            task.delay(0.5, function()
                if not Toggles.FakeRevive.Value then return end
                oxygenModule.Enabled = false
                healthModule.Enabled = false
                inventoryModule.Enabled = false
            end)
        end
        repeat task.wait(0.25)
            Script.RemotesFolder.Underwater:FireServer(true)
        until not Script.Alive or not Toggles.FakeRevive.Value
        if Script.Alive and not Toggles.FakeRevive.Value then
            Script.RemotesFolder.Underwater:FireServer(false)
            shared.Notify:Alert({
                Title = "Dương Api",
                Description = "Đã tắt tính năng, dừng giết người dùng.",
                Reason = "Bãn vẫn chưa chết",
            })
            oxygenModule.Enabled = true
            healthModule.Enabled = true
            return
        end
        Toggles.SpeedBypass:SetValue(false)
        Options.WalkSpeed:SetMax(75)
        Options.FlySpeed:SetMax(75)
        Script.FakeRevive.Enabled = true
        workspace.Gravity = 0
        if shared.CameraModule then
            shared.CameraModule.Enabled = false
        end
        task.wait(0.1)
        for _, hotbarItem in pairs(Script.MainUI.MainFrame.Hotbar:GetChildren()) do
            if not hotbarItem:IsA("TextButton") then continue end
            hotbarItem.Visible = false
        end
        local tool = Instance.new("Tool") do
            tool.RequiresHandle = false
            tool.Name = "AttachTool"
            tool.Parent = shared.Character
            shared.Humanoid.Name = "old_Humanoid"
            local newHumanoid = shared.Humanoid:Clone()
            newHumanoid.Parent = shared.Character
            newHumanoid.Name = "Humanoid"
            task.wait()
            shared.Humanoid:Destroy()
            shared.Camera.CameraSubject = shared.Character
            shared.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
            local determined_cframe = shared.RootPart.CFrame * CFrame.new(0, 0, 0) * CFrame.new(math.random(-100, 100)/200,math.random(-100, 100)/200,math.random(-100, 100)/200)
            shared.RootPart.CFrame = determined_cframe
            local atempts = 0
            repeat task.wait()
                atempts = atempts + 1
                shared.RootPart.CFrame = determined_cframe
            until (tool.Parent ~= shared.Character or not shared.RootPart or not shared.RootPart.Parent or atempts > 250) and atempts > 2
            tool:Destroy()
        end
        -- setup shared.Character
        for _, part in pairs(shared.Character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "UpperTorso" and part.Name ~= "Collision" and part.Parent.Name ~= "Collision" then 
                --v.CanCollide = false
                part.Massless = true
                part.CustomPhysicalProperties = PhysicalProperties.new(100, 0.3, 0.5, 1, 1)
            end
        end
        for _, weld in pairs(shared.Character:GetChildren()) do
            if weld:IsA("Weld") then
                weld:Destroy()
            end
        end
        shared.Camera:Destroy()
        task.wait(0.1)
        workspace.CurrentCamera.CameraSubject = shared.Character:FindFirstChildWhichIsA('Humanoid')
        workspace.CurrentCamera.CameraType = "Custom"
        shared.LocalPlayer.CameraMinZoomDistance = 0.5
        shared.LocalPlayer.CameraMaxZoomDistance = 400
        shared.LocalPlayer.CameraMode = "Classic"
        shared.Character.Head.Anchored = false
        shared.Camera = workspace.CurrentCamera
        -- setup fake char
        local humanoidDescription = shared.Players:GetHumanoidDescriptionFromUserId(shared.LocalPlayer.UserId)
        humanoidDescription.HeightScale = 1.2
        local previewCharacter = shared.Players:CreateHumanoidModelFromDescription(humanoidDescription, Enum.HumanoidRigType.R15) do
            previewCharacter.Parent = shared.Workspace
            previewCharacter.Name = "PreviewCharacter"
            previewCharacter.HumanoidRootPart.Anchored = true
            shared.Character.UpperTorso.CanCollide = false
        end
        Script.FakeRevive.Connections["HidingFix"] = shared.UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if shared.UserInputService:GetFocusedTextBox() then return end
            if gameProcessed then return end
            if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.S or input.KeyCode == Enum.KeyCode.D then
                if shared.Character:GetAttribute("Hiding") then
                    for i = 1, 50 do
                        task.wait()
                        Script.RemotesFolder.CamLock:FireServer()
                    end
                end
            end
        end)
        shared.Connect:GiveSignal(Script.FakeRevive.Connections["HidingFix"])
        -- animation setup
        task.spawn(function()
            local anims = shared.Character:WaitForChild("Animations", 10) or previewCharacter:WaitForChild("Animations", 10);
            local crouch, oldCrouchSpeed = previewCharacter.Humanoid:LoadAnimation(anims.Crouch), 0;
            local walk, idle = previewCharacter.Humanoid:LoadAnimation(anims.Forward), previewCharacter.Humanoid:LoadAnimation(anims.Idle);
            local interact = previewCharacter.Humanoid:LoadAnimation(anims.Interact);
            oldCrouchSpeed = crouch.Speed;
            local function playWalkingAnim(key)
                repeat
                    if idle.isPlaying then idle:Stop() end
                    if shared.Character:GetAttribute("Crouching") then
                        if not crouch.isPlaying then crouch:Play() crouch:AdjustSpeed(oldCrouchSpeed) end
                        if walk.isPlaying then walk:Stop() end
                    else
                        if crouch.isPlaying then crouch:Stop() end
                        if not walk.isPlaying then walk:Play() end
                    end
                    task.wait(0.5)
                until not shared.UserInputService:IsKeyDown(key) and not shared.UserInputService:GetFocusedTextBox()
            end
            Script.FakeRevive.Connections["AnimationHandler"] = shared.UserInputService.InputBegan:Connect(function(input)
                if shared.UserInputService:GetFocusedTextBox() then return end
                if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.S or input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.D then
                    playWalkingAnim(input.KeyCode)
                end
            end)
            shared.Connect:GiveSignal(Script.FakeRevive.Connections["AnimationHandler"])
            Script.FakeRevive.Connections["AnimationHandler2"] = shared.UserInputService.InputEnded:Connect(function(input)
                if shared.UserInputService:GetFocusedTextBox() then return end
                if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.S then
                    task.wait(0.1)
                    if walk.isPlaying then walk:Stop() end
                    if shared.Character:GetAttribute("Crouching") then 
                        if not crouch.isPlaying then crouch:Play() end
                        crouch:AdjustSpeed(0)
                    else 
                        if crouch.isPlaying then crouch:Stop() end 
                    end
                    if not idle.isPlaying then idle:Play() end
                end
            end)
            shared.Connect:GiveSignal(Script.FakeRevive.Connections["AnimationHandler2"])
            -- Tool Handler (kinda broken) --
            if shared.Character:WaitForChild("RightHand", math.huge) then
                local rightGrip = Instance.new("Weld", shared.Character.RightHand)
                rightGrip.C0 = CFrame.new(0, -0.15, -1.5, 1, 0, -0, 0, 0, 1, 0, -1, 0)
                rightGrip.Part0 = shared.Character.RightHand
                local toolsAnim = {}
                local currentTool = nil
                local doorInteractables = { "Key", "Lockpick" }
                Script.FakeRevive.Connections["ToolAnimHandler"] = shared.Character.ChildAdded:Connect(function(tool)
                    if tool:IsA("Tool") then
                        for _, anim in pairs(toolsAnim) do
                            anim:Stop()
                        end
                        table.clear(toolsAnim)
                        local anims = tool:WaitForChild("Animations")
                        currentTool = tool
                        for i, v in pairs(anims:GetChildren()) do
                            if v:IsA("Animation") then
                                toolsAnim[v.Name] = previewCharacter.Humanoid:LoadAnimation(v)
                            end
                        end
                        if toolsAnim.idle then toolsAnim.idle:Play(0.4, 1, 1) end
                        if toolsAnim.equip then toolsAnim.equip:Play(0.05, 1, 1) end
                        local toolHandle = tool:WaitForChild("Handle", 3)
                        if toolHandle and shared.Character:FindFirstChild("RightHand") then
                            rightGrip.Parent = shared.Character.RightHand
                            rightGrip.C1 = tool.Grip
                            rightGrip.Part1 = toolHandle        
                        end
                        local animation_state = false
                        tool.Activated:Connect(function()
                            if table.find(doorInteractables, tool.Name) then return end
                            local anim = toolsAnim.use or (tool:GetAttribute("LightSource") and toolsAnim.open)
                            if anim then
                                if wax.shared.ExecutorSupport["require"] then wax.require(tool.ToolModule).fire() end
                                local toolRemote = tool:FindFirstChild("Remote")
                                if toolRemote then
                                    toolRemote:FireServer()
                                end
                                if tool:GetAttribute("LightSource") then
                                    if animation_state then
                                        anim:Stop()
                                    else
                                        anim:Play()
                                    end
                                    animation_state = not animation_state
                                    return
                                end
                                anim:Play()
                            end
                        end)
                    end
                end)
                shared.Connect:GiveSignal(Script.FakeRevive.Connections["ToolAnimHandler"])
                -- Prompts handler
                local holding, holdStart, startDurability = false, 0, 0
                Script.FakeRevive.Connections["ToolAnimHandler2"] = shared.ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
                    if (currentTool and table.find(doorInteractables, currentTool.Name)) and (prompt.Name == "UnlockPrompt" and prompt.Parent.Name == "Lock") then
                        holding = true; holdStart = tick(); startDurability = currentTool:GetAttribute("Durability")
                        toolsAnim.use:Play()
                    end
                end)
                shared.Connect:GiveSignal(Script.FakeRevive.Connections["ToolAnimHandler2"])
                Script.FakeRevive.Connections["ToolAnimInteractHandler"] = shared.ProximityPromptService.PromptButtonHoldEnded:Connect(function(prompt)
                    if (currentTool and table.find(doorInteractables, currentTool.Name)) and (prompt.Name == "UnlockPrompt" and prompt.Parent.Name == "Lock") then
                        if holdStart == 0 then return end
                        if startDurability and currentTool:GetAttribute("Durability") < startDurability then
                            toolsAnim.use:Stop()
                            toolsAnim.usebreak:Play()
                            return
                        end
                        if holding and tick() - holdStart > prompt.HoldDuration then
                            holding = false; holdStart = 0
                            toolsAnim.use:Stop()
                            toolsAnim.usefinish:Play()
                            return
                        end
                        holding = false; holdStart = 0
                        toolsAnim.use:Stop()
                    end
                end)
                shared.Connect:GiveSignal(Script.FakeRevive.Connections["ToolAnimInteractHandler"])
                Script.FakeRevive.Connections["ToolAnimUnequipHandler"] = shared.Character.ChildRemoved:Connect(function(v)
                    if v:IsA("Tool") then
                        rightGrip.Part1 = nil
                        rightGrip.C1 = CFrame.new()
                        rightGrip.Parent = nil
                        for _, anim in pairs(toolsAnim) do
                            anim:Stop()
                        end
                        currentTool = nil
                    end
                end)
                shared.Connect:GiveSignal(Script.FakeRevive.Connections["ToolAnimUnequipHandler"])
            end
        end)
        -- movement code
        local function generateCharacterCFrame(obj)
            local obj_pos = obj.Position
            return CFrame.new(obj_pos, obj_pos - (Vector3.new(shared.Camera.CFrame.Position.X, obj_pos.Y, shared.Camera.CFrame.Position.Z) - obj_pos).unit)
        end
        local function usePreviewCharacter(doStepped)
            -- fuck you roblox for using head instead of primarypart or char:GetPivot() 
            -- mstudio45 2023 ^^
            if wax.shared.ExecutorSupport["hookmetamethod"] and wax.shared.ExecutorSupport["getnamecallmethod"] then
                shared.Hooks._fixDistanceFromCharacter = hookmetamethod(shared.LocalPlayer, "__namecall", function(self, ...)
                    local method = getnamecallmethod();
                    local args = {...}
                    if method == "DistanceFromCharacter" then
                        if typeof(args[1]) == "Vector3" then
                            return Script.Functions.DistanceFromCharacter(args[1])
                        end
                        return 9999;
                    end
                    return shared.Hooks._fixDistanceFromCharacter(self, ...)
                end)
            end
            if doStepped ~= false then
                shared.Library:Notify("You are not longer visible to others because you have lost Network Ownership of your shared.Character.", 5);
                for _,v in pairs(previewCharacter:GetDescendants()) do
                    if v:IsA("BasePart") then 
                        v.CanCollide = false
                    end
                end
                for _, connection in pairs(Script.FakeRevive.Connections) do
                    connection:Disconnect()
                end
                table.clear(Script.FakeRevive.Connections)
            end
            if previewCharacter:FindFirstChild("Humanoid") then previewCharacter.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None end
            Toggles.Fly:SetValue(true)
            shared.Connect:GiveSignal(shared.RunService.RenderStepped:Connect(function()
                if doStepped ~= false then previewCharacter:PivotTo(generateCharacterCFrame(shared.Character:GetPivot())) end
                if shared.RootPart then 
                    shared.RootPart.Transparency = (doStepped ~= false) and 1 or 0
                    shared.RootPart.CanCollide = false
                end
            end))
        end
        if shared.Character:FindFirstChild("LeftFoot") then shared.Character.LeftFoot.CanCollide = true end
        if shared.Character:FindFirstChild("RightFoot") then shared.Character.RightFoot.CanCollide = true end
        Script.FakeRevive.Connections["mainStepped"] = shared.RunService.RenderStepped:Connect(function()
            -- deivid gonna get mad at this line :content:
            if shared.Character:FindFirstChild("Humanoid") then shared.Character.Humanoid.WalkSpeed = Options.WalkSpeed.Value end
            if shared.RootPart and shared.RootPart.Position.Y < -150 then
                shared.RootPart.Position = workspace.SpawnLocation.Position
            end
            if shared.Character:FindFirstChild("UpperTorso") then
                shared.Character.UpperTorso.CanCollide = false 
            else
                if shared.Character:FindFirstChild("HumanoidRootPart") then 
                    local totalParts = 0
                    for _, v in pairs(shared.Character:GetChildren()) do if v:IsA("BasePart") then totalParts = totalParts + 1 end end
                    if totalParts <= 2 then
                        task.spawn(usePreviewCharacter)
                        Script.FakeRevive.Connections["mainStepped"]:Disconnect()
                        for _, connection in pairs(Script.FakeRevive.Connections) do
                            connection:Disconnect()
                        end
                        table.clear(Script.FakeRevive.Connections)
                        return
                    end
                end
            end
            if not shared.Character:FindFirstChild("HumanoidRootPart") then
                shared.Library:Notify("You have completely lost Network Ownership of your shared.Character which resulted of breaking Fake Death.", 5);
                task.spawn(usePreviewCharacter, false)
                Script.FakeRevive.Connections["mainStepped"]:Disconnect()
                for _, connection in pairs(Script.FakeRevive.Connections) do
                    connection:Disconnect()
                end
                table.clear(Script.FakeRevive.Connections)
                return
            end
            previewCharacter:PivotTo(generateCharacterCFrame(shared.RootPart.CFrame * CFrame.new(0,1000,0)))
            local charPartCFrames = {}
            for _, part in ipairs(previewCharacter:GetDescendants()) do
                if part:IsA("BasePart") then
                    charPartCFrames[part.Name..part.ClassName] = part.CFrame
                end
            end
            for _, part in ipairs(shared.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    if part.Name == "RagdollCollision" then
                        part.CFrame = (charPartCFrames[part.Parent.Name .. part.Parent.ClassName] - Vector3.new(0,1000,0))
                        part.CanCollide = true
                    else
                        if charPartCFrames[part.Name..part.ClassName] then
                            part.CFrame = (charPartCFrames[part.Name..part.ClassName] - Vector3.new(0,1000,0))
                        end
                    end
                    if part.Name ~= "HumanoidRootPart" then
                        if part.Parent == shared.Character or part.Parent:IsA("Accessory") then
                            part.LocalTransparencyModifier = 0
                        end
                        part.AssemblyAngularVelocity = Vector3.zero
                        part.AssemblyLinearVelocity = Vector3.zero
                    end
                end
            end
        end)
        shared.Connect:GiveSignal(Script.FakeRevive.Connections["mainStepped"])
        task.wait(0.1)
        local function fixUI()
            local setComponentVisibility = {
                Script.MainUI.HodlerRevive,
                Script.MainUI.Statistics,
                Script.MainUI.DeathPanelDead,
                Script.MainUI.DeathPanel,
                Script.MainUI.MainFrame.Healthbar,
                ["visible_real"] = Script.MainUI.MainFrame.PromptFrame.CenterImage,
                ["deivid_ballers_fake"] = Script.MainUI.MainFrame.PromptFrame.Holder,
                Script.MainUI.MainFrame.Hotbar,
                Script.MainUI.MainFrame.InventoryCap,
                Script.MainUI.MainFrame.InventoryLeftArrow,
                Script.MainUI.MainFrame.InventoryRightArrow,
            }
            for i,v in pairs(setComponentVisibility) do
                local target_visibility = (typeof(i) == "string" and true or false)
                v:GetPropertyChangedSignal("Visible"):Connect(function()
                    v.Visible = target_visibility
                end)
                v.Visible = target_visibility
            end
            shared.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
        end
        task.spawn(fixUI)
        shared.UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        shared.UserInputService.MouseIconEnabled = true
        shared.UserInputService.MouseIcon = "rbxassetid://2833720882"
        task.wait()
        shared.Character.HumanoidRootPart.Anchored = false
        if Script.MainGameSrc then Script.MainGameSrc.dead = false end
        shared.ProximityPromptService.Enabled = true
        Script.FakeRevive.Connections["ProximityPromptEnabler"] = shared.ProximityPromptService:GetPropertyChangedSignal("Enabled"):Connect(function()
            shared.ProximityPromptService.Enabled = true
        end)
        shared.Connect:GiveSignal(Script.FakeRevive.Connections["ProximityPromptEnabler"])
        workspace.Gravity = 90
        -- ESP Fix :smartindividual:
        for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
            task.spawn(function()
                local roomDetectPart = room:WaitForChild(room.Name, math.huge)
                if roomDetectPart then
                    roomDetectPart.Size = Vector3.new(roomDetectPart.Size.X, roomDetectPart.Size.Y * 250, roomDetectPart.Size.Z)
                    local touchEvent = roomDetectPart.Touched:Connect(function(hit)
                        if hit.Parent == shared.LocalPlayer.Character and not Script.FakeRevive.Debounce then
                            Script.FakeRevive.Debounce = true
                            shared.LocalPlayer:SetAttribute("CurrentRoom", tonumber(room.Name))
                            task.wait(0.075)
                            Script.FakeRevive.Debounce = false
                        end
                    end)
                    table.insert(Script.FakeRevive.Connections, touchEvent)
                    shared.Connect:GiveSignal(touchEvent)
                end
            end)
        end
        Script.FakeRevive.Connections["CurrentRoomFix"] = workspace.CurrentRooms.ChildAdded:Connect(function(room)
            local roomDetectPart = room:WaitForChild(room.Name, math.huge)
            if roomDetectPart then
                roomDetectPart.Size = Vector3.new(roomDetectPart.Size.X, roomDetectPart.Size.Y * 100, roomDetectPart.Size.Z)
                local touchEvent = roomDetectPart.Touched:Connect(function(hit)
                    if hit.Parent == shared.LocalPlayer.Character and not Script.FakeRevive.Debounce then
                        Script.FakeRevive.Debounce = true
                        shared.LocalPlayer:SetAttribute("CurrentRoom", tonumber(room.Name))
                        task.wait(0.075)
                        Script.FakeRevive.Debounce = false
                    end
                end)
                table.insert(Script.FakeRevive.Connections, touchEvent)
                shared.Connect:GiveSignal(touchEvent)
            end
        end)
        shared.Connect:GiveSignal(Script.FakeRevive.Connections["CurrentRoomFix"])
        shared.Notify:Alert({
            Title = "Dương Api",
            Description = "Tính năng đã hoạt động, chúc vui vẻ:))!",
            Reason = 'Hiện tại bạn đã bay màu :))',
        })
    end
end)
Toggles.CollisionOffsetGodmode:OnChanged(function(value)
    if not Script.Collision then return end
    if value then
        Script.Collision.CanCollide = false
        Script.Collision.CollisionCrouch.CanCollide = false
    else
        if Script.Collision.Position ~= shared.RootPart.Position then
            Script.Collision.Position = shared.RootPart.Position
            Script.CollisionClone.Position = Script.Collision.Position + Vector3.new(0, 2.5, 0) --idk what is the correct distance xD
        end
    end
end)
end)() end,
    [15] = function()local wax,script,require=ImportGlobals(15)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
local Tabs = Script.Tabs
--// Floor \\--
if Script.IsHotel then
    local Hotel_AntiEntityGroupBox = Tabs.Floor:AddLeftGroupbox("Chống quái") do
        Hotel_AntiEntityGroupBox:AddToggle("AntiSeekObstructions", {
            Text = "Xóa vật cản từ seek(beta)",
            Default = false
        })
    end
    local Hotel_BypassGroupBox = Tabs.Floor:AddLeftGroupbox("Bỏ qua") do
        Hotel_BypassGroupBox:AddToggle("AvoidRushAmbush", {
            Text = "Né Rush/Ambush",
            Tooltip = "Không hoạt động từ cửa 90 trở đi",
            Default = false,
            Risky = true
        })
    end
    local Hotel_FarmGroupBox = Tabs.Floor:AddLeftGroupbox("Cày (cần có hồi sinh)") do
        Hotel_FarmGroupBox:AddToggle("KnobFarm", {
            Text = "Cày knob",
            Tooltip = "Chỉ hoạt động ở cửa 100 và có figure xuất hiện",
            Default = false
        })
    end
    local CharacterEffectsGroupBox = Tabs.Floor:AddLeftGroupbox("Hiệu ứng người dùng") do
        -- Thêm Toggle cho Stun
        CharacterEffectsGroupBox:AddToggle("Stun", {
            Text = 'Giả chết',
            Default = false,
            Callback = function(value)
                local lplr = game.Players.LocalPlayer
                -- Thực thi hiệu ứng Stun
                if value then
                    lplr.Character:SetAttribute('Stunned', true)
                    lplr.Character.Humanoid:SetAttribute('Stunned', true)
                else
                    lplr.Character:SetAttribute('Stunned', false)
                    lplr.Character.Humanoid:SetAttribute('Stunned', false)
                end
            end
        })
        CharacterEffectsGroupBox:AddToggle("ThinkingAnimation", {
            Text = 'Hiệu ứng đang nghĩ',
            Default = false,
            Callback = function(value)
                local lplr = game.Players.LocalPlayer
                local thinkanims = {"18885101321", "18885098453", "18885095182"}
                if value then
                    local animation = Instance.new("Animation")
                    animation.AnimationId = "rbxassetid://" .. thinkanims[math.random(1, #thinkanims)]
                    animtrack = lplr.Character:FindFirstChildWhichIsA("Humanoid"):LoadAnimation(animation)
                    animtrack.Looped = true
                    animtrack:Play()
                else
                    if animtrack then
                        animtrack:Stop()
                        animtrack:Destroy()
                    end
                end
            end
        })
    end
    local Hotel_ModifiersGroupBox = Tabs.Floor:AddRightGroupbox("Chức năng khác") do
        Hotel_ModifiersGroupBox:AddToggle("NoVoiceActing", {
            Text = "Xóa âm thanh lồng tiếng",
            Default = false
        })
        Hotel_ModifiersGroupBox:AddToggle("AntiA90", {
            Text = "Xóa A90",
            Default = false
        })
        Hotel_ModifiersGroupBox:AddToggle("NoJammin", {
            Text = "Không có Jammin",
            Default = false
        })
    end
    local musicList = {
        { Name = "Dress", URL = "https://raw.githubusercontent.com/DuongTest1/Songroblox/main/dress.mp3" },
        { Name = "Slay", URL = "https://raw.githubusercontent.com/DuongTest1/Songroblox/main/slay.mp3" },
        { Name = "Money So Big", URL = "https://raw.githubusercontent.com/DuongTest1/Songroblox/main/moneysobig.mp3" },
        { Name = "Eu Sento Gabu", URL = "https://raw.githubusercontent.com/DuongTest1/Songroblox/main/eusentogabu.mp3" },
        { Name = "Glory", URL = "https://raw.githubusercontent.com/DuongTest1/Songroblox/main/glory.mp3" },
        { Name = "Bunny Girl Lofi", URL = "https://raw.githubusercontent.com/laitung1122/Score.M4/refs/heads/main/a.mp3" },
        { Name = "Another Song", URL = "https://link-to-another-song.mp3" }
    }
    local currentMusic, isPlaying, volume, duration, timePosition = nil, false, 2, 0, 0
    local updateTimeThread, SliderRef, TimeLabel
    local function stopCurrentMusic()
        if currentMusic then
            currentMusic:Stop()
            currentMusic:Destroy()
            currentMusic = nil
        end
    end
    local function updateMusicStatus()
        while isPlaying and currentMusic do
            timePosition = currentMusic.TimePosition
            SliderRef:SetValue(timePosition)
            TimeLabel.Text = string.format("Thời gian: %d / %d giây", math.floor(timePosition), math.floor(duration))
            task.wait(0.1)
        end
    end
    local function loadMusic(url, name)
        stopCurrentMusic()
        if not isfile(name .. ".mp3") then writefile(name .. ".mp3", game:HttpGet(url)) end
        local sound = Instance.new("Sound", game.SoundService)
        sound.SoundId = getcustomasset(name .. ".mp3")
        sound.Volume = volume
        sound:Play()
        sound.Ended:Connect(function() isPlaying = false end)
        task.spawn(function()
            repeat task.wait(0.1) until sound.TimeLength > 0
            duration = sound.TimeLength
            SliderRef:SetMax(duration)
            getgenv().Library:Notify("[Thành công] Thời lượng nhạc: " .. math.floor(duration) .. " giây", 4)
        end)
        return sound
    end
    local function playMusic(url, name)
        pcall(function()
            currentMusic = loadMusic(url, name)
            isPlaying = true
            getgenv().Library:Notify("[Thành công] Đang phát nhạc: " .. name, 4)
            task.spawn(updateMusicStatus)
        end)
    end
    local function controlMusic(action)
        if currentMusic then
            if action == "pause" then
                currentMusic:Pause()
                isPlaying = false
                getgenv().Library:Notify("[Thông báo] Nhạc đã tạm dừng", 4)
            elseif action == "resume" then
                currentMusic:Play()
                isPlaying = true
                getgenv().Library:Notify("[Thông báo] Nhạc đã tiếp tục", 4)
                task.spawn(updateMusicStatus)
            elseif action == "restart" then
                currentMusic.TimePosition = 0
                currentMusic:Play()
                isPlaying = true
                getgenv().Library:Notify("[Thông báo] Nhạc đang chạy lại từ đầu", 4)
                task.spawn(updateMusicStatus)
            elseif action == "stop" then
                stopCurrentMusic()
                isPlaying, duration, timePosition = false, 0, 0
                SliderRef:SetValue(0)
                SliderRef:SetMax(0)
                TimeLabel.Text = "Thời gian: 0 / 0 giây"
                getgenv().Library:Notify("[Thông báo] Nhạc đã dừng và bộ đếm đã được reset", 4)
            end
        end
    end
    local MusicPlayerGroupBox = Tabs.Floor:AddLeftGroupbox("Trình Phát Nhạc")
    local selectedMusic = musicList[1].Name
    MusicPlayerGroupBox:AddDropdown("MusicDropdown", {
        Values = {"Dress", "Slay", "Money So Big", "Eu Sento Gabu", "Glory", "Bunny Girl Lofi", "Another Song"},
        Default = 1,
        Text = "Chọn Nhạc",
        Tooltip = "Chọn bài nhạc để phát",
        Callback = function(value) selectedMusic = value end
    })
    MusicPlayerGroupBox:AddButton("Phát", function()
        for _, music in ipairs(musicList) do
            if music.Name == selectedMusic then
                playMusic(music.URL, music.Name)
                break
            end
        end
    end)
    MusicPlayerGroupBox:AddButton("Tạm dừng", function() controlMusic("pause") end)
    MusicPlayerGroupBox:AddButton("Tiếp tục", function() controlMusic("resume") end)
    MusicPlayerGroupBox:AddButton("Chạy lại", function() controlMusic("restart") end)
    MusicPlayerGroupBox:AddButton("Tắt nhạc", function() controlMusic("stop") end)
    SliderRef = MusicPlayerGroupBox:AddSlider("SeekSlider", {
        Text = "Tua nhạc",
        Default = 0,
        Min = 0,
        Max = 0,
        Rounding = 1,
        Callback = function(value) if currentMusic then currentMusic.TimePosition = value end end
    })
    TimeLabel = MusicPlayerGroupBox:AddLabel({ Text = "Thời gian: 0 / 0 giây" })
local ScriptLoaderGroupBox = Tabs.Floor:AddRightGroupbox("Dương DEX (lưu ý chỉ dành cho pc)") do
    ScriptLoaderGroupBox:AddButton("Chạy DEX", function()
        getgenv().Library:Notify("[Dương APi] Đang chạy script..", 4)
        local url = "https://raw.githubusercontent.com/laitung1122/Score.M4/refs/heads/main/duongdex.lua"
        local success, scriptString = pcall(function()
            return game:HttpGet(url)
        end)
        if success then
            local execSuccess, result = pcall(loadstring(scriptString))
            if execSuccess then
                getgenv().Library:Notify("[Success] Đã chạy script thành công", 4)
            else
                getgenv().Library:Notify("[Error] Chạy script thất bại với lỗi: " .. tostring(result), 4)
            end
        else
            getgenv().Library:Notify("[Error] Chạy script thất bại với lỗi: " .. tostring(scriptString), 4)
        end
    end)
end
    Toggles.AntiSeekObstructions:OnChanged(function(value)
        for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
            if v.Name == "ChandelierObstruction" or v.Name == "Seek_Arm" then
                for _, obj in pairs(v:GetDescendants()) do
                    if v:IsA("BasePart") then v.CanTouch = not value end
                end
            end
        end
    end)
    Toggles.KnobFarm:OnChanged(function(value)
        local reviveCutscene = shared.ReplicatedStorage:FindFirstChild("ReviveCutscene", true) or shared.ReplicatedStorage:FindFirstChild("_ReviveCutscene", true)
        if reviveCutscene then
            reviveCutscene.Name = if value then "_ReviveCutscene" else "ReviveCutscene"
        end
        if value then
            task.spawn(function()
                while task.wait(0.25) and Toggles.KnobFarm.Value and not shared.Library.Unloaded do
                    repeat task.wait() until Script.LatestRoom.Value == 100 or not (Toggles.KnobFarm.Value and not shared.Library.Unloaded)
                    if not (Toggles.KnobFarm.Value and not shared.Library.Unloaded) then break end
                    if not Script.Alive then
                        Script.RemotesFolder.Revive:FireServer()
                        repeat task.wait() until Script.Alive
                        task.wait(3)
                    end
                    local figure = workspace.CurrentRooms:FindFirstChild("FigureRig", true)
                    if figure then
                        repeat
                            task.wait()
                            shared.Character:PivotTo(figure.Root.CFrame)
                        until not Script.Alive or not (Toggles.KnobFarm.Value and not shared.Library.Unloaded)
                        if not (Toggles.KnobFarm.Value and not shared.Library.Unloaded) then break end
                        task.wait()
                        Script.RemotesFolder.Statistics:FireServer()
                    end
                end
            end)
        end
    end)
    Toggles.NoVoiceActing:OnChanged(function(value)
        local voiceActing = shared.ReplicatedStorage:FindFirstChild("VoiceActing")
        if not voiceActing then return end
        local voicelines = voiceActing:FindFirstChild("Voicelines") or voiceActing:FindFirstChild("_Voicelines")
        if voicelines then
            voicelines.Name = if value then "_Voicelines" else "Voicelines"
        end
    end)
    Toggles.AntiA90:OnChanged(function(value)
        if not Script.MainGame then return end
        local module = Script.MainGame:FindFirstChild("A90", true) or Script.MainGame:FindFirstChild("_A90", true)
        if module then
            module.Name = value and "_A90" or "A90"
        end
    end)
    Toggles.NoJammin:OnChanged(function(value)
        if not Script.LiveModifiers:FindFirstChild("Jammin") then return end
        if Script.MainGame then
            local jamSound = Script.MainGame:FindFirstChild("Jam", true)
            if jamSound then jamSound.Playing = not value end
        end
        local jamminEffect = shared.SoundService:FindFirstChild("Jamming", true)
        if jamminEffect then jamminEffect.Enabled = not value end
    end)
elseif Script.IsMines then
    local Mines_MovementGroupBox = Tabs.Floor:AddLeftGroupbox("Di chuyển") do
        Mines_MovementGroupBox:AddSlider("MaxSlopeAngle", {
            Text = "Góc nghiêng tối đa",
            Default = 45,
            Min = 0,
            Max = 90,
            Rounding = 0
        })
    end
    local Mines_AntiEntityGroupBox = Tabs.Floor:AddLeftGroupbox("Chống quái") do
        Mines_AntiEntityGroupBox:AddToggle("AntiGiggle", {
            Text = "Chống Giggle",
            Default = false
        })
        Mines_AntiEntityGroupBox:AddToggle("AntiGloomEgg", {
            Text = "Chống Gloom Egg",
            Default = false
        })
        Mines_AntiEntityGroupBox:AddToggle("AntiBridgeFall", {
            Text = "Chống Đá rơi vô đầu :)",
            Default = false
        })
        Mines_AntiEntityGroupBox:AddToggle("AntiPipeGap", {
            Text = "Chống Pipe Gap",
            Default = false
        })
        Mines_AntiEntityGroupBox:AddToggle("AntiSeekFlood", {
            Text = "Chống Seek Flood",
            Default = false
        })
    end
    local Mines_AutomationGroupBox = Tabs.Floor:AddRightGroupbox("Tự động") do
        Mines_AutomationGroupBox:AddButton({
            Text = "Phá đảo cửa 200",
            Func = function()
                if Script.LatestRoom.Value < 99 then
                    shared.Notify:Alert({
                        Title = "Dương Api",
                        Description = "Bạn chưa tới cửa 200...",
                        Time = 5
                    })
                    return
                end
                local bypassing = Toggles.SpeedBypass.Value
                local startPos = shared.RootPart.CFrame
                Toggles.SpeedBypass:SetValue(false)
                local damHandler = workspace.CurrentRooms[Script.LatestRoom.Value]:FindFirstChild("_DamHandler")
                if damHandler then
                    if damHandler:FindFirstChild("PlayerBarriers1") then
                        for _, pump in pairs(damHandler.Flood1.Pumps:GetChildren()) do
                            shared.Character:PivotTo(pump.Wheel.CFrame)
                            task.wait(0.25)
                            shared.forcefireproximityprompt(pump.Wheel.ValvePrompt)
                            task.wait(0.25)
                        end
                        task.wait(8)
                    end
                    if damHandler:FindFirstChild("PlayerBarriers2") then
                        for _, pump in pairs(damHandler.Flood2.Pumps:GetChildren()) do
                            shared.Character:PivotTo(pump.Wheel.CFrame)
                            task.wait(0.25)
                            shared.forcefireproximityprompt(pump.Wheel.ValvePrompt)
                            task.wait(0.25)
                        end
                        task.wait(8)
                    end
                    if damHandler:FindFirstChild("PlayerBarriers3") then
                        for _, pump in pairs(damHandler.Flood3.Pumps:GetChildren()) do
                            shared.Character:PivotTo(pump.Wheel.CFrame)
                            task.wait(0.25)
                            shared.forcefireproximityprompt(pump.Wheel.ValvePrompt)
                            task.wait(0.25)
                        end
                        task.wait(10)
                    end
                end
                local generator = workspace.CurrentRooms[shared.LatestRoom.Value]:FindFirstChild("MinesGenerator", true)
                if generator then
                    shared.Character:PivotTo(generator.PrimaryPart.CFrame)
                    task.wait(0.25)
                    shared.forcefireproximityprompt(generator.Lever.LeverPrompt)
                    task.wait(0.25)
                end
                Toggles.SpeedBypass:SetValue(bypassing)
                shared.Character:PivotTo(startPos)
            end
        })
        Mines_AutomationGroupBox:AddToggle("TheMinesAnticheatBypass", {
            Text = "Bỏ qua chống gian lận",
            Default = false
        })
    end
    local Mines_BypassGroupBox = Tabs.Floor:AddRightGroupbox("Bỏ qua") do
        Mines_BypassGroupBox:AddToggle("MinecartTeleport", {
            Text = "Dịch chuyển xe mỏ(beta)",
            Tooltip = "Rất rủi ro, không đảm bảo 100% hoạt động tốt",
            Default = false
        })
        Mines_BypassGroupBox:AddToggle("MinecartTeleportDebug", {
            Text = "Vá lỗi dịch chuyển",
            Tooltip = "Rất rủi ro, không đảm bảo 100% hoạt động tốt",
            Default = false,
            Visible = true,
        })
    end
    local Mines_VisualGroupBox = Tabs.Floor:AddRightGroupbox("Đường đi") do
        Mines_VisualGroupBox:AddToggle("MinecartPathVisualiser", {
            Text = "Hiển thị đường đi chính xác",
            Default = false
        })
    end
    Toggles.TheMinesAnticheatBypass:OnChanged(function(value)
        if value then
            local progressPart = Instance.new("Part", shared.Workspace) do
                progressPart.Anchored = true
                progressPart.CanCollide = false
                progressPart.Name = "_internal_mspaint_acbypassprogress"
                progressPart.Transparency = 1
            end
            if shared.Library.IsMobile then
                shared.Notify:Alert({
                    Title = "Dương Api",
                    Description = "To bypass the ac, you must interact with a ladder.",
                    Reason = "Ladder ESP has been enabled, do not move while on the ladder.",
                    LinoriaMessage = "To bypass the anticheat, you must interact with a ladder. Ladder ESP has been enabled.\nDo not move while on the ladder.",
                    Time = progressPart
                })
            else
                shared.Notify:Alert({
                    Title = "Dương Api",
                    Description = "To bypass the ac, you must interact with a ladder.",
                    Reason = "Ladder ESP has been enabled, do not move while on the ladder.",
                    LinoriaMessage = "To bypass the anticheat, you must interact with a ladder. Ladder ESP has been enabled.\nDo not move while on the ladder.",
                    Time = progressPart
                })
            end
            -- Ladder ESP
            for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
                if v:IsA("Model") and v.Name == "Ladder" then
                    Script.Functions.ESP({
                        Type = "None",
                        Object = v,
                        Text = "Ladder",
                        Color = Color3.new(0, 0, 1)
                    })
                end
            end
        else
            if workspace:FindFirstChild("_internal_mspaint_acbypassprogress") then workspace:FindFirstChild("_internal_mspaint_acbypassprogress"):Destroy() end
            for _, ladderEsp in pairs(Script.ESPTable.None) do
                ladderEsp.Destroy()
            end
            if Script.Bypassed and not Script.FakeRevive.Enabled then
                Script.RemotesFolder.ClimbLadder:FireServer()
                Script.Bypassed = false
                Options.WalkSpeed:SetMax(Toggles.SpeedBypass.Value and 75 or (Toggles.EnableJump.Value and 18 or 22))
                Options.FlySpeed:SetMax(Toggles.SpeedBypass.Value and 75 or 22)
            end
        end
    end)
    Options.MaxSlopeAngle:OnChanged(function(value)
        if shared.Humanoid then
            shared.Humanoid.MaxSlopeAngle = value
        end
    end)
    Toggles.AntiGiggle:OnChanged(function(value)
        for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
            for _, giggle in pairs(room:GetChildren()) do
                if giggle.Name == "GiggleCeiling" then
                    giggle:WaitForChild("Hitbox", 5).CanTouch = not value
                end
            end
        end
    end)
    -- this shits bad, but it doesnt go through all parts, so its optimized :cold_face:
    Toggles.AntiGloomEgg:OnChanged(function(value)
        for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
            for _, gloomPile in pairs(room:GetChildren()) do
                if gloomPile.Name == "GloomPile" then
                    for _, gloomEgg in pairs(gloomPile:GetDescendants()) do
                        if gloomEgg.Name == "Egg" then
                            gloomEgg.CanTouch = not value
                        end
                    end
                end
            end
        end
    end)
    Toggles.AntiBridgeFall:OnChanged(function(value)
        if value then
            for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
                if not room:FindFirstChild("Parts") then continue end
                for _, bridge in pairs(room.Parts:GetChildren()) do
                    if bridge.Name == "Bridge" then
                        for _, barrier in pairs(bridge:GetChildren()) do
                            if not (barrier.Name == "PlayerBarrier" and barrier.Size.Y == 2.75 and (barrier.Rotation.X == 0 or barrier.Rotation.X == 180)) then continue end
                            local clone = barrier:Clone()
                            clone.CFrame = clone.CFrame * CFrame.new(0, 0, -5)
                            clone.Color = Color3.new(1, 1, 1)
                            clone.Name = "AntiBridge"
                            clone.Size = Vector3.new(clone.Size.X, clone.Size.Y, 11)
                            clone.Transparency = 0
                            clone.Parent = bridge
                            table.insert(Script.Temp.Bridges, clone)
                        end
                    end
                end
            end
        else
            for _, bridge in pairs(Script.Temp.Bridges) do
                bridge:Destroy()
            end
        end
    end)
    Toggles.AntiPipeGap:OnChanged(function(value)
        if value then
            for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
                if not room:FindFirstChild("Assets") then continue end
                for _, killBrick in pairs(room.Assets:GetChildren()) do
                    if killBrick.Name == "KillBrick" then
                        local clone = killBrick:Clone()
                        clone.Color = Color3.new(1, 1, 1)
                        clone.Name = "AntiPipeGap"
                        clone.Position += Vector3.new(0, 20, 0)
                        clone.Size = Vector3.new(9, 4, clone.Size.Z)
                        clone.Transparency = 0
                        clone.Parent = killBrick.Parent
                        table.insert(Script.Temp.PipeBridges, clone)
                    end
                end
            end
        else
            for _, bridge in pairs(Script.Temp.PipeBridges) do
                bridge:Destroy()
            end
        end
    end)
    Toggles.AntiSeekFlood:OnChanged(function(value)
        local room = workspace.CurrentRooms:FindFirstChild("100")
        if room and room:FindFirstChild("_DamHandler") then
            local seekFlood = room._DamHandler:FindFirstChild("SeekFloodline")
            if seekFlood then
                seekFlood.CanCollide = value
            end
        end
    end)
    Toggles.MinecartTeleport:OnChanged(function(value)
        if value then
            for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
                task.spawn(Script.Functions.Minecart.Teleport, room)
            end
        end
    end)
    Toggles.MinecartPathVisualiser:OnChanged(function(value)
        for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
            task.spawn(Script.Functions.Minecart.DrawNodes, room)
        end
    end)
elseif Script.IsBackdoor then
    local Backdoors_AntiEntityGroupBox = Tabs.Floor:AddLeftGroupbox("Anti-Entity") do
        Backdoors_AntiEntityGroupBox:AddToggle("AntiHasteJumpscare", {
            Text = "Chống haste dọa",
            Default = false
        })
    end
    local Backdoors_VisualGroupBox = Tabs.Floor:AddRightGroupbox("Visual") do
        Backdoors_VisualGroupBox:AddToggle("HasteClock", {
            Text = "Đồng hồ haste",
            Default = true
        })
    end
    Toggles.AntiHasteJumpscare:OnChanged(function(value)
        local clientRemote = shared.ReplicatedStorage.FloorReplicated.ClientRemote
        local internal_temp_mspaint = clientRemote:FindFirstChild("_mspaint")
        if not internal_temp_mspaint then internal_temp_mspaint = Instance.new("Folder", clientRemote); internal_temp_mspaint.Name = "_mspaint" end
        if value then
            for i,v in pairs(clientRemote.Haste:GetChildren()) do
                if v:IsA("RemoteEvent") then continue end
                v.Parent = internal_temp_mspaint
            end
        else
            for i,v in pairs(internal_temp_mspaint:GetChildren()) do
                v.Parent = clientRemote.Haste
            end
        end
    end)
    Toggles.HasteClock:OnChanged(function(value)
        if not value then
            Script.Functions.HideCaptions()
        end
    end)
    function Script.Functions.TimerFormat(seconds: number)
        local minutes = math.floor(seconds / 60)
        local remainingSeconds = seconds % 60
        return string.format("%02d:%02d", minutes, remainingSeconds)
    end
    shared.Connect:GiveSignal(Script.FloorReplicated.DigitalTimer:GetPropertyChangedSignal("Value"):Connect(function()
        if Toggles.HasteClock.Value and Script.FloorReplicated.ScaryStartsNow.Value then
            Script.Functions.Captions(Script.Functions.TimerFormat(Script.FloorReplicated.DigitalTimer.Value))
        end
    end))
elseif Script.IsRooms then
    local Rooms_AntiEntityGroupBox = Tabs.Floor:AddLeftGroupbox("Anti-Entity") do
        Rooms_AntiEntityGroupBox:AddToggle("AntiA90", {
            Text = "Xóa A90",
            Default = false
        })
    end
    local Rooms_AutomationGroupBox = Tabs.Floor:AddRightGroupbox("Tự động") do
        Rooms_AutomationGroupBox:AddToggle("AutoRooms", {
            Text = "Tự động A1000",
            Default = false
        })
        Rooms_AutomationGroupBox:AddLabel("Cài đặt khuyên dùng:\nTốc độ chạy 22-30 và tắt xuyên tường", true)
        Rooms_AutomationGroupBox:AddDivider()
        Rooms_AutomationGroupBox:AddToggle("AutoRoomsDebug", { 
            Text = "Hiển thị vá lỗi",
            Default = false
        })
        Rooms_AutomationGroupBox:AddToggle("ShowAutoRoomsPathNodes", { 
            Text = "Hiển thị ghi chú",
            Default = true
        })
    end
    Toggles.AntiA90:OnChanged(function(value)
        if Toggles.AutoRooms.Value and not value then
            shared.Notify:Alert({
                Title = "Dương Api",
                Description = "Tính năng xóa A90 cần thiết để chạy ổn định!",
                Reason = "Đã bật tính năng xóa A90",
            })
            Toggles.AntiA90:SetValue(true)
        end
        if not Script.MainGame then return end
        local module = Script.MainGame:FindFirstChild("A90", true) or Script.MainGame:FindFirstChild("_A90", true)
        if module then
            module.Name = value and "_A90" or "A90"
        end
    end)
    function Script.Functions.GetAutoRoomsPathfindingGoal(): BasePart
        local entity = (workspace:FindFirstChild("A60") or workspace:FindFirstChild("A120"))
        if entity and entity.PrimaryPart.Position.Y > -10 then
            local GoalLocker = Script.Functions.GetNearestAssetWithCondition(function(asset)
                return asset.Name == "Rooms_Locker" and not asset.HiddenPlayer.Value and asset.PrimaryPart.Position.Y > -10
            end)
            return GoalLocker.PrimaryPart
        end
        return workspace.CurrentRooms[Script.LatestRoom.Value].RoomExit
    end
    local _internal_mspaint_pathfinding_nodes = Instance.new("Folder", shared.Workspace) do
        _internal_mspaint_pathfinding_nodes.Name = "_internal_mspaint_pathfinding_nodes"
    end
    local _internal_mspaint_pathfinding_block = Instance.new("Folder", shared.Workspace) do
        _internal_mspaint_pathfinding_block.Name = "_internal_mspaint_pathfinding_block"
    end
    Toggles.ShowAutoRoomsPathNodes:OnChanged(function(value)
        for _, node in pairs(_internal_mspaint_pathfinding_nodes:GetChildren()) do
            node.Transparency = value and 0.5 or 1
        end
        for _, nodeBlock in pairs(_internal_mspaint_pathfinding_block:GetChildren()) do
            nodeBlock.Transparency = value and 0.9 or 1
        end
    end)
    shared.Connect:GiveSignal(shared.RunService.RenderStepped:Connect(function()
        if not Toggles.AutoRooms.Value then return end
        local entity = (workspace:FindFirstChild("A60") or workspace:FindFirstChild("A120"))
        local isEntitySpawned = (entity and entity.PrimaryPart.Position.Y > -10)
        if isEntitySpawned and not shared.RootPart.Anchored then
            local pathfindingGoal = Script.Functions.GetAutoRoomsPathfindingGoal()
            if Script.Functions.IsPromptInRange(pathfindingGoal.Parent.HidePrompt) then
                shared.forcefireproximityprompt(pathfindingGoal.Parent.HidePrompt)
            end
        elseif not isEntitySpawned and shared.RootPart.Anchored then
            for i = 1, 10 do
                Script.RemotesFolder.CamLock:FireServer()
            end
        end
    end))
    Toggles.AutoRooms:OnChanged(function(value)
        local hasResetFailsafe = false
        local function nodeCleanup()
            _internal_mspaint_pathfinding_nodes:ClearAllChildren()
            _internal_mspaint_pathfinding_block:ClearAllChildren()
            hasResetFailsafe = true
        end
        local function moveToCleanup()
            if shared.Humanoid then
                shared.Humanoid:Move(shared.RootPart.Position)
                shared.Humanoid.WalkToPart = nil
                shared.Humanoid.WalkToPoint = shared.RootPart.Position
            end
            nodeCleanup()
        end
        if value then
            Toggles.AntiA90:SetValue(true)
            local lastRoomValue = 0
            local function createNewBlockedPoint(point: PathWaypoint)
                local block = Instance.new("Part", _internal_mspaint_pathfinding_block)
                local pathMod = Instance.new("PathfindingModifier", block)
                pathMod.Label = "_ms_pathBlock"
                block.Name = "_mspaint_blocked_path"
                block.Shape = Enum.PartType.Block
                local sizeY = 10
                block.Size = Vector3.new(1, sizeY, 1)
                block.Color = Color3.fromRGB(255, 130, 30)
                block.Material = Enum.Material.Neon
                block.Position = point.Position + Vector3.new(0, sizeY / 2, 0)
                block.Anchored = true
                block.CanCollide = false
                block.Transparency = Toggles.ShowAutoRoomsPathNodes.Value and 0.9 or 1
            end
            local function doAutoRooms()
                local pathfindingGoal = Script.Functions.GetAutoRoomsPathfindingGoal()
                if Script.LatestRoom.Value ~= lastRoomValue then
                    _internal_mspaint_pathfinding_block:ClearAllChildren()
                    lastRoomValue = Script.LatestRoom.Value
                end
               --shared.Notify:Log({
                    --Title = "Dương Api",
                    --Description = "Xác định vật thể thành công",
                --}, Toggles.AutoRoomsDebug.Value)
                local path = shared.PathfindingService:CreatePath({
                    AgentCanJump = false,
                    AgentCanClimb = false,
                    WaypointSpacing = 2,
                    AgentRadius = 1,
                    Costs = {
                        _ms_pathBlock = 8 --cost will increase the more stuck you get.
                    }
                })
                --shared.Notify:Log({
                    --Title = "Dương Api",
                    --Description = "Đang tạo đường đi...",
                --}, Toggles.AutoRoomsDebug.Value)
                path:ComputeAsync(shared.RootPart.Position - Vector3.new(0, 2.5, 0), pathfindingGoal.Position)
                local waypoints = path:GetWaypoints()
                local waypointAmount = #waypoints
                if path.Status == Enum.PathStatus.Success then
                    hasResetFailsafe = true
                    task.spawn(function()
                        task.wait(0.1)
                        hasResetFailsafe = false
                        if shared.Humanoid and Script.Collision then
                            local checkFloor = shared.Humanoid.FloorMaterial
                            local isStuck = checkFloor == Enum.Material.Air or checkFloor == Enum.Material.Concrete
                            if isStuck then
                                repeat task.wait()
                                    Script.Collision.CanCollide = false
                                    Script.Collision.CollisionCrouch.CanCollide = not (Toggles.CollisionOffsetGodmode.Value or shared.Library.IsMobile or Options.CollisionOffsetGodmodeKey:GetState())
                                until not isStuck or hasResetFailsafe
                                Script.Collision.CanCollide = not (Toggles.CollisionOffsetGodmode.Value and (shared.Library.IsMobile or Options.CollisionOffsetGodmodeKey:GetState()))
                            end
                            hasResetFailsafe = true
                        end
                    end)
                    shared.Notify:Log({
                        Title = "Dương Api",
                        Description = "Xác định thành công, đã tạo " .. waypointAmount .. " điểm!",
                    }, Toggles.AutoRoomsDebug.Value)
                    _internal_mspaint_pathfinding_nodes:ClearAllChildren()
                    for i, waypoint in pairs(waypoints) do
                        local node = Instance.new("Part", _internal_mspaint_pathfinding_nodes) do
                            node.Name = "_internal_node_" .. i
                            node.Size = Vector3.new(1, 1, 1)
                            node.Position = waypoint.Position
                            node.Anchored = true
                            node.CanCollide = false
                            node.Shape = Enum.PartType.Ball
                            node.Color = Color3.new(1, 0, 0)
                            node.Transparency = Toggles.ShowAutoRoomsPathNodes.Value and 0.5 or 1
                        end
                    end
                    local lastWaypoint = nil
                    for i, waypoint in pairs(waypoints) do
                        local moveToFinished = false
                        local recalculate = false
                        local waypointConnection = shared.Humanoid.MoveToFinished:Connect(function() moveToFinished = true end)
                        if not moveToFinished or not Toggles.AutoRooms.Value then
                            shared.Humanoid:MoveTo(waypoint.Position)
                            local entity = (workspace:FindFirstChild("A60") or workspace:FindFirstChild("A120"))
                            local isEntitySpawned = (entity and entity.PrimaryPart.Position.Y > -10)
                            if isEntitySpawned and not shared.RootPart.Anchored and pathfindingGoal.Parent.Name ~= "Rooms_Locker" then
                                waypointConnection:Disconnect()
                                if not Toggles.AutoRooms.Value then
                                    nodeCleanup()
                                    break
                                else
                                    if _internal_mspaint_pathfinding_nodes:FindFirstChild("_internal_node_" .. i) then
                                        _internal_mspaint_pathfinding_nodes:FindFirstChild("_internal_node_" .. i):Destroy()
                                    end
                                end
                                break
                            end
                            task.delay(1, function()
                                if moveToFinished then return end
                                if (not Toggles.AutoRooms.Value or shared.Library.Unloaded) then return moveToCleanup() end
                                repeat task.wait(0.25) until (not shared.Character:GetAttribute("Hiding") and not shared.Character.PrimaryPart.Anchored)
                                shared.Notify:Alert({
                                    Title = "Dương Api",
                                    Description = "Có vẻ bạn đang bị kẹt, đang tính toán đường mới...",
                                    Reason = "Thất bại khi di chuyển tới điểm chấm",
                                })
                                recalculate = true
                                if lastWaypoint == nil and waypointAmount > 1 then
                                    waypoint = waypoints[i+1]
                                else
                                    waypoint = waypoints[i-1]
                                end
                                createNewBlockedPoint(waypoint)
                            end)
                        end
                        repeat task.wait() until moveToFinished or not Toggles.AutoRooms.Value or recalculate or shared.Library.Unloaded
                        lastWaypoint = waypoint
                        waypointConnection:Disconnect()
                        if not Toggles.AutoRooms.Value then
                            nodeCleanup()
                            break
                        else
                            if _internal_mspaint_pathfinding_nodes:FindFirstChild("_internal_node_" .. i) then
                                _internal_mspaint_pathfinding_nodes:FindFirstChild("_internal_node_" .. i):Destroy()
                            end
                        end
                        if recalculate then break end
                    end
                else
                    shared.Notify:Log({
                        Title = "Dương Api",
                        Description = "Tính toán thất bại với lỗi " .. tostring(path.Status)   
                    }, Toggles.AutoRoomsDebug.Value)
                end
            end
            -- Movement
            while Toggles.AutoRooms.Value and not shared.Library.Unloaded do
                if Script.LatestRoom.Value == 1000 then
                    shared.Notify:Alert({
                        Title = "Dương Api",
                        Description = "Bạn đã tới A-1000",
                        Reason = "A-1000 sửa lại bởi dương",
                    })
                    break
                end
                doAutoRooms()
            end
            moveToCleanup()
        end
    end)
elseif Script.IsFools then
    local Fools_TrollingGroupBox = Tabs.Floor:AddLeftGroupbox("Trolling") do
        Fools_TrollingGroupBox:AddToggle("GrabBananaJeffToggle",{
            Text = "Nhặt Banana / Jeff",
            Default = false
        }):AddKeyPicker("GrabBananaJeff", {
            Default = "H",
            Mode = "Hold",
            Text = "Nhặt Banana / Jeff",
        })
        Fools_TrollingGroupBox:AddLabel("Throw"):AddKeyPicker("ThrowBananaJeff", {
            Default = "G",
            Mode = "Hold",
            Text = "Ném"
        })
        Fools_TrollingGroupBox:AddSlider("ThrowStrength", {
            Text = "Lực ném",
            Default = 1,
            Min = 1,
            Max = 10,
            Rounding = 1,
            Compact = true
        })
        function Script.Functions.ThrowBananaJeff()
            local target = Script.Temp.HoldingItem
            Script.Tracks.ItemHoldTrack:Stop()
            Script.Tracks.ItemThrowTrack:Play()
            task.wait(0.35)
            if target:FindFirstChildWhichIsA("BodyGyro") then
                target:FindFirstChildWhichIsA("BodyGyro"):Destroy()
            end
            local velocity = shared.LocalPlayer:GetMouse().Hit.LookVector * 0.5 * 200 * Options.ThrowStrength.Value
            local spawnPos = shared.Camera.CFrame:ToWorldSpace(CFrame.new(0,0,-3) * CFrame.lookAt(Vector3.new(0, 0, 0), shared.Camera.CFrame.LookVector))
            target.CFrame = spawnPos
            target.Velocity = velocity
            if target:FindFirstAncestorWhichIsA("Model").Name == "JeffTheKiller" then
                for _,i in ipairs(target:FindFirstAncestorWhichIsA("Model"):GetDescendants()) do
                    if i:IsA("BasePart") then
                        i.CanTouch = not Toggles.AntiJeffClient.Value
                        i.CanCollide = i:GetAttribute("Clip") or true
                    end
                end
            else
                target.CanTouch = not Toggles.AntiBananaPeel.Value
                target.CanCollide = target:GetAttribute("Clip") or true
            end
            Script.Temp.HoldingItem = nil
        end
    end
    local Fools_AntiEntityGroupBox = Tabs.Floor:AddRightGroupbox("Anti-Entity") do
        Fools_AntiEntityGroupBox:AddToggle("AntiSeekObstructions", {
            Text = "Xóa vật cản từ seek",
            Default = false
        })
        Fools_AntiEntityGroupBox:AddToggle("AntiBananaPeel", {
            Text = "Chống Banana",
            Default = false
        })
        Fools_AntiEntityGroupBox:AddToggle("AntiJeffClient", {
            Text = "Chống Jeff",
            Default = false
        })
    end
    local Fools_BypassGroupBox = Tabs.Floor:AddRightGroupbox("Bypass") do
        Fools_BypassGroupBox:AddToggle("InfRevives", {
            Text = "Hồi sinh vô tận",
            Default = false
        })
        Fools_BypassGroupBox:AddToggle("AntiJeffServer", {
            Text = "Xóa jeff (FE)",
            Default = false
        })
        Fools_BypassGroupBox:AddDivider()
        Fools_BypassGroupBox:AddToggle("GodmodeNoclipBypassFools", {
            Text = "Bất tử",
            Default = false
        })
        Fools_BypassGroupBox:AddToggle("FigureGodmodeFools", {
            Text = "Bất tử trước figure",
            Default = false
        })
    end
    Toggles.AntiSeekObstructions:OnChanged(function(value)
        for i, v in pairs(workspace.CurrentRooms:GetDescendants()) do
            if v.Name == "ChandelierObstruction" or v.Name == "Seek_Arm" then
                for _, obj in pairs(v:GetDescendants()) do
                    if v:IsA("BasePart") then v.CanTouch = not value end
                end
            end
        end
    end)
    Toggles.AntiBananaPeel:OnChanged(function(value)
        for _, peel in pairs(workspace:GetChildren()) do
            if peel.Name == "BananaPeel" then
                peel.CanTouch = not value
            end
        end
    end)
    Toggles.AntiJeffClient:OnChanged(function(value)
        for _, jeff in pairs(workspace:GetChildren()) do
            if jeff:IsA("Model") and jeff.Name == "JeffTheKiller" then
                for i, v in pairs(jeff:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v.CanTouch = not value
                    end
                end
            end
        end
    end)
    Toggles.AntiJeffServer:OnChanged(function(value)
        if value then
            for _, jeff in pairs(workspace:GetChildren()) do
                if jeff:IsA("Model") and jeff.Name == "JeffTheKiller" then
                    task.spawn(function()
                        repeat task.wait() until shared.isnetworkowner(jeff.PrimaryPart)
                        jeff:FindFirstChildOfClass("Humanoid").Health = 0
                    end)
                end
            end
        end
    end)
    Toggles.InfRevives:OnChanged(function(value)
        if value and not shared.LocalPlayer:GetAttribute("Alive") then
            Script.RemotesFolder.Revive:FireServer()
        end
    end)
    Toggles.GodmodeNoclipBypassFools:OnChanged(function(value)
        if value and shared.Humanoid and Script.Collision then
            shared.Humanoid.HipHeight = 3.01
            task.wait()
            Script.Collision.Position = Script.Collision.Position - Vector3.new(0, 8, 0)
            task.wait()
            shared.Humanoid.HipHeight = 3
            -- don't want to put collision up when you load the script 
            -- im sorry deivid
            task.spawn(function()
                repeat task.wait() until not Toggles.GodmodeNoclipBypassFools.Value
                shared.Humanoid.HipHeight = 3.01
                task.wait()
                Script.Collision.Position = Script.Collision.Position + Vector3.new(0, 8, 0)
                task.wait()
                shared.Humanoid.HipHeight = 3
            end)
        end
    end)
    Toggles.FigureGodmodeFools:OnChanged(function(value)
        if value and not Toggles.GodmodeNoclipBypassFools.Value then Toggles.GodmodeNoclipBypassFools:SetValue(true); shared.Notify:Alert({Title = "Figure Godmode", Description = "Godmode/Noclip Bypass is required to use figure godmode", Reason = "Godmode/Noclip Bypass not enabled"}) end
        if Script.LatestRoom.Value ~= 50 or Script.LatestRoom.Value ~= 100 then return end
        for _, figure in pairs(workspace.CurrentRooms:GetDescendants()) do
            if figure:IsA("Model") and figure.Name == "FigureRagdoll" then
                for i, v in pairs(figure:GetDescendants()) do
                    if v:IsA("BasePart") then
                        if not v:GetAttribute("Clip") then v:SetAttribute("Clip", v.CanCollide) end
                        v.CanTouch = not value
                        v.CanCollide = not value
                    end
                end
            end
        end
    end)
end
end)() end,
    [16] = function()local wax,script,require=ImportGlobals(16)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
local Tabs = Script.Tabs
--// Main \\--
local PlayerGroupBox = Tabs.Main:AddLeftGroupbox("Người chơi") do
    PlayerGroupBox:AddToggle("EnableSpeedHack", {
        Text = "Áp dụng tốc độ",
        Default = false
    })
    PlayerGroupBox:AddSlider("WalkSpeed", {
        Text = "Tốc độ",
        Default = 15,
        Min = 0,
        Max = 22,
        Rounding = 0,
        Compact = true
    })
    PlayerGroupBox:AddSlider("LadderSpeed", {
        Text = "Tốc độ leo thang",
        Default = 15,
        Min = 0,
        Max = 75,
        Rounding = 0,
        Compact = true
    })
    PlayerGroupBox:AddToggle("EnableJump", {
        Text = "Nút nhảy",
        Default = false,
        Visible = not Script.IsFools
    })
    PlayerGroupBox:AddSlider("JumpBoost", {
        Text = "Lực nhảy",
        Default = 5,
        Min = 0,
        Max = 50,
        Rounding = 0,
        Compact = true,
        Visible = not Script.IsFools
    })
    PlayerGroupBox:AddToggle("NoAccel", {
        Text = "Không gia tốc",
        Default = false
    })
    PlayerGroupBox:AddDivider()
    PlayerGroupBox:AddToggle("InstaInteract", {
        Text = "Tương tác tức thì",
        Default = false
    })
    PlayerGroupBox:AddToggle("FastClosetExit", {
        Text = "Thoát khỏi tủ nhanh",
        Default = false
    })
    PlayerGroupBox:AddDivider()
    PlayerGroupBox:AddToggle("Noclip", {
        Text = "Xuyên tường",
        Default = false
    }):AddKeyPicker("NoclipKey", {
        Mode = "Toggle",
        Default = "N",
        Text = "Xuyên tuòng",
        SyncToggleState = true
    })
    PlayerGroupBox:AddToggle("Fly", {
        Text = "Bay",
        Default = false
    }):AddKeyPicker("FlyKey", {
        Mode = "Toggle",
        Default = "F",
        Text = "Bay",
        SyncToggleState = true
    })
    PlayerGroupBox:AddSlider("FlySpeed", {
        Text = "Tốc độ bay",
        Default = 15,
        Min = 10,
        Max = 22,
        Rounding = 1,
        Compact = true,
    })
end
local ReachGroupBox = Tabs.Main:AddLeftGroupbox("Thao tác") do
    ReachGroupBox:AddToggle("DoorReach", {
        Text = "Mở cửa từ xa",
        Default = false
    })
    ReachGroupBox:AddToggle("PromptClip", {
        Text = "Clip nhắc nhở",
        Default = false
    })
    ReachGroupBox:AddSlider("PromptReachMultiplier", {
        Text = "Khoảng cách mở",
        Default = 1,
        Min = 1,
        Max = 2,
        Rounding = 1
    })
end
local AutomationGroupBox = Tabs.Main:AddRightGroupbox("Tự động") do
    AutomationGroupBox:AddToggle("AutoInteract", {
        Text = "Tự động mở + nhặt",
        Default = true
    }):AddKeyPicker("AutoInteractKey", {
        Mode = shared.Library.IsMobile and "Toggle" or "Hold",
        Default = "R",
        Text = "Tự động mở + nhặt",
        SyncToggleState = shared.Library.IsMobile
    })
    AutomationGroupBox:AddDropdown("AutoInteractIgnore", {
        AllowNull = true,
        Values = {"Jeff Items", "Unlock w/ Lockpick", "Paintings", "Gold", "Light Source Items", "Skull Prompt"},
        Default = {"Jeff Items","Paintings"},
        Multi = true,
        Text = "Ignore List"
    })
    AutomationGroupBox:AddDivider()
    AutomationGroupBox:AddToggle("AutoWardrobeNotif", {
        Text = "Thông báo tự động ẩn nấp",
        Default = false
    })
    AutomationGroupBox:AddToggle("AutoWardrobe", {
        Text = "Tự động ẩn nấp",
        Default = false,
        Tooltip = "Có thể lỗi khi gặp quá nhiều quái cùng lúc",
        Visible = not Script.IsRetro,
        Risky = true
    }):AddKeyPicker("AutoWardrobeKey", {
        Mode = "Toggle",
        Default = "Q",
        Text = "Tự động ẩn nấp",
        SyncToggleState = true
    })
    AutomationGroupBox:AddDivider()
    AutomationGroupBox:AddToggle("AutoHeartbeat", {
        Text = "Tự động win mini game tim đập",
        Default = false,
        Visible = wax.shared.ExecutorSupport["getnamecallmethod"]
    })
    if Script.IsHotel or Script.IsFools then
        AutomationGroupBox:AddToggle("AutoLibrarySolver", {
            Text = "Tự động giải mã thư viện",
            Default = false
        })
        AutomationGroupBox:AddSlider("AutoLibraryDistance", {
            Text = "Khoảng cách giải mã",
            Default = 20,
            Min = 1,
            Max = 100,
            Rounding = 0,
            Compact = true
        })
        AutomationGroupBox:AddDivider()
        AutomationGroupBox:AddDropdown("AutoBreakerSolverMethod", {
            AllowNull = false,
            Values = {"Legit", "Exploit"},
            Default = "Legit",
            Multi = false,
            Text = "Phương pháp giải mã hộp cầu chì"
        })
        AutomationGroupBox:AddToggle("AutoBreakerSolver", {
            Text = "Tự động giải mã hộp cầu chì",
            Default = false
        })
        Toggles.AutoLibrarySolver:OnChanged(function(value)
            if value then
                for _, player in pairs(shared.Players:GetPlayers()) do
                    if not player.Character then continue end
                    local tool = player.Character:FindFirstChildOfClass("Tool")
                    if tool and tool.Name:match("LibraryHintPaper") then
                        local code = Script.Functions.GetPadlockCode(tool)
                        local padlock = workspace:FindFirstChild("Padlock", true)
                        if tonumber(code) and Script.Functions.DistanceFromCharacter(padlock) <= Options.AutoLibraryDistance.Value then
                            Script.RemotesFolder.PL:FireServer(code)
                        end
                    end
                end
            end
        end)
        Toggles.AutoBreakerSolver:OnChanged(function(value)
            if value then
                local elevatorBreaker = workspace.CurrentRooms:FindFirstChild("ElevatorBreaker", true)
                if not elevatorBreaker then return end
                Script.Functions.SolveBreakerBox(elevatorBreaker)
            end
        end)
    elseif Script.IsMines then
        AutomationGroupBox:AddToggle("AutoAnchorSolver", {
            Text = "Tự động giải mã trụ điện",
            Default = false
        })
    end
end
local MiscGroupBox = Tabs.Main:AddRightGroupbox("Tính năng phụ") do
    MiscGroupBox:AddButton({
        Text = "Hồi sinh",
        Func = function()
            Script.RemotesFolder.Revive:FireServer()
        end,
        DoubleClick = true
    })
    MiscGroupBox:AddButton({
        Text = "Chơi lại",
        Func = function()
            Script.RemotesFolder.PlayAgain:FireServer()
        end,
        DoubleClick = true
    })
    MiscGroupBox:AddButton({
        Text = "Về sảnh",
        Func = function()
            Script.RemotesFolder.Lobby:FireServer()
        end,
        DoubleClick = true
    })
end
--// Player \\--
Toggles.EnableJump:OnChanged(function(value)
    if Script.IsFools then return end
    if shared.Character then
        shared.Character:SetAttribute("CanJump", value)
    end
    if not value and shared.CheckToggle("SpeedBypass", true) and Options.WalkSpeed.Max ~= 22 and not Script.FakeRevive.Enabled then
        Options.WalkSpeed:SetMax(22)
    end
end)
Options.JumpBoost:OnChanged(function(value)
    if Script.IsFools or not Toggles.EnableJump.Value then return end
    shared.Humanoid.JumpHeight = value
end)
Toggles.NoAccel:OnChanged(function(value)
    if not shared.RootPart then return end
    if value then
        Script.Temp.NoAccelValue = shared.RootPart.CustomPhysicalProperties.Density
        local existingProperties = shared.RootPart.CustomPhysicalProperties
        shared.RootPart.CustomPhysicalProperties = PhysicalProperties.new(100, existingProperties.Friction, existingProperties.Elasticity, existingProperties.FrictionWeight, existingProperties.ElasticityWeight)
    else
        local existingProperties = shared.RootPart.CustomPhysicalProperties
        shared.RootPart.CustomPhysicalProperties = PhysicalProperties.new(Script.Temp.NoAccelValue, existingProperties.Friction, existingProperties.Elasticity, existingProperties.FrictionWeight, existingProperties.ElasticityWeight)
    end
end)
Toggles.InstaInteract:OnChanged(function(value)
    for _, prompt in pairs(workspace.CurrentRooms:GetDescendants()) do
        if prompt:IsA("ProximityPrompt") then
            if value then
                if not prompt:GetAttribute("Hold") then prompt:SetAttribute("Hold", prompt.HoldDuration) end
                prompt.HoldDuration = 0
            else
                prompt.HoldDuration = prompt:GetAttribute("Hold") or 0
            end
        end
    end
end)
Toggles.Fly:OnChanged(function(value)
    if not shared.Fly.FlyBody then shared.Fly:Setup() end
    shared.Fly:Set(value)
end)
Options.FlySpeed:OnChanged(function(value)
    shared.Fly:SetSpeed(value)
end)
--// Reach \\--
Toggles.PromptClip:OnChanged(function(value)
    for _, prompt in pairs(workspace.CurrentRooms:GetDescendants()) do        
        if Script.Functions.PromptCondition(prompt) then
            if value then
                prompt.RequiresLineOfSight = false
            else
                prompt.RequiresLineOfSight = prompt:GetAttribute("Clip") or true
            end
        end
    end
end)
Options.PromptReachMultiplier:OnChanged(function(value)
    for _, prompt in pairs(workspace.CurrentRooms:GetDescendants()) do
        if Script.Functions.PromptCondition(prompt) then
            if not prompt:GetAttribute("Distance") then prompt:SetAttribute("Distance", prompt.MaxActivationDistance) end
            prompt.MaxActivationDistance = prompt:GetAttribute("Distance") * value
        end
    end
end)
end)() end,
    [17] = function()local wax,script,require=ImportGlobals(17)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
local Tabs = Script.Tabs
local CaptionStyles = {"Linoria"}
if wax.shared.ExecutorSupport["firesignal"] then
    table.insert(CaptionStyles, "Doors")
end
--// Visuals \\--
local ESPTabBox = Tabs.Visuals:AddLeftTabbox() do
    local ESPTab = ESPTabBox:AddTab("Định vị") do
        ESPTab:AddToggle("DoorESP", {
            Text = "Cửa",
            Default = false,
        }):AddColorPicker("DoorEspColor", {
            Default = Color3.new(0, 1, 1),
        })
        ESPTab:AddToggle("ObjectiveESP", {
            Text = "Đồ vật",
            Default = false,
        }):AddColorPicker("ObjectiveEspColor", {
            Default = Color3.new(0, 1, 0),
        })
        ESPTab:AddToggle("EntityESP", {
            Text = "Quái",
            Default = false,
        }):AddColorPicker("EntityEspColor", {
            Default = Color3.new(1, 0, 0),
        })
        ESPTab:AddToggle("ItemESP", {
            Text = "Vật phẩm",
            Default = false,
        }):AddColorPicker("ItemEspColor", {
            Default = Color3.new(1, 0, 1),
        })
        ESPTab:AddToggle("ChestESP", {
            Text = "Rương",
            Default = false,
        }):AddColorPicker("ChestEspColor", {
            Default = Color3.new(1, 1, 0),
        })
        ESPTab:AddToggle("PlayerESP", {
            Text = "Người chơi",
            Default = false,
        }):AddColorPicker("PlayerEspColor", {
            Default = Color3.new(1, 1, 1),
        })
        ESPTab:AddToggle("HidingSpotESP", {
            Text = Script.HidingPlaceName[Script.Floor.Value],
            Default = false,
        }):AddColorPicker("HidingSpotEspColor", {
            Default = Color3.new(0, 0.5, 0),
        })
        ESPTab:AddToggle("GoldESP", {
            Text = "Vàng",
            Default = false,
        }):AddColorPicker("GoldEspColor", {
            Default = Color3.new(1, 1, 0),
        })
        ESPTab:AddToggle("GuidingLightESP", {
            Text = "Điểm sáng",
            Default = false,
        }):AddColorPicker("GuidingLightEspColor", {
            Default = Color3.new(0, 0.5, 1),
        })
    end
    local ESPSettingsTab = ESPTabBox:AddTab("Cài đặt") do
        ESPSettingsTab:AddToggle("ESPRainbow", {
            Text = "Định vị màu cầu vồng",
            Default = false,
        })
        ESPSettingsTab:AddDivider()
        ESPSettingsTab:AddToggle("ESPHighlight", {
            Text = "Thêm điểm kẻ sáng",
            Default = true
        })
        ESPSettingsTab:AddSlider("ESPFillTransparency", {
            Text = "Độ mờ vật thể",
            Default = 0.75,
            Min = 0,
            Max = 1,
            Rounding = 2
        })
        ESPSettingsTab:AddSlider("ESPOutlineTransparency", {
            Text = "Độ mờ đường kẻ",
            Default = 0,
            Min = 0,
            Max = 1,
            Rounding = 2
        })
        ESPSettingsTab:AddDivider()
        ESPSettingsTab:AddToggle("ESPDistance", {
            Text = "Hiển thị khoảng cách",
            Default = true
        })
        ESPSettingsTab:AddSlider("ESPTextSize", {
            Text = "Kích cỡ chữ",
            Default = 18,
            Min = 16,
            Max = 26,
            Rounding = 0
        })
        ESPSettingsTab:AddDivider()
        ESPSettingsTab:AddToggle("ESPTracer", {
            Text = "Hiển thị đường kẻ",
            Default = false
        })
        ESPSettingsTab:AddDropdown("ESPTracerStart", {
            AllowNull = false,
            Values = {"Bottom", "Center", "Top", "Mouse"},
            Default = "Bottom",
            Multi = false,
            Text = "Vị trí đường kẻ"
        })
        ESPSettingsTab:AddDivider()
        ESPSettingsTab:AddToggle("ESPArrow", {
            Text = "Hiển thị mũi tên",
            Default = false
        })
        ESPSettingsTab:AddSlider("ESPArrowCenterOffset", {
            Text = "Độ rộng mũi tên",
            Default = 300,
            Min = 0,
            Max = 500,
            Rounding = 0
        })
    end
end
local AmbientGroupBox = Tabs.Visuals:AddLeftGroupbox("Thị giác") do
    AmbientGroupBox:AddSlider("Brightness", {
        Text = "Độ sáng",
        Default = 0,
        Min = 0,
        Max = 3,
        Rounding = 1,
    })
    AmbientGroupBox:AddToggle("Fullbright", {
        Text = "Map sáng",
        Default = false,
    })
    AmbientGroupBox:AddToggle("NoFog", {
        Text = "Xóa sương mù",
        Default = false,
    })
    AmbientGroupBox:AddToggle("AntiLag", {
        Text = "Giảm lag",
        Default = false,
    })
end
local NotifyTabBox = Tabs.Visuals:AddRightTabbox() do
    local NotifyTab = NotifyTabBox:AddTab("Thông báo") do
        NotifyTab:AddDropdown("NotifyEntity", {
            AllowNull = true,
            Values = {"Blitz", "Lookman", "Rush", "Ambush", "Eyes", "Halt Room", "A60", "A120", "Jeff The Killer", "Gloombat Swarm", "Void/Glitch"},
            Default = {"Rush","Ambush","Eyes"},
            Multi = true,
            Text = "Cảnh báo quái"
        })
        NotifyTab:AddToggle("NotifyPadlock", {
            Text = "Thông báo mã thư viện",
            Default = false,
        })
        NotifyTab:AddToggle("NotifyOxygen", {
            Text = "Hiển thị oxygen còn lại",
            Default = false,
        })
        NotifyTab:AddToggle("NotifyHideTime", {
            Text = "Hiển thị thời gian ẩn",
            Default = false,
        })
    end
    local NotifySettingsTab = NotifyTabBox:AddTab("Cài đặt") do
        NotifySettingsTab:AddToggle("NotifyChat", {
            Text = "Cảnh báo trong chat",
            Tooltip = "Quái hoặc mã khóa",
            Default = false,
        })
        NotifySettingsTab:AddInput("NotifyEntityMessage", {
            Default = "đã xuất hiện!",
            Numeric = false,
            Finished = true,
            ClearTextOnFocus = false,
            Text = "Tin nhắn cảnh báo"
        })
        NotifySettingsTab:AddDivider()
        NotifySettingsTab:AddToggle("NotifySound", {
            Text = "Chạy âm thanh cảnh báo",
            Default = true,
        })
        NotifySettingsTab:AddSlider("NotifyVolume", {
            Text = "Âm lượng",
            Default = 2,
            Min = 0,
            Max = 5,
            Rounding = 1
        })
        NotifySettingsTab:AddDropdown("NotifySide", {
            AllowNull = false,
            Values = {"Left", "Right"},
            Default = "Right",
            Multi = false,
            Text = "Vị trí cảnh báo"
        })
        NotifySettingsTab:AddDropdown("NotifyStyle", {
            AllowNull = false,
            Values = {"Linoria", "Doors"},
            Default = "Doors",
            Multi = false,
            Text = "Phong cách cảnh báo"
        })
        NotifySettingsTab:AddDivider()
        NotifySettingsTab:AddDropdown("CaptionStyle", {
            AllowNull = false,
            Values = CaptionStyles,
            Default = "Doors",
            Multi = false,
            Text = "Phong cách tiêu đề"
        })
    end
end
local SelfTabBox = Tabs.Visuals:AddRightTabbox() do
    local SelfTab = SelfTabBox:AddTab("Bản thân") do
        SelfTab:AddToggle("ThirdPerson", {
            Text = "Góc nhìn thứ 3",
            Default = false
        }):AddKeyPicker("ThirdPersonKey", {
            Default = "V",
            Text = "Góc nhìn thứ 3",
            Mode = "Toggle",
            SyncToggleState = not shared.Library.IsMobile -- ????
        })
        SelfTab:AddSlider("FOV", {
            Text = "Độ cong tầm nhìn",
            Default = 70,
            Min = 70,
            Max = 120,
            Rounding = 0
        })
        SelfTab:AddToggle("NoCamBob", {
            Text = "Không lắc lư màn",
            Default = false,
            Visible = wax.shared.ExecutorSupport["require"]
        })
        SelfTab:AddToggle("NoCamShake", {
            Text = "Không rung màn",
            Default = false,
            Visible = wax.shared.ExecutorSupport["require"]
        })
        SelfTab:AddToggle("NoCutscenes", {
            Text = "Không đoạn cắt cảnh",
            Default = false,
        })
        SelfTab:AddToggle("TranslucentHidingSpot", {
            Text = "Làm nơi ẩn nấp",
            Default = false
        })
        SelfTab:AddSlider("HidingTransparency", {
            Text = "Độ mờ",
            Default = 0.5,
            Min = 0,
            Max = 1,
            Rounding = 1,
            Compact = true,
        })
        if wax.shared.ExecutorSupport["require"] then
            SelfTab:AddDivider()
        end
        SelfTab:AddToggle("ViewmodelOffset", {
            Text = "Tầm nhìn theo góc độ(giỏi toán)",
            Default = false,
            Visible = wax.shared.ExecutorSupport["require"]
        })
        SelfTab:AddSlider("ToolOffsetX", {
            Text = "X",
            Default = 0,
            Min = -5,
            Max = 5,
            Rounding = 1,
            Compact = true,
            Visible = wax.shared.ExecutorSupport["require"]
        })
        SelfTab:AddSlider("ToolOffsetY", {
            Text = "Y",
            Default = 0,
            Min = -5,
            Max = 5,
            Rounding = 1,
            Compact = true,
            Visible = wax.shared.ExecutorSupport["require"]
        })
        SelfTab:AddSlider("ToolOffsetZ", {
            Text = "Z",
            Default = 0,
            Min = -5,
            Max = 5,
            Rounding = 1,
            Compact = true,
            Visible = wax.shared.ExecutorSupport["require"]
        })
    end
    local EffectsTab = SelfTabBox:AddTab("Xóa hiệu ứng") do
        EffectsTab:AddToggle("NoGlitchEffect", {
            Text = "Không hiệu úng glicth",
            Default = false
        })
        EffectsTab:AddToggle("NoVoidEffect", {
            Text = "Không hiệu ứng lồng tiếng",
            Default = false
        })
        EffectsTab:AddToggle("NoEntityJumpscare", {
            Text = "Không dọa",
            Default = false
        })
        EffectsTab:AddToggle("NoSpiderJumpscare", {
            Text = "Không bị nhện dọa",
            Default = false
        })
    end
end
--// ESP \\--
Toggles.DoorESP:OnChanged(function(value)
    if value then
        if workspace.CurrentRooms[Script.CurrentRoom]:FindFirstChild("Door") then
            Script.Functions.DoorESP(workspace.CurrentRooms[Script.CurrentRoom])
        end
        if workspace.CurrentRooms[Script.NextRoom]:FindFirstChild("Door") then
            Script.Functions.DoorESP(workspace.CurrentRooms[Script.NextRoom])
        end
    else
        for _, connection in pairs(Script.FeatureConnections.Door) do
            connection:Disconnect()
        end
        for _, esp in pairs(Script.ESPTable.Door) do
            esp.Destroy()
        end
    end
end)
Options.DoorEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Door) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Toggles.ObjectiveESP:OnChanged(function(value)
    if value then
        local currentRoomModel = workspace.CurrentRooms:FindFirstChild(Script.CurrentRoom)
        if currentRoomModel then
            for _, asset in pairs(currentRoomModel:GetDescendants()) do
                task.spawn(Script.Functions.ObjectiveESP, asset)
            end
        end
    else
        for _, esp in pairs(Script.ESPTable.Objective) do
            esp.Destroy()
        end
    end
end)
Options.ObjectiveEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Objective) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Toggles.EntityESP:OnChanged(function(value)
    if value then
        for _, entity in pairs(workspace:GetChildren()) do
            if table.find(Script.EntityTable.Names, entity.Name) then
                Script.Functions.EntityESP(entity)
            end
        end
        local currentRoomModel = workspace.CurrentRooms:FindFirstChild(Script.CurrentRoom)
        if currentRoomModel then
            for _, entity in pairs(currentRoomModel:GetDescendants()) do
                if table.find(Script.EntityTable.SideNames, entity.Name) then
                    Script.Functions.SideEntityESP(entity)
                end
            end
        end
    else
        for _, esp in pairs(Script.ESPTable.Entity) do
            esp.Destroy()
        end
        for _, esp in pairs(Script.ESPTable.SideEntity) do
            esp.Destroy()
        end
    end
end)
Options.EntityEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Entity) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Toggles.ItemESP:OnChanged(function(value)
    if value then
        for _, item in pairs(workspace.Drops:GetChildren()) do
            if Script.Functions.ItemCondition(item) then
                Script.Functions.ItemESP(item, true)
            end
        end
        local currentRoomModel = workspace.CurrentRooms:FindFirstChild(Script.CurrentRoom)
        if currentRoomModel then
            for _, item in pairs(currentRoomModel:GetDescendants()) do
                if Script.Functions.ItemCondition(item) then
                    Script.Functions.ItemESP(item)
                end
            end
        end
    else
        for _, esp in pairs(Script.ESPTable.DroppedItem) do
            esp.Destroy()
        end
        for _, esp in pairs(Script.ESPTable.Item) do
            esp.Destroy()
        end
    end
end)
Options.ItemEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.DroppedItem) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
    for _, esp in pairs(Script.ESPTable.Item) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Toggles.ChestESP:OnChanged(function(value)
    if value then
        local currentRoomModel = workspace.CurrentRooms:FindFirstChild(Script.CurrentRoom)
        if currentRoomModel then
            for _, chest in pairs(currentRoomModel:GetDescendants()) do
                if chest:GetAttribute("Storage") == "ChestBox" or chest.Name == "Toolshed_Small" then
                    Script.Functions.ChestESP(chest)
                end
            end
        end
    else
        for _, esp in pairs(Script.ESPTable.Chest) do
            esp.Destroy()
        end
    end
end)
Options.ChestEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Chest) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Toggles.PlayerESP:OnChanged(function(value)
    if value then
        for _, player in pairs(shared.Players:GetPlayers()) do
            if player == shared.LocalPlayer or not player.Character then continue end
            Script.Functions.PlayerESP(player.Character)
        end
    else
        for _, connection in pairs(Script.FeatureConnections.Player) do
            connection:Disconnect()
        end
        for _, esp in pairs(Script.ESPTable.Player) do
            esp.Destroy()
        end
    end
end)
Options.PlayerEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Player) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Toggles.HidingSpotESP:OnChanged(function(value)
    if value then
        local currentRoomModel = workspace.CurrentRooms:FindFirstChild(Script.CurrentRoom)
        if currentRoomModel then
            for _, wardrobe in pairs(currentRoomModel:GetDescendants()) do
                if wardrobe:GetAttribute("LoadModule") == "Wardrobe" or wardrobe:GetAttribute("LoadModule") == "Bed" or wardrobe.Name == "Rooms_Locker" or wardrobe.Name == "RetroWardrobe" then
                    Script.Functions.HidingSpotESP(wardrobe)
                end
            end
        end 
    else
        for _, esp in pairs(Script.ESPTable.HidingSpot) do
            esp.Destroy()
        end
    end
end)
Options.HidingSpotEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.HidingSpot) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Toggles.GoldESP:OnChanged(function(value)
    if value then
        local currentRoomModel = workspace.CurrentRooms:FindFirstChild(Script.CurrentRoom)
        if currentRoomModel then
            for _, gold in pairs(currentRoomModel:GetDescendants()) do
                if gold.Name == "GoldPile" then
                    Script.Functions.GoldESP(gold)
                end
            end
        end
    else
        for _, esp in pairs(Script.ESPTable.Gold) do
            esp.Destroy()
        end
    end
end)
Options.GoldEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Gold) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Toggles.GuidingLightESP:OnChanged(function(value)
    if value then
        for _, guidance in pairs(shared.Camera:GetChildren()) do
            if guidance:IsA("BasePart") and guidance.Name == "Guidance" then
                Script.Functions.GuidingLightEsp(guidance)
            end
        end
    else
        for _, esp in pairs(Script.ESPTable.Guiding) do
            esp.Destroy()
        end
    end
end)
Options.GuidingLightEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Guiding) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
--// ESP Settings \\--
Toggles.ESPRainbow:OnChanged(function(value)
    shared.ESPLibrary.Rainbow.Set(value)
end)
Toggles.ESPHighlight:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.SetVisible(value, false)
        end
    end
end)
Options.ESPFillTransparency:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Update({ FillTransparency = value })
        end
    end
end)
Options.ESPOutlineTransparency:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Update({ OutlineTransparency = value })
        end
    end
end)
Toggles.ESPDistance:OnChanged(function(value)
    shared.ESPLibrary.Distance.Set(value)
end)
Options.ESPTextSize:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Update({ TextSize = value })
        end
    end
end)
Toggles.ESPTracer:OnChanged(function(value)
    shared.ESPLibrary.Tracers.Set(value)
end)
Options.ESPTracerStart:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Update({ Tracer = { From = value } })
        end
    end
end)
Toggles.ESPArrow:OnChanged(function(value)
    shared.ESPLibrary.Arrows.Set(value)
end)
Options.ESPArrowCenterOffset:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Update({ Arrow = { CenterOffset = value } })
        end
    end
end)
--// Ambient \\--
Options.Brightness:OnChanged(function(value)
    shared.Lighting.Brightness = value
end)
Toggles.Fullbright:OnChanged(function(value)
    if value then
        shared.Lighting.Ambient = Color3.new(1, 1, 1)
    else
        if Script.Alive then
            shared.Lighting.Ambient = workspace.CurrentRooms[shared.LocalPlayer:GetAttribute("CurrentRoom")]:GetAttribute("Ambient")
        else
            shared.Lighting.Ambient = Color3.new(0, 0, 0)
        end
    end
end)
Toggles.NoFog:OnChanged(function(value)
    if not shared.Lighting:GetAttribute("FogStart") then shared.Lighting:SetAttribute("FogStart", shared.Lighting.FogStart) end
    if not shared.Lighting:GetAttribute("FogEnd") then shared.Lighting:SetAttribute("FogEnd", shared.Lighting.FogEnd) end
    shared.Lighting.FogStart = value and 0 or shared.Lighting:GetAttribute("FogStart")
    shared.Lighting.FogEnd = value and math.huge or shared.Lighting:GetAttribute("FogEnd")
    local fog = shared.Lighting:FindFirstChildOfClass("Atmosphere")
    if fog then
        if not fog:GetAttribute("Density") then fog:SetAttribute("Density", fog.Density) end
        fog.Density = value and 0 or fog:GetAttribute("Density")
    end
end)
shared.Connect:GiveSignal(shared.Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
    shared.Lighting.Brightness = Options.Brightness.Value
end))
shared.Connect:GiveSignal(shared.Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
    if Toggles.Fullbright.Value then
        shared.Lighting.Ambient = Color3.new(1, 1, 1)
    end
end))
shared.Connect:GiveSignal(shared.Lighting:GetPropertyChangedSignal("FogStart"):Connect(function()
    if Toggles.NoFog.Value then
        shared.Lighting.FogStart = 0
    end
end))
shared.Connect:GiveSignal(shared.Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
    if Toggles.NoFog.Value then
        shared.Lighting.FogEnd = math.huge
    end
end))
Toggles.AntiLag:OnChanged(function(value)
    for _, object in pairs(workspace.CurrentRooms:GetDescendants()) do
        if object:IsA("BasePart") then
            if not object:GetAttribute("Material") then object:SetAttribute("Material", object.Material) end
            if not object:GetAttribute("Reflectance") then object:SetAttribute("Reflectance", object.Reflectance) end
            object.Material = value and Enum.Material.Plastic or object:GetAttribute("Material")
            object.Reflectance = value and 0 or object:GetAttribute("Reflectance")
        elseif object:IsA("Decal") then
            if not object:GetAttribute("Transparency") then object:SetAttribute("Transparency", object.Transparency) end
            if not table.find(Script.SlotsName, object.Name) then
                object.Transparency = value and 1 or object:GetAttribute("Transparency")
            end
        end
    end
    workspace.Terrain.WaterReflectance = if value then 0 else 1
    workspace.Terrain.WaterTransparency = if value then 0 else 1
    workspace.Terrain.WaterWaveSize = if value then 0 else 0.05
    workspace.Terrain.WaterWaveSpeed = if value then 0 else 8
    shared.Lighting.GlobalShadows = not value
end)
--// Notifier \\--
if Script.IsBackdoor then
    local clientRemote = Script.FloorReplicated.ClientRemote
    local haste_incoming_progress = nil
    shared.Connect:GiveSignal(clientRemote.Haste.Remote.OnClientEvent:Connect(function(value)
        if not value and Toggles.NotifyEntity.Value then
            haste_incoming_progress = Instance.new("Part", shared.Workspace); do
                haste_incoming_progress.Anchored = true
                haste_incoming_progress.CanCollide = false
                haste_incoming_progress.Name = "_internal_mspaint_haste"
                haste_incoming_progress.Transparency = 1
            end
            shared.Notify:Alert({
                Title = "ENTITIES",
                Description = "Haste đang đến tìm cần gạt khẩn cấp m!",
                Time = haste_incoming_progress,
                Warning = true
            })
            repeat task.wait() until not haste_incoming_progress or not Toggles.NotifyEntity.Value or not shared.Character:GetAttribute("Alive")
            if haste_incoming_progress then haste_incoming_progress:Destroy() end
        end
        if value and haste_incoming_progress then
            haste_incoming_progress:Destroy()
        end
    end))
end
shared.Connect:GiveSignal(Script.RemotesFolder.HideMonster.OnClientEvent:Connect(function()
    if Script.IsBackdoor or Script.IsRooms or Script.IsRetro then return end
    local hideTime = Script.Functions.CalculateHideTime(Script.CurrentRoom) or math.huge
    local finalTime = tick() + math.round(hideTime)
    if Toggles.NotifyHideTime.Value and hideTime ~= math.huge then
        while shared.Character:GetAttribute("Hiding") and Script.Alive and not shared.Library.Unloaded and Toggles.NotifyHideTime.Value do
            local remainingTime = math.max(0, finalTime - tick())
            if wax.shared.ExecutorSupport["firesignal"] then
                if Options.NotifyStyle.Value == "Doors" then
                    firesignal(Script.RemotesFolder.Caption.OnClientEvent, string.format("%.1f", remainingTime))
                elseif Options.NotifyStyle.Value == "Linoria" then
                    Script.Functions.Captions(string.format("%.1f", remainingTime))
                end
            else
                Script.Functions.Captions(string.format("%.1f", remainingTime))
            end
            task.wait()
        end
    end
end))
Options.NotifyVolume:OnChanged(function(value)
    shared.NotifyVolume = value
end)
Options.NotifySide:OnChanged(function(value)
    shared.Library.NotifySide = value
end)
Options.NotifyStyle:OnChanged(function(value)
    shared.NotifyStyle = value
end)
Toggles.NoCutscenes:OnChanged(function(value)
    if Script.MainGame then
        local cutscenes = Script.MainGame:FindFirstChild("Cutscenes", true)
        if cutscenes then
            for _, cutscene in pairs(cutscenes:GetChildren()) do
                if table.find(Script.CutsceneExclude, cutscene.Name) then continue end
                local defaultName = cutscene.Name:gsub("_", "")
                cutscene.Name = value and "_" .. defaultName or defaultName
            end
        end
    end
    if Script.FloorReplicated then
        for _, cutscene in pairs(Script.FloorReplicated:GetChildren()) do
            if not cutscene:IsA("ModuleScript") or table.find(Script.CutsceneExclude, cutscene.Name) then continue end
            local defaultName = cutscene.Name:gsub("_", "")
            cutscene.Name = value and "_" .. defaultName or defaultName
        end
    end
end)
Toggles.TranslucentHidingSpot:OnChanged(function(value)
    if value and shared.Character:GetAttribute("Hiding") then
        for _, obj in pairs(workspace.CurrentRooms:GetDescendants()) do
            if not obj:IsA("ObjectValue") and obj.Name ~= "HiddenPlayer" then continue end
            if obj.Value == shared.Character then
                task.spawn(function()
                    local affectedParts = {}
                    for _, v in pairs(obj.Parent:GetChildren()) do
                        if not v:IsA("BasePart") then continue end
                        v.Transparency = Options.HidingTransparency.Value
                        table.insert(affectedParts, v)
                    end
                    repeat task.wait()
                        for _, part in pairs(affectedParts) do
                            task.wait()
                            part.Transparency = Options.HidingTransparency.Value
                        end
                    until not shared.Character:GetAttribute("Hiding") or not Toggles.TranslucentHidingSpot.Value
                    for _, v in pairs(affectedParts) do
                        v.Transparency = 0
                    end
                end)
                break
            end
        end
    end
end)
--// Self \\--
Toggles.NoGlitchEffect:OnChanged(function(value)
    if not Script.EntityModules then return end
    local module = Script.EntityModules:FindFirstChild("Glitch") or Script.EntityModules:FindFirstChild("_Glitch")
    if module then
        module.Name = if value then "_Glitch" else "Glitch"
    end
end)
Toggles.NoVoidEffect:OnChanged(function(value)
    if not Script.EntityModules then return end
    local module = Script.EntityModules:FindFirstChild("Void") or Script.EntityModules:FindFirstChild("_Void")
    if module then
        module.Name = if value then "_Void" else "Void"
    end
end)
Toggles.NoSpiderJumpscare:OnChanged(function(value)
    if not Script.MainGame then return end
    local module = Script.MainGame:FindFirstChild("SpiderJumpscare", true) or Script.MainGame:FindFirstChild("_SpiderJumpscare", true)
    if module then
        module.Name = if value then "_SpiderJumpscare" else "SpiderJumpscare"
    end
end)
Toggles.NoEntityJumpscare:OnChanged(function(value)
    if not Script.MainGame then return end
    local jumpscaresFolder = Script.MainGame:FindFirstChild("Jumpscares", true) or Script.MainGame:FindFirstChild("_Jumpscares", true)
    if jumpscaresFolder then
        jumpscaresFolder.Name = if value then "_Jumpscares" else "Jumpscares"
    end
end)
Toggles.ViewmodelOffset:OnChanged(function(value)
    if not value and shared.Character and shared.Character:FindFirstChildOfClass("Tool") and Script.MainGameSrc then
        local tool = shared.Character:FindFirstChildOfClass("Tool")
        if not tool:GetAttribute("ToolOffset") then return end
        Script.MainGameSrc.tooloffset = tool:GetAttribute("ToolOffset")
    end
end)
end)() end,
    [19] = function()local wax,script,require=ImportGlobals(19)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
local Tabs = Script.Tabs
---// Main \\--
local SniperGroupbox = Tabs.Main:AddLeftGroupbox("Sniper") do
    SniperGroupbox:AddToggle("ElevatorSniper", {
        Text = "Vô thang máy đã chọn",
        Default = false
    })
    SniperGroupbox:AddDropdown("ElevatorSniperTarget", {
        SpecialType = "Player",
        Multi = false,
        Text = "Người chơi"
    })
end
local OtherGroupbox = Tabs.Main:AddRightGroupbox("Other") do
    OtherGroupbox:AddToggle("Twerk", {
        Text = "Nhảy",
        Default = false
    })
    OtherGroupbox:AddToggle("LoopAchievements", {
        Text = "Hiệu ứng đổi danh hiệu",
        Default = false
    })
    OtherGroupbox:AddSlider("LoopAchievementsSpeed", {
        Text = "Tốc độ đổi",
        Default = 0.05,
        Min = 0.05,
        Max = 1,
        Rounding = 2,
        Compact = true
    })
    OtherGroupbox:AddDivider()
    OtherGroupbox:AddButton("Create Retro Elevator", function()
        local data = {
            ["FriendsOnly"] = Script.CreateElevatorFrame.Settings.FriendsOnly:GetAttribute("Setting"),
            ["Destination"] = "Hotel",
            ["Mods"] = {
                "RetroMode"
            },
            ["MaxPlayers"] = Script.CreateElevatorFrame.Settings.MaxPlayers.Toggle.Text
        }
        Script.CreateElevator:FireServer(data)
    end)
end
if wax.shared.ExecutorSupport["_SupportsFileSystem"] then
    local PresetGroupbox = Tabs.Main:AddLeftGroupbox("Presets") do
        PresetGroupbox:AddInput('Elevator_PresetName', { Text = 'Preset name' })
        PresetGroupbox:AddButton({
            Text = "Create Preset",
            Func = function()
                if Script.PresetHelper.IsFile(Options.Elevator_PresetName.Value .. ".json") then
                    shared.Notify:Alert({
                        Description = "Preset already exists!"
                    })
                    return
                end
                local presetData = {
                    Floor = "Hotel",
                    MaxPlayers = 1,
                    Modifiers = {},
                    FriendsOnly = true
                }
                for _, floor in pairs(Script.CreateElevatorFrame.Floors:GetChildren()) do
                    if floor:IsA("TextLabel") and floor.Visible then
                        presetData.Floor = floor.Name
                        break
                    end
                end
                for _, modifier in pairs(Script.CreateElevatorFrame.Modifiers:GetChildren()) do
                    if modifier:GetAttribute("Enabled") then
                        table.insert(presetData.Modifiers, modifier.Name)    
                    end
                end
                presetData.MaxPlayers = tonumber(Script.CreateElevatorFrame.Settings.MaxPlayers.Toggle.Text)
                presetData.FriendsOnly = Script.CreateElevatorFrame.Settings.FriendsOnly:GetAttribute("Setting")
                Script.Functions.CreatePreset(Options.Elevator_PresetName.Value, presetData)
                shared.Notify:Alert({
                    Description = 'Created elevator preset "' .. Options.Elevator_PresetName.Value .. '" with ' .. #presetData.Modifiers .. " modifiers"
                })
                Script.Functions.LoadPresets()
                Options.Elevator_PresetList:SetValues(Script.ElevatorPresets)
                Options.Elevator_PresetList:SetValue(nil)
            end
        })
        PresetGroupbox:AddDivider()
        PresetGroupbox:AddDropdown('Elevator_PresetList', { Text = 'Preset list', Values = Script.ElevatorPresets, AllowNull = true })
        PresetGroupbox:AddButton('Load Preset', function()
            Script.Functions.LoadPreset(Options.Elevator_PresetList.Value)
        end)
        PresetGroupbox:AddButton('Override Preset', function()
            local presetData = {
                Floor = "Hotel",
                MaxPlayers = 1,
                Modifiers = {},
                FriendsOnly = true
            }
            for _, floor in pairs(Script.CreateElevatorFrame.Floors:GetChildren()) do
                if floor:IsA("TextLabel") and floor.Visible then
                    presetData.Floor = floor.Name
                    break
                end
            end
            for _, modifier in pairs(Script.CreateElevatorFrame.Modifiers:GetChildren()) do
                if modifier:GetAttribute("Enabled") then
                    table.insert(presetData.Modifiers, modifier.Name)    
                end
            end
            presetData.MaxPlayers = tonumber(Script.CreateElevatorFrame.Settings.MaxPlayers.Toggle.Text)
            presetData.FriendsOnly = Script.CreateElevatorFrame.Settings.FriendsOnly:GetAttribute("Setting")
            shared.Notify:Alert({
                Description = "Overrided preset: " .. Options.Elevator_PresetList.Value
            })
            Script.Functions.CreatePreset(Options.Elevator_PresetList.Value, presetData)
            Script.Functions.LoadPresets()
            Options.Elevator_PresetList:SetValues(Script.ElevatorPresets)
            Options.Elevator_PresetList:SetValue(nil)
        end)
        PresetGroupbox:AddButton('Delete Preset', function()
            if not Script.PresetHelper.IsFile(Options.Elevator_PresetList.Value .. ".json") then
                shared.Notify:Alert({
                    Description = "Preset does not exist!"
                })
                return
            end
            local success, err = pcall(function()
                Script.PresetHelper.DeleteFile(Options.Elevator_PresetList.Value .. ".json")
            end)
            if not success then
                shared.Notify:Alert({
                    Description = "Failed to delete preset: " .. Options.Elevator_PresetList.Value
                })
                return
            end
            shared.Notify:Alert({
                Description = "Deleted preset: " .. Options.Elevator_PresetList.Value
            })
            Script.Functions.LoadPresets()
            Options.Elevator_PresetList:SetValues(Script.ElevatorPresets)
            Options.Elevator_PresetList:SetValue(nil)
        end)
        PresetGroupbox:AddButton('Refresh Presets', function()
            Script.Functions.LoadPresets()
            Options.Elevator_PresetList:SetValues(Script.ElevatorPresets)
            Options.Elevator_PresetList:SetValue(nil)
        end)
    end
end
--// Sniper \\--
shared.Connect:GiveSignal(shared.RunService.RenderStepped:Connect(function()
    if Toggles.ElevatorSniper.Value and Options.ElevatorSniperTarget.Value then
        local targetCharacter = workspace:FindFirstChild(Options.ElevatorSniperTarget.Value)
        if not targetCharacter then return end
        local targetElevatorID = targetCharacter:GetAttribute("InGameElevator")
        local currentElevatorID = shared.Character:GetAttribute("InGameElevator")
        if currentElevatorID == targetElevatorID then return end
        if targetElevatorID ~= nil then    
            local targetElevator = Script.LobbyElevators:FindFirstChild("LobbyElevator-" .. targetElevatorID) 
            if not targetElevator then
                for _, elevator in pairs(Script.LobbyElevators:GetChildren()) do
                    if elevator.Name:match(Options.ElevatorSniperTarget.Value) then
                        targetElevator = elevator
                    end
                end
            end
            if targetElevator then
                Script.RemotesFolder.ElevatorJoin:FireServer(targetElevator)
            end
        elseif currentElevatorID ~= nil then
            Script.RemotesFolder.ElevatorExit:FireServer()
        end
    end
end))
--// Other \\--
Toggles.LoopAchievements:OnChanged(function(value)
    if value then
        Script.Functions.LoopAchievements()
    end
end)
Toggles.Twerk:OnChanged(function(value)
    shared.Twerk:Set(value)
end)
end)() end,
    [21] = function()local wax,script,require=ImportGlobals(21)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
local Tabs = Script.Tabs
Script.LastSpeed = if shared.Humanoid then shared.Humanoid.WalkSpeed else 16
--// Main \\--
local PlayerGroupBox = Tabs.Main:AddLeftGroupbox("Player") do
    PlayerGroupBox:AddToggle("SpeedHack", {
        Text = "Speed Hack",
        Default = false
    })
    PlayerGroupBox:AddSlider("WalkSpeed", {
        Text = "Walk Speed",
        Default = 16,
        Min = 0,
        Max = 75,
        Rounding = 0,
        Compact = true
    })
    PlayerGroupBox:AddDivider()
    PlayerGroupBox:AddToggle("InfStamina", {
        Text = "Infinite Stamina",
        Default = false,
        Visible = wax.shared.ExecutorSupport["getrenv"]
    })
    PlayerGroupBox:AddToggle("InfFlashlight", {
        Text = "Infinite Flashlight",
        Default = false,
        Visible = wax.shared.ExecutorSupport["getrenv"]
    })
end
--// Player \\--
Toggles.SpeedHack:OnChanged(function(value)
    if not shared.Humanoid then return end
    if value then
        Script.LastSpeed = shared.Humanoid.WalkSpeed
    end
    shared.Humanoid.WalkSpeed = if value then Options.WalkSpeed.Value else Script.LastSpeed
end)
end)() end,
    [22] = function()local wax,script,require=ImportGlobals(22)local ImportGlobals return (function(...)
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
local Tabs = Script.Tabs
--// ESP \\--
Toggles.DoorESP:OnChanged(function(value)
    if value then
        for _, room in pairs(workspace.rooms:GetChildren()) do
            Script.Functions.DoorESP(room)
        end
        for _, room in pairs(workspace.next:GetChildren()) do
            Script.Functions.DoorESP(room)
        end
    else
        for _, connection in pairs(Script.FeatureConnections.Door) do
            connection:Disconnect()
        end
        for _, esp in pairs(Script.ESPTable.Door) do
            esp.Destroy()
        end
    end
end)
Options.DoorEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Door) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Options.EntityEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Entity) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Toggles.BatteryESP:OnChanged(function(value)
    if value then
        for _, battery in pairs(workspace.rooms:GetDescendants()) do
            if battery.Name ~= "battery" then continue end
            Script.Functions.BatteryESP(battery)
        end
        for _, battery in pairs(workspace.next:GetDescendants()) do
            if battery.Name ~= "battery" then continue end
            Script.Functions.BatteryESP(battery)
        end
    else
        for _, esp in pairs(Script.ESPTable.Battery) do
            esp.Destroy()
        end
    end
end)
Toggles.LockerESP:OnChanged(function(value)
    if value then
        for _, hideLocker in pairs(workspace.rooms:GetDescendants()) do
            if hideLocker.Name ~= "hidelocker" then continue end
            Script.Functions.LockerESP(hideLocker)
        end
        for _, hideLocker in pairs(workspace.next:GetDescendants()) do
            if hideLocker.Name ~= "hidelocker" then continue end
            Script.Functions.LockerESP(hideLocker)
        end
    else
        for _, esp in pairs(Script.ESPTable.Locker) do
            esp.Destroy()
        end
    end
end)
Options.LockerEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Locker) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
Toggles.TableESP:OnChanged(function(value)
    if value then
        for _, hideTable in pairs(workspace.rooms:GetDescendants()) do
            if hideTable.Name ~= "hidetable" then continue end
            Script.Functions.TableESP(hideTable)
        end
        for _, hideTable in pairs(workspace.next:GetDescendants()) do
            if hideTable.Name ~= "hidetable" then continue end
            Script.Functions.TableESP(hideTable)
        end
    else
        for _, esp in pairs(Script.ESPTable.Table) do
            esp.Destroy()
        end
    end
end)
Options.TableEspColor:OnChanged(function(value)
    for _, esp in pairs(Script.ESPTable.Table) do
        esp.Update({
            FillColor = value,
            OutlineColor = value,
            TextColor = value,
        })
    end
end)
--// ESP Settings \\--
Toggles.ESPRainbow:OnChanged(function(value)
    shared.ESPLibrary.Rainbow.Set(value)
end)
Toggles.ESPHighlight:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.SetVisible(value, false)
        end
    end
end)
Options.ESPFillTransparency:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Update({ FillTransparency = value })
        end
    end
end)
Options.ESPOutlineTransparency:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Update({ OutlineTransparency = value })
        end
    end
end)
Toggles.ESPDistance:OnChanged(function(value)
    shared.ESPLibrary.Distance.Set(value)
end)
Options.ESPTextSize:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Update({ TextSize = value })
        end
    end
end)
Toggles.ESPTracer:OnChanged(function(value)
    shared.ESPLibrary.Tracers.Set(value)
end)
Options.ESPTracerStart:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Update({ Tracer = { From = value } })
        end
    end
end)
Toggles.ESPArrow:OnChanged(function(value)
    shared.ESPLibrary.Arrows.Set(value)
end)
Options.ESPArrowCenterOffset:OnChanged(function(value)
    for _, espType in pairs(Script.ESPTable) do
        for _, esp in pairs(espType) do
            esp.Update({ Arrow = { CenterOffset = value } })
        end
    end
end)
--// Ambient \\--
Toggles.Fullbright:OnChanged(function(value)
    if value then
        shared.Lighting.Ambient = Color3.new(1, 1, 1)
    else
        shared.Lighting.Ambient = Script.CurrentAmbient
    end
end)
Toggles.NoFlashlightShadow:OnChanged(function(value)
    local slender = Script.MainUI and Script.MainUI:FindFirstChild("slender")
    if slender then
        slender.ImageTransparency = if value then 1 else 0
        for _, bar in pairs(slender:GetChildren()) do
            bar.Visible = not value
        end
    end
end)
Toggles.NoBlur:OnChanged(function(value)
    local blur = shared.Lighting:FindFirstChildOfClass("BlurEffect")
    if blur then
        blur.Enabled = not value
    end
end)
--// Notifier \\--
Options.NotifyVolume:OnChanged(function(value)
    shared.NotifyVolume = value
end)
Options.NotifySide:OnChanged(function(value)
    shared.Library.NotifySide = value
end)
end)() end,
    [26] = function()local wax,script,require=ImportGlobals(26)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
function Script.Functions.PromptCondition(prompt)
    local modelAncestor = prompt:FindFirstAncestorOfClass("Model")
    return 
        prompt:IsA("ProximityPrompt") and (
            not table.find(Script.PromptTable.Excluded.Prompt, prompt.Name) 
            and not table.find(Script.PromptTable.Excluded.Parent, prompt.Parent and prompt.Parent.Name or "") 
            and not (table.find(Script.PromptTable.Excluded.ModelAncestor, modelAncestor and modelAncestor.Name or ""))
        )
end
function Script.Functions.ItemCondition(item)
    return item:IsA("Model") and (item:GetAttribute("Pickup") or item:GetAttribute("PropType")) and not item:GetAttribute("FuseID")
end
function Script.Functions.VoiceCondition(sound: Sound)
    return sound:IsA("Sound") and table.find(Script.Voicelines, sound.SoundId)
end
function Script.Functions.ChildCheck(child)
    -- optimization (ty lsplash)
    if (child.Name == "AnimSaves" or child.Name == "Keyframe" or child:IsA("KeyframeSequence")) then
        child:Destroy()
        return
    end
    -- skip
    if not (child:IsA("ProximityPrompt") or child:IsA("Model") or child:IsA("BasePart") or child:IsA("Decal") or child:IsA("Sound")) then
        return
    end
    if Script.Functions.PromptCondition(child) then
        task.defer(function()
            if not child:GetAttribute("Hold") then child:SetAttribute("Hold", child.HoldDuration) end
            if not child:GetAttribute("Distance") then child:SetAttribute("Distance", child.MaxActivationDistance) end
            if not child:GetAttribute("Clip") then child:SetAttribute("Clip", child.RequiresLineOfSight) end
        end)
        task.defer(function()
            child.MaxActivationDistance = child:GetAttribute("Distance") * Options.PromptReachMultiplier.Value
            if Toggles.InstaInteract.Value then
                child.HoldDuration = 0
            end
            if Toggles.PromptClip.Value then
                child.RequiresLineOfSight = false
            end
        end)
        table.insert(Script.PromptTable.GamePrompts, child)
    elseif child:IsA("Model") then
        if child.Name == "ElevatorBreaker" and Toggles.AutoBreakerSolver.Value then
            Script.Functions.SolveBreakerBox(child)
        end
        if Script.IsMines and Toggles.TheMinesAnticheatBypass.Value and child.Name == "Ladder" then
            Script.Functions.ESP({
                Type = "None",
                Object = child,
                Text = "Ladder",
                Color = Color3.new(0, 0, 1)
            })
        end
        if (child.Name == "GiggleCeiling" and Toggles.AntiGiggle.Value) or (child.Name == "Snare" and Toggles.AntiSnare.Value) then
            local hitbox = child:WaitForChild("Hitbox", 5)
            if hitbox then hitbox.CanTouch = false end
        elseif (child:GetAttribute("LoadModule") == "DupeRoom" or child:GetAttribute("LoadModule") == "SpaceSideroom") and Toggles.AntiDupe.Value then
            Script.Functions.DisableDupe(child, true, child:GetAttribute("LoadModule") == "SpaceSideroom")
        end
        if (Script.IsHotel or Script.IsFools) and (child.Name == "ChandelierObstruction" or child.Name == "Seek_Arm") and Toggles.AntiSeekObstructions.Value then
            for i,v in pairs(child:GetDescendants()) do
                if v:IsA("BasePart") then v.CanTouch = false end
            end
        end
        if Script.IsFools then
            if Toggles.FigureGodmodeFools.Value and child.Name == "FigureRagdoll" then
                for i, v in pairs(child:GetDescendants()) do
                    if v:IsA("BasePart") then
                        if not v:GetAttribute("Clip") then v:SetAttribute("Clip", v.CanCollide) end
                        v.CanTouch = false
                        -- woudn't want figure to just dip into the ground
                        task.spawn(function()
                            repeat task.wait() until (Script.LatestRoom.Value == 50 or Script.LatestRoom.Value == 100)
                            task.wait(5)
                            v.CanCollide = false
                        end)
                    end
                end
            end
        end
    elseif child:IsA("BasePart") then
        if child.Parent then
            if tonumber(child.Name) and child.Name == child.Parent.Name then
                child.Size *= Vector3.new(1, 100, 1)
            elseif child.Name == "Egg" and Toggles.AntiGloomEgg.Value then
                child.CanTouch = false
            end
        else
            if child.Name == "Egg" and Toggles.AntiGloomEgg.Value then
                child.CanTouch = false
            end
        end
        if Toggles.AntiLag.Value then
            if not child:GetAttribute("Material") then child:SetAttribute("Material", child.Material) end
            if not child:GetAttribute("Reflectance") then child:SetAttribute("Reflectance", child.Reflectance) end
            child.Material = Enum.Material.Plastic
            child.Reflectance = 0
        end
        if Script.IsMines then
            if Toggles.AntiBridgeFall.Value and child.Name == "PlayerBarrier" and child.Size.Y == 2.75 and (child.Rotation.X == 0 or child.Rotation.X == 180) then
                local clone = child:Clone()
                clone.CFrame = clone.CFrame * CFrame.new(0, 0, -5)
                clone.Color = Color3.new(1, 1, 1)
                clone.Name = "AntiBridge"
                clone.Size = Vector3.new(clone.Size.X, clone.Size.Y, 11)
                clone.Transparency = 0
                clone.Parent = child.Parent
                table.insert(Script.Temp.Bridges, clone)
            elseif Toggles.AntiPipeGap.Value and child.Name == "KillBrick" and child.Parent.Name == "Assets" then
                local clone = child:Clone()
                clone.Color = Color3.new(1, 1, 1)
                clone.Name = "AntiPipeGap"
                clone.Position += Vector3.new(0, 20, 0)
                clone.Size = Vector3.new(9, 4, clone.Size.Z)
                clone.Transparency = 0
                clone.Parent = child.Parent
                table.insert(Script.Temp.PipeBridges, clone)
            elseif Toggles.AntiSeekFlood.Value and child.Name == "SeekFloodline" then
                child.CanCollide = true
            end
        end
    elseif child:IsA("Decal") and Toggles.AntiLag.Value then
        if not child:GetAttribute("Transparency") then child:SetAttribute("Transparency", child.Transparency) end
        if not table.find(Script.SlotsName, child.Name) then
            child.Transparency = 1
        end
    elseif Script.Functions.VoiceCondition(child) and shared.CheckToggle("NoVoiceActing", true) then
        child:Destroy()
    end
end
function Script.Functions.IsPromptInRange(prompt: ProximityPrompt)
    return Script.Functions.DistanceFromCharacter(prompt:FindFirstAncestorWhichIsA("BasePart") or prompt:FindFirstAncestorWhichIsA("Model") or prompt.Parent) <= prompt.MaxActivationDistance
end
function Script.Functions.GetNearestAssetWithCondition(condition: () -> ())
    local nearestDistance = math.huge
    local nearest
    for _, room in pairs(workspace.CurrentRooms:GetChildren()) do
        if not room:FindFirstChild("Assets") then continue end
        for _, asset in pairs(room.Assets:GetChildren()) do
            if condition(asset) and Script.Functions.DistanceFromCharacter(asset) < nearestDistance then
                nearestDistance = Script.Functions.DistanceFromCharacter(asset)
                nearest = asset
            end
        end
    end
    return nearest
end
function Script.Functions.GetAllPromptsWithCondition(condition)
    assert(typeof(condition) == "function", "Expected a function as condition argument but got " .. typeof(condition))
    local validPrompts = {}
    for _, prompt in pairs(Script.PromptTable.GamePrompts) do
        if not prompt or not prompt:IsDescendantOf(workspace) then continue end
        local success, returnData = pcall(function()
            return condition(prompt)
        end)
        assert(success, "An error has occured while running condition function.\n" .. tostring(returnData))
        assert(typeof(returnData) == "boolean", "Expected condition function to return a boolean")
        if returnData then
            table.insert(validPrompts, prompt)
        end
    end
    return validPrompts
end
function Script.Functions.GetNearestPromptWithCondition(condition)
    local prompts = Script.Functions.GetAllPromptsWithCondition(condition)
    local nearestPrompt = nil
    local oldHighestDistance = math.huge
    for _, prompt in pairs(prompts) do
        local promptParent = prompt:FindFirstAncestorWhichIsA("BasePart") or prompt:FindFirstAncestorWhichIsA("Model")
        if promptParent and Script.Functions.DistanceFromCharacter(promptParent) < oldHighestDistance then
            nearestPrompt = prompt
            oldHighestDistance = Script.Functions.DistanceFromCharacter(promptParent)
        end
    end
    return nearestPrompt
end
end)() end,
    [27] = function()local wax,script,require=ImportGlobals(27)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
function Script.Functions.GenerateAutoWardrobeExclusions(targetWardrobePrompt: ProximityPrompt)
    if not workspace.CurrentRooms:FindFirstChild(Script.CurrentRoom) then return {targetWardrobePrompt.Parent} end
    local ignore = { targetWardrobePrompt.Parent }
    if workspace.CurrentRooms[Script.CurrentRoom]:FindFirstChild("Assets") then
        for _, asset in pairs(workspace.CurrentRooms[Script.CurrentRoom].Assets:GetChildren()) do
            if asset.Name == "Pillar" then table.insert(ignore, asset) end
        end
    end
    return ignore
end
function Script.Functions.AutoWardrobe(child, index: number | nil)
    -- Entity check
    if not child then return end
    if not child:IsDescendantOf(workspace) then return end
    -- Toggles check
    if not Toggles.AutoWardrobeNotif or not Toggles.AutoWardrobe then return end
    if not Toggles.AutoWardrobe.Value or not Script.Alive then
        index = index or table.find(Script.Temp.AutoWardrobeEntities, child)
        if index then
            table.remove(Script.Temp.AutoWardrobeEntities, index)
        end
        return
    end
    local NotifPrefix = "Dương Api";
    task.spawn(function() 
        shared.Notify:Log({
            Title = NotifPrefix,
            Description = "Đứng trước tủ đi còn lại để anh lo:))",
            LinoriaMessage = "[" .. NotifPrefix .. "] Đứng trước tủ đi còn lại để anh lo:))"
        }, Toggles.AutoWardrobeNotif.Value)
    end)
    local entityIndex = #Script.Temp.AutoWardrobeEntities + 1
    Script.Temp.AutoWardrobeEntities[entityIndex] = child
    -- Get wardrobe
    local distance = Script.EntityTable.AutoWardrobe.Distance[child.Name].Distance;
    local targetWardrobeChecker = function(prompt)
        if not prompt.Parent then return false end
        if not prompt.Parent:FindFirstChild("HiddenPlayer") then return false end
        if prompt.Parent:FindFirstChild("Main") and prompt.Parent.Main:FindFirstChild("HideEntityOnSpot") then
            if prompt.Parent.Main.HideEntityOnSpot.Whispers.Playing == true then return false end -- Hide
        end
        return prompt.Name == "HidePrompt" and (prompt.Parent:GetAttribute("LoadModule") == "Wardrobe" or prompt.Parent:GetAttribute("LoadModule") == "Bed" or prompt.Parent.Name == "Rooms_Locker") and not prompt.Parent.HiddenPlayer.Value and (Script.Functions.DistanceFromCharacter(prompt.Parent) < prompt.MaxActivationDistance * Options.PromptReachMultiplier.Value)
    end
    local targetWardrobePrompt = Script.Functions.GetNearestPromptWithCondition(targetWardrobeChecker)
    local getPrompt = function()
        if not targetWardrobePrompt or Script.Functions.DistanceFromCharacter(targetWardrobePrompt:FindFirstAncestorWhichIsA("Model"):GetPivot().Position) > 15 then
            repeat task.wait()
                targetWardrobePrompt = Script.Functions.GetNearestPromptWithCondition(targetWardrobeChecker)
            until targetWardrobePrompt ~= nil or shared.Character:GetAttribute("Hiding") or (not Toggles.AutoWardrobe.Value or not Script.Alive or not child or not child:IsDescendantOf(workspace)) or shared.Library.Unloaded
            if (not Toggles.AutoWardrobe.Value or not Script.Alive or not child or not child:IsDescendantOf(workspace)) or shared.Library.Unloaded then
                return
            end
        end
    end
    getPrompt()
    -- Hide Checks
    if shared.Character:GetAttribute("Hiding") then return end
    if not Toggles.AutoWardrobe.Value or not Script.Alive or shared.Library.Unloaded then return end  
    -- Hide
    task.spawn(function() 
        shared.Notify:Log({
            Title = NotifPrefix,
            Description = "Đang bắt đầu làm việc...",
            LinoriaMessage = "[" .. NotifPrefix .. "] Đang bắt đầu làm việc..."
        }, Toggles.AutoWardrobeNotif.Value)
    end)
    local exclusion = Script.Functions.GenerateAutoWardrobeExclusions(targetWardrobePrompt)
    local atempts, maxAtempts = 0, 60
    local isSafeCheck = function(addMoreDist)
        local isSafe = true
        for _, entity in pairs(Script.Temp.AutoWardrobeEntities) do
            if isSafe == false then break end
            local distanceEntity = Script.EntityTable.AutoWardrobe.Distance[child.Name].Distance;
            local entityDeleted = (entity == nil or entity.Parent == nil)
            local inView = Script.Functions.IsInViewOfPlayer(entity.PrimaryPart, distanceEntity + (addMoreDist == true and 15 or 0), exclusion)
            local isClose = Script.Functions.DistanceFromCharacter(entity:GetPivot().Position) < distanceEntity + (addMoreDist == true and 15 or 0)
            isSafe = entityDeleted == true and true or (inView == false and isClose == false);
            if isSafe == false then break end
        end
        return isSafe
    end
    local waitForSafeExit; waitForSafeExit = function()
        if child.Name == "A120" then
            repeat task.wait() until not child:IsDescendantOf(workspace) or (child.PrimaryPart and child.PrimaryPart.Position.Y < -10) or (not Script.Alive or not shared.Character:GetAttribute("Hiding"))
        else   
            local didPlayerSeeEntity = false
            task.spawn(function()
                repeat task.wait()
                    if not Script.Alive or not child or not child:IsDescendantOf(workspace) then break end
                    if shared.Character:GetAttribute("Hiding") and Script.Functions.IsInViewOfPlayer(child.PrimaryPart, distance, exclusion) then
                        didPlayerSeeEntity = true
                        break
                    end
                until false == true
            end)
            repeat task.wait(0.15)
                local isSafe = isSafeCheck()
                if didPlayerSeeEntity == true and isSafe == true then
                    task.spawn(function() 
                        shared.Notify:Log({
                            Title = NotifPrefix,
                            Description = "Đang ra khỏi tủ, quái đã đi ra xa.",
                            LinoriaMessage = "[" .. NotifPrefix .. "] Đang ra khỏi tủ, quái đã đi ra xa."
                        }, Toggles.AutoWardrobeNotif.Value)
                    end)
                    break
                else
                    if isSafe == true and not child:IsDescendantOf(workspace) then 
                        task.spawn(function() 
                            shared.Notify:Log({
                                Title = NotifPrefix,
                                Description = "Đang ra khỏi tủ, quái đã bị xóa.",
                                LinoriaMessage = "[" .. NotifPrefix .. "] Đang ra khỏi tủ, quái đã bị xóa."
                            }, Toggles.AutoWardrobeNotif.Value)
                        end)
                        break 
                    end          
                end
                if not Script.Alive then  
                    if Toggles.AutoWardrobeNotif.Value then shared.Notify:Log("[" .. NotifPrefix .. "] Tự dừng lại vì người dùng quá đẹp trai.") end             
                    task.spawn(function() 
                        shared.Notify:Log({
                            Title = NotifPrefix,
                            Description = "Tự dừng lại vì người dùng quá đẹp trai.",
                            LinoriaMessage = "[" .. NotifPrefix .. "] Tự dừng lại vì người dùng quá đẹp trai."
                        }, Toggles.AutoWardrobeNotif.Value)
                    end)
                    break 
                end                             
            until false == true          
        end
        return true
    end
    local hide = function()
        if (shared.Character:GetAttribute("Hiding") and shared.RootPart.Anchored) then return false end
        getPrompt()
        repeat task.wait()
            atempts += 1
            shared.forcefireproximityprompt(targetWardrobePrompt)
        until atempts > maxAtempts or not Script.Alive or (shared.Character:GetAttribute("Hiding") and shared.RootPart.Anchored)
        if atempts > maxAtempts or not Script.Alive then return false end
        return true
    end
    if child.Name == "AmbushMoving" then
        local LastPos = child:GetPivot().Position
        local IsMoving = false
        task.spawn(function()
            repeat task.wait(0.01)
                local diff = (LastPos - child:GetPivot().Position) / 0.01
                LastPos = child:GetPivot().Position
                IsMoving = diff.Magnitude > 0
            until not child or not child:IsDescendantOf(workspace)
        end)
        repeat task.wait()
            task.spawn(function() 
                shared.Notify:Log({
                    Title = NotifPrefix,
                    Description = "Đợi ambush đến gàn để hệ thống làm việc:)",
                    LinoriaMessage = "[" .. NotifPrefix .. "] Đợi ambush đến gàn để hệ thống làm việc:)",
                }, Toggles.AutoWardrobeNotif.Value)
            end)
            repeat task.wait() until (IsMoving == true and Script.Functions.DistanceFromCharacter(child:GetPivot().Position) <= distance) or (not child or not child:IsDescendantOf(workspace))
            if not child or not child:IsDescendantOf(workspace) then break end
            local success = hide()
            if success then
                task.spawn(function() 
                    shared.Notify:Log({
                        Title = NotifPrefix,
                        Description = "Bình tĩnh đợi nó mất, nhanh tay rồi hẹo đéo ai cứu:))",
                        LinoriaMessage = "[" .. NotifPrefix .. "] Bình tĩnh đợi nó mất, nhanh tay rồi hẹo đéo ai cứu:))",
                    }, Toggles.AutoWardrobeNotif.Value)
                end)
                repeat task.wait() until (IsMoving == false and Script.Functions.DistanceFromCharacter(child:GetPivot().Position) >= distance) or (not child or not child:IsDescendantOf(workspace));
                if not child or not child:IsDescendantOf(workspace) then break end
                Script.RemotesFolder.CamLock:FireServer()
            end
        until (not child or not child:IsDescendantOf(workspace)) or not Script.Alive
    else
        repeat task.wait() until isSafeCheck(true, true) == false
        repeat
            local success = hide()
            if success then
                local finished = waitForSafeExit()
                repeat task.wait() until finished == true        
                Script.RemotesFolder.CamLock:FireServer()
            end
            task.wait()
        until isSafeCheck()
    end
    table.remove(Script.Temp.AutoWardrobeEntities, entityIndex)
    task.spawn(function() 
        shared.Notify:Log({
            Title = NotifPrefix,
            Description = "Hoàn thành.",
            LinoriaMessage = "[" .. NotifPrefix .. "] Hoàn thành.",
        }, Toggles.AutoWardrobeNotif.Value)
    end)
end
end)() end,
    [28] = function()local wax,script,require=ImportGlobals(28)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
function Script.Functions.EnableBreaker(breaker, value)
    breaker:SetAttribute("Enabled", value)
    if value then
        breaker:FindFirstChild("PrismaticConstraint", true).TargetPosition = -0.2
        breaker.Light.Material = Enum.Material.Neon
        breaker.Light.Attachment.Spark:Emit(1)
        breaker.Sound.Pitch = 1.3
    else
        breaker:FindFirstChild("PrismaticConstraint", true).TargetPosition = 0.2
        breaker.Light.Material = Enum.Material.Glass
        breaker.Sound.Pitch = 1.2
    end
    breaker.Sound:Play()
end
function Script.Functions.SolveBreakerBox(breakerBox)
    if not Options.AutoBreakerSolverMethod then return end
    if not breakerBox then return end
    local code = breakerBox:FindFirstChild("Code", true)
    local correct = breakerBox:FindFirstChild("Correct", true)
    repeat task.wait() until code.Text ~= "..." or not breakerBox:IsDescendantOf(workspace)
    if not breakerBox:IsDescendantOf(workspace) then return end
    shared.Notify:Alert({
        Title = "Auto Breaker Solver",
        Description = "Đang giải mã hộp cầu chì...",
        Reason = ""
    })
    if Options.AutoBreakerSolverMethod.Value == "Legit" then
        Script.Temp.UsedBreakers = {}
        if shared.Connections["Reset"] then shared.Connections["Reset"]:Disconnect() end
        if shared.Connections["Code"] then shared.Connections["Code"]:Disconnect() end
        local breakers = {}
        for _, breaker in pairs(breakerBox:GetChildren()) do
            if breaker.Name == "BreakerSwitch" then
                local id = string.format("%02d", breaker:GetAttribute("ID"))
                breakers[id] = breaker
            end
        end
        if code:FindFirstChild("Frame") then
            Script.Functions.AutoBreaker(code, breakers)
            shared.Connections["Reset"] = correct:GetPropertyChangedSignal("Playing"):Connect(function()
                if correct.Playing then table.clear(Script.Temp.UsedBreakers) end
            end)
            shared.Connections["Code"] = code:GetPropertyChangedSignal("Text"):Connect(function()
                task.delay(0.1, Script.Functions.AutoBreaker, code, breakers)
            end)
        end
    else
        repeat task.wait(0.1)
            Script.RemotesFolder.EBF:FireServer()
        until not workspace.CurrentRooms["100"]:FindFirstChild("DoorToBreakDown")
        shared.Notify:Alert({
            Title = "Dương Api",
            Description = "Giải mã hộp cầu chì thành công.",
        })
    end
end
function Script.Functions.AutoBreaker(code, breakers)
    local newCode = code.Text
    if not tonumber(newCode) and newCode ~= "??" then return end
    local isEnabled = code.Frame.BackgroundTransparency == 0
    local breaker = breakers[newCode]
    if newCode == "??" and #Script.Temp.UsedBreakers == 9 then
        for i = 1, 10 do
            local id = string.format("%02d", i)
            if not table.find(Script.Temp.UsedBreakers, id) then
                breaker = breakers[id]
            end
        end
    end
    if breaker then
        table.insert(Script.Temp.UsedBreakers, newCode)
        if breaker:GetAttribute("Enabled") ~= isEnabled then
            Script.Functions.EnableBreaker(breaker, isEnabled)
        end
    end
end
end)() end,
    [29] = function()local wax,script,require=ImportGlobals(29)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
local GodmodeRaycastParams = RaycastParams.new()
GodmodeRaycastParams.FilterType = Enum.RaycastFilterType.Exclude
function Script.Functions.CameraCheck(child)
    if child:IsA("BasePart") and child.Name == "Guidance" and Toggles.GuidingLightESP.Value then
        Script.Functions.GuidingLightEsp(child)
    end
end
function Script.Functions.SetupCameraConnection(camera)
    for _, child in pairs(camera:GetChildren()) do
        task.spawn(Script.Functions.CameraCheck, child)
    end
    shared.Connections["CameraChildAdded"] = camera.ChildAdded:Connect(function(child)
        task.spawn(Script.Functions.CameraCheck, child)
    end)
end
function Script.Functions.SetupRoomConnection(room)
    if Options.NotifyEntity.Value["Halt Room"] and room:GetAttribute("RawName") == "HaltHallway" then
        shared.Notify:Alert({
            Title = "ENTITIES",
            Description = "Halt sẽ xuất hiện ở phòng kế tiếp!",
            Image = Script.EntityTable.NotifyReason["HaltRoom"].Image,
            Warning = true
        })
    end
    for _, child in pairs(room:GetDescendants()) do
        if Toggles.DeleteSeek.Value and shared.RootPart and child.Name == "Collision" then
            task.spawn(Script.Functions.DeleteSeek, child)
        end
        task.spawn(Script.Functions.ChildCheck, child)
    end
    shared.Connections[room.Name .. "DescendantAdded"] = room.DescendantAdded:Connect(function(child)
        if tonumber(room.Name) == Script.CurrentRoom then
            if Script.Functions.ObjectiveESP(child) then
                return
            elseif Toggles.ItemESP.Value and Script.Functions.ItemCondition(child) then
                Script.Functions.ItemESP(child)
                return
            elseif Toggles.GoldESP.Value and child.Name == "GoldPile" then
                Script.Functions.GoldESP(child)
                return
            end
        end
        if Toggles.DeleteSeek.Value and shared.RootPart and child.Name == "Collision" then
            task.spawn(Script.Functions.DeleteSeek, child)
        end
        task.delay(0.1, Script.Functions.ChildCheck, child)
    end)
end
function Script.Functions.SetupDropConnection(drop)
    if Toggles.ItemESP.Value then
        Script.Functions.ItemESP(drop, true)
    end
    task.spawn(function()
        local prompt = drop:WaitForChild("ModulePrompt", 3)
        if prompt then
            table.insert(Script.PromptTable.GamePrompts, prompt)
        end
    end)
end
function Script.Functions.SetupCharacterConnection(newCharacter)
    shared.Character = newCharacter
    if shared.Character then
        Script.NoCharRaycastParam.FilterDescendantsInstances = {shared.Character}
        if Toggles.EnableJump.Value then
            shared.Character:SetAttribute("CanJump", true)
        end
        for _, oldConnection in pairs(Script.FeatureConnections.Character) do
            oldConnection:Disconnect()
        end
        Script.FeatureConnections.Character["ChildAdded"] = shared.Character.ChildAdded:Connect(function(child)
            if not (child:IsA("Tool") and child.Name:match("LibraryHintPaper")) then return end
            task.wait(0.1)
            local code = Script.Functions.GetPadlockCode(child)
            local output, count = string.gsub(code, "_", "x")
            local padlock = workspace:FindFirstChild("Padlock", true)
            if Toggles.AutoLibrarySolver.Value and tonumber(code) and Script.Functions.DistanceFromCharacter(padlock) <= Options.AutoLibraryDistance.Value then
                Script.RemotesFolder.PL:FireServer(code)
            end
            if Toggles.NotifyPadlock.Value and count < 5 then
                shared.Notify:Alert({
                    Title = "Dương Api",
                    Description = string.format("Mã thư viện: %s", output),
                    Reason = if tonumber(code) then "Giải mã thư viện" else "Bạn vẫn còn thiếu một số quyển vở",
                })
                if Toggles.NotifyChat.Value and count == 0 then
                    shared.RBXGeneral:SendAsync(string.format("Library Code: %s", output))
                end
            end
        end)
        Script.FeatureConnections.Character["CanJump"] = shared.Character:GetAttributeChangedSignal("CanJump"):Connect(function()
            if not Toggles.EnableJump then return end
            if not Toggles.EnableJump.Value then return end
            if not shared.Character:GetAttribute("CanJump") then
                shared.Character:SetAttribute("CanJump", true)
            end
        end)
        Script.FeatureConnections.Character["Crouching"] = shared.Character:GetAttributeChangedSignal("Crouching"):Connect(function()
            if not Toggles.AntiHearing then return end
            if not Toggles.AntiHearing.Value then return end
            if not shared.Character:GetAttribute("Crouching") then
                Script.RemotesFolder.Crouch:FireServer(true)
            end
        end)
        Script.FeatureConnections.Character["Hiding"] = shared.Character:GetAttributeChangedSignal("Hiding"):Connect(function()
            if not shared.Character:GetAttribute("Hiding") then return end
            if not Toggles.TranslucentHidingSpot or not Options.HidingTransparency then return end
            if not Toggles.TranslucentHidingSpot.Value then return end
            for _, obj in pairs(workspace.CurrentRooms:GetDescendants()) do
                if not obj:IsA("ObjectValue") and obj.Name ~= "HiddenPlayer" then continue end
                if obj.Value == shared.Character then
                    task.spawn(function()
                        local affectedParts = {}
                        for _, part in pairs(obj.Parent:GetChildren()) do
                            if not part:IsA("BasePart") or part.Name:match("Collision") then continue end
                            part.Transparency = Options.HidingTransparency.Value
                            table.insert(affectedParts, part)
                        end
                        repeat task.wait()
                            for _, part in pairs(affectedParts) do
                                task.wait()
                                part.Transparency = Options.HidingTransparency.Value
                            end
                        until not shared.Character:GetAttribute("Hiding") or not Toggles.TranslucentHidingSpot.Value
                        for _, part in pairs(affectedParts) do
                            part.Transparency = 0
                        end
                    end)
                    break
                end
            end
        end)
        Script.FeatureConnections.Character["Oxygen"] = shared.Character:GetAttributeChangedSignal("Oxygen"):Connect(function()
            if not Toggles.NotifyOxygen then return end
            if not Toggles.NotifyOxygen.Value then return end
            if shared.Character:GetAttribute("Oxygen") >= 100 then return end
            if wax.shared.ExecutorSupport["firesignal"] then 
                if Options.CaptionStyle.Value == "Doors" then
                    firesignal(Script.RemotesFolder.Caption.OnClientEvent, string.format("Oxygen: %.1f", shared.Character:GetAttribute("Oxygen")))
                elseif Options.CaptionStyle.Value == "Linoria" then
                    Script.Functions.Captions(string.format("Oxygen: %.1f", shared.Character:GetAttribute("Oxygen")))
                end
            else
                Script.Functions.Captions(string.format("Oxygen: %.1f", shared.Character:GetAttribute("Oxygen")))
            end
        end)
    end
    shared.Humanoid = shared.Character:WaitForChild("Humanoid")
    if shared.Humanoid then
        for _, oldConnection in pairs(Script.FeatureConnections.Humanoid) do
            oldConnection:Disconnect()
        end
        shared.Twerk:Setup()
        if Toggles.Twerk.Value then
            shared.Twerk:Enable()
        end
        Script.FeatureConnections.Humanoid["Move"] = shared.Humanoid:GetPropertyChangedSignal("MoveDirection"):Connect(function()
            if not Toggles.FastClosetExit then return end
            if Toggles.FastClosetExit.Value and shared.Humanoid.MoveDirection.Magnitude > 0 and shared.Character:GetAttribute("Hiding") then
                Script.RemotesFolder.CamLock:FireServer()
            end
        end)
        Script.FeatureConnections.Humanoid["Jump"] = shared.Humanoid:GetPropertyChangedSignal("JumpHeight"):Connect(function()
            if not Script.IsFools and Toggles.EnableJump.Value then
                shared.Humanoid.JumpHeight = Options.JumpBoost.Value
            end
            if not Toggles.SpeedBypass then return end
            if not Toggles.SpeedBypass.Value and Script.LatestRoom.Value < 100 and not Script.FakeRevive.Enabled then
                if shared.Humanoid.JumpHeight > 0 then
                    Script.LastSpeed = Options.WalkSpeed.Value
                    Options.WalkSpeed:SetMax(18)
                elseif Script.LastSpeed > 0 then
                    Options.WalkSpeed:SetMax(22)
                    Options.WalkSpeed:SetValue(Script.LastSpeed)
                    Script.LastSpeed = 0
                end
            end
        end)
        Script.FeatureConnections.Humanoid["Died"] = shared.Humanoid.Died:Connect(function()
            if Script.CollisionClone then
                Script.CollisionClone:Destroy()
            end
        end)
        if Script.IsFools then
            Script.Tracks.ItemHoldTrack = shared.Humanoid:LoadAnimation(Script.Anims.HoldAnim)
            Script.Tracks.ItemThrowTrack = shared.Humanoid:LoadAnimation(Script.Anims.ThrowAnim)
        end
    end
    shared.RootPart = shared.Character:WaitForChild("HumanoidRootPart")
    if shared.RootPart then
        if Toggles.NoAccel.Value then
            Script.Temp.NoAccelValue = shared.RootPart.CustomPhysicalProperties.Density
            local existingProperties = shared.RootPart.CustomPhysicalProperties
            shared.RootPart.CustomPhysicalProperties = PhysicalProperties.new(100, existingProperties.Friction, existingProperties.Elasticity, existingProperties.FrictionWeight, existingProperties.ElasticityWeight)
        end
        Script.FeatureConnections.RootPart["RootChildAdded"] = shared.RootPart.ChildAdded:Connect(function(child)
            if shared.CheckToggle("NoVoiceActing", true) and Script.Functions.VoiceCondition(child) then
                child:Destroy() 
            end
        end)
        Script.FeatureConnections.RootPart["Touched"] = shared.RootPart.Touched:Connect(function(touchedPart)
            if tonumber(touchedPart.Name) and touchedPart.Name == touchedPart.Parent.Name then
                shared.LocalPlayer:SetAttribute("CurrentRoom", tonumber(touchedPart.Name))
            end
        end)
    end
    Script.Collision = shared.Character:WaitForChild("Collision")
    if Script.Collision then
        if Toggles.UpsideDown.Value then
            Script.Collision.Rotation = Vector3.new(Script.Collision.Rotation.X, Script.Collision.Rotation.Y, -90)
        end
        Script.FeatureConnections.Player["CollisionOffsetGodmodeCanCollide"] = Script.Collision:GetPropertyChangedSignal("CanCollide"):Connect(function()
            if not (Toggles.CollisionOffsetGodmode.Value and (shared.Library.IsMobile or Options.CollisionOffsetGodmodeKey:GetState())) then return end
            Script.Collision.CollisionGroup = "PlayerCrouching"
            Script.Collision.CollisionCrouch.CollisionGroup = "PlayerCrouching"
            Script.Collision.CanCollide = false
            Script.Collision.CollisionCrouch.CanCollide = false
        end)
        Script.FeatureConnections.Player["CollisionOffsetGodmodeCrouchCanCollide"] = Script.Collision.CollisionCrouch:GetPropertyChangedSignal("CanCollide"):Connect(function()
            if not (Toggles.CollisionOffsetGodmode.Value and (shared.Library.IsMobile or Options.CollisionOffsetGodmodeKey:GetState())) then return end
            Script.Collision.CollisionGroup = "PlayerCrouching"
            Script.Collision.CollisionCrouch.CollisionGroup = "PlayerCrouching"
            Script.Collision.CanCollide = false
            Script.Collision.CollisionCrouch.CanCollide = false
            local crouchAnimID = shared.Character.Animations.Crouch.AnimationId
            for _, track in pairs(shared.Humanoid:GetPlayingAnimationTracks()) do
                if track.Animation.AnimationId == crouchAnimID then
                    track:Stop(0)
                    break
                end
            end
        end)
        Script.Collision.CanQuery = false
        Script.Collision.CollisionCrouch.CanQuery = false
        Script.CollisionClone = Script.Collision:Clone()
        Script.CollisionClone.CanCollide = false
        Script.CollisionClone.Massless = true
        Script.CollisionClone.CanQuery = false
        Script.CollisionClone.Name = "CollisionClone"
        if Script.CollisionClone:FindFirstChild("CollisionCrouch") then
            Script.CollisionClone.CollisionCrouch:Destroy()
        end
        Script.CollisionClone.Parent = shared.Character
    end
    if Script.IsMines then
        if shared.Character then
            shared.Connections["AnticheatBypassTheMines"] = shared.Character:GetAttributeChangedSignal("Climbing"):Connect(function()
                if not Toggles.TheMinesAnticheatBypass then return end
                if not Toggles.TheMinesAnticheatBypass.Value then return end
                if not shared.Character:GetAttribute("Climbing") then return end
                task.wait(1)
                shared.Character:SetAttribute("Climbing", false)
                Script.Bypassed = true
                for _, ladderEsp in pairs(Script.ESPTable.None) do
                    ladderEsp.Destroy()
                end
                Options.WalkSpeed:SetMax(75)
                Options.FlySpeed:SetMax(75)
                shared.Notify:Alert({
                    Title = "Anticheat Bypass",
                    Description = "Bypassed the anticheat successfully!",
                    Reason = "This will only last until the next cutscene!",
                    LinoriaMessage = "Bypassed the anticheat successfully! This will only last until the next cutscene",
                    Time = 7
                })
                if workspace:FindFirstChild("_internal_mspaint_acbypassprogress") then workspace:FindFirstChild("_internal_mspaint_acbypassprogress"):Destroy() end
            end)
        end
        if shared.Humanoid then
            shared.Humanoid.MaxSlopeAngle = Options.MaxSlopeAngle.Value
        end
    end
end
function Script.Functions.SetupOtherPlayerConnection(player: Player)
    if player.Character then
        task.spawn(Script.Functions.SetupOtherCharacterConnection, player.Character)
    end
    shared.Connect:GiveSignal(player.CharacterAdded:Connect(function(newCharacter)
        if Toggles.PlayerESP and Toggles.PlayerESP.Value then
            task.delay(1, Script.Functions.PlayerESP, newCharacter)
        end
        task.delay(1, Script.Functions.SetupOtherCharacterConnection, newCharacter)
    end))
end
function Script.Functions.SetupOtherCharacterConnection(character: Model)
    shared.Connections[character.Name .. "ChildAdded"] = character.ChildAdded:Connect(function(child)
        if not (child:IsA("Tool") and child.Name:match("LibraryHintPaper")) then return end
        task.wait(0.1)
        local code = Script.Functions.GetPadlockCode(child)
        local output, count = string.gsub(code, "_", "x")
        local padlock = workspace:FindFirstChild("Padlock", true)
        if Toggles.AutoLibrarySolver.Value and tonumber(code) and Script.Functions.DistanceFromCharacter(padlock) <= Options.AutoLibraryDistance.Value then
            Script.RemotesFolder.PL:FireServer(code)
        end
        if Toggles.NotifyPadlock.Value and count < 5 then
            shared.Notify:Alert({
                Title = "Dương Api",
                Description = string.format("Mã thư viện: %s", output),
                Reason = if tonumber(code) then "Giải mã khóa" else "Bạn vẫn còn thiếu một số vở",
            })
            if Toggles.NotifyChat.Value and count == 0 then
                shared.RBXGeneral:SendAsync(string.format("Mã thư viện: %s", output))
            end
        end
    end)
    local otherRootPart = character:WaitForChild("HumanoidRootPart")
    if otherRootPart then
        shared.Connections[character.Name .. "RootChildAdded"] = otherRootPart.ChildAdded:Connect(function(child)
            if shared.CheckToggle("NoVoiceActing", true) and Script.Functions.VoiceCondition(child) then
                child:Destroy() 
            end
        end)
    end
end
end)() end,
    [30] = function()local wax,script,require=ImportGlobals(30)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
local ESPLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/laitung1122/Duonga2/main/esp.lua"))()
shared.ESPLibrary = ESPLibrary
type ESP = {
    Color: Color3,
    IsEntity: boolean,
    IsDoubleDoor: boolean,
    Object: Instance,
    Offset: Vector3,
    Text: string,
    TextParent: Instance,
    Type: string
}
function Script.Functions.ESP(args: ESP)
    if not args.Object then return Script.Functions.Warn("ESP Object is nil") end
    local ESPManager = {
        Object = args.Object,
        Text = args.Text or "No Text",
        Color = args.Color or Color3.new(),
        MaxDistance = args.MaxDistance or 5000,
        Offset = args.Offset or Vector3.zero,
        IsEntity = args.IsEntity or false,
        IsDoubleDoor = args.IsDoubleDoor or false,
        Type = args.Type or "None",
        OnDestroy = args.OnDestroy or nil,
        Invisible = false,
        Humanoid = nil
    }
    if ESPManager.IsEntity and ESPManager.Object.PrimaryPart then
        if ESPManager.Object.PrimaryPart.Transparency == 1 then
            ESPManager.Invisible = true
            ESPManager.Object.PrimaryPart.Transparency = 0.99
        end
        local humanoid = ESPManager.Object:FindFirstChildOfClass("Humanoid")
        if not humanoid then humanoid = Instance.new("Humanoid", ESPManager.Object) end
        ESPManager.Humanoid = humanoid
    end
    local ESPInstance = ESPLibrary.ESP.Highlight({
        Name = ESPManager.Text,
        Model = ESPManager.Object,
        MaxDistance = ESPManager.MaxDistance,
        StudsOffset = ESPManager.Offset,
        FillColor = ESPManager.Color,
        OutlineColor = ESPManager.Color,
        TextColor = ESPManager.Color,
        TextSize = Options.ESPTextSize.Value or 16,
        FillTransparency = Options.ESPFillTransparency.Value,
        OutlineTransparency = Options.ESPOutlineTransparency.Value,
        Tracer = {
            Enabled = true,
            From = Options.ESPTracerStart.Value,
            Color = ESPManager.Color
        },
        Arrow = {
            Enabled = true,
            CenterOffset = Options.ESPArrowCenterOffset.Value,
            Color = ESPManager.Color
        },
        OnDestroy = ESPManager.OnDestroy or function()
            if ESPManager.Object.PrimaryPart and ESPManager.Invisible then ESPManager.Object.PrimaryPart.Transparency = 1 end
            if ESPManager.Humanoid then ESPManager.Humanoid:Destroy() end
        end
    })
    table.insert(Script.ESPTable[args.Type], ESPInstance)
    return ESPInstance
end
function Script.Functions.DoorESP(room)
    local door = room:WaitForChild("Door", 5)
    if door then
        local doorNumber = tonumber(room.Name) + 1
        if Script.IsMines then
            doorNumber += 100
        end
        local opened = door:GetAttribute("Opened")
        local locked = room:GetAttribute("RequiresKey")
        local doorState = if opened then "[mở]" elseif locked then "[Khóa]" else ""
        local doorIdx = Script.Functions.RandomString()
        local doorEsp = Script.Functions.ESP({
            Type = "Door",
            Object = door:WaitForChild("Door"),
            Text = string.format("Cửa %s %s", doorNumber, doorState),
            Color = Options.DoorEspColor.Value,
            OnDestroy = function()
                if Script.FeatureConnections.Door[doorIdx] then Script.FeatureConnections.Door[doorIdx]:Disconnect() end
            end
        })
        Script.FeatureConnections.Door[doorIdx] = door:GetAttributeChangedSignal("Mở"):Connect(function()
            if doorEsp then doorEsp.SetText(string.format("Cửa %s [Mở]", doorNumber)) end
            if Script.FeatureConnections.Door[doorIdx] then Script.FeatureConnections.Door[doorIdx]:Disconnect() end
        end)
    end
end 
function Script.Functions.ObjectiveESP(child)
    -- Backdoor
    if child.Name == "TimerLever" then
        Script.Functions.ESP({
            Type = "Objective",
            Object = child,
            Text = string.format("Cần gạt thòi gian [+%s]", child.TakeTimer.TextLabel.Text),
            Color = Options.ObjectiveEspColor.Value
        })
    -- Backdoor + Hotel
    elseif child.Name == "KeyObtain" then
        Script.Functions.ESP({
            Type = "Objective",
            Object = child,
            Text = "Chìa khóa",
            Color = Options.ObjectiveEspColor.Value
        })
    -- Hotel
    elseif child.Name == "ElectricalKeyObtain" then
        Script.Functions.ESP({
            Type = "Objective",
            Object = child,
            Text = "Chìa khóa điện",
            Color = Options.ObjectiveEspColor.Value
        })
    elseif child.Name == "LeverForGate" then
        Script.Functions.ESP({
            Type = "Objective",
            Object = child,
            Text = "Cần gạt",
            Color = Options.ObjectiveEspColor.Value
        })
    elseif child.Name == "LiveHintBook" then
        Script.Functions.ESP({
            Type = "Objective",
            Object = child,
            Text = "Vở",
            Color = Options.ObjectiveEspColor.Value
        })
    elseif child.Name == "LiveBreakerPolePickup" then
        Script.Functions.ESP({
            Type = "Objective",
            Object = child,
            Text = "Breaker",
            Color = Options.ObjectiveEspColor.Value
        })
    -- Mines
    elseif child.Name == "MinesGenerator" then
        Script.Functions.ESP({
            Type = "Objective",
            Object = child,
            Text = "Máy phát điện",
            Color = Options.ObjectiveEspColor.Value
        })
    elseif child.Name == "MinesGateButton" then
        Script.Functions.ESP({
            Type = "Objective",
            Object = child,
            Text = "Nút bấm",
            Color = Options.ObjectiveEspColor.Value
        })
    elseif child.Name == "FuseObtain" then
        Script.Functions.ESP({
            Type = "Objective",
            Object = child,
            Text = "Cầu chì",
            Color = Options.ObjectiveEspColor.Value
        })
    elseif child.Name == "MinesAnchor" then
        local sign = child:WaitForChild("Sign", 5)
        if sign and sign:FindFirstChild("TextLabel") then
            Script.Functions.ESP({
                Type = "Objective",
                Object = child,
                Text = string.format("Trụ điện %s", sign.TextLabel.Text),
                Color = Options.ObjectiveEspColor.Value
            })
        end
    elseif child.Name == "WaterPump" then
        local wheel = child:WaitForChild("Wheel", 5)
        local onFrame = child:FindFirstChild("OnFrame", true)
        if wheel and (onFrame and onFrame.Visible) then
            local pumpIdx = Script.Functions.RandomString()
            local pumpEsp = Script.Functions.ESP({
                Type = "Objective",
                Object = wheel,
                Text = "Máy bơm nước",
                Color = Options.ObjectiveEspColor.Value,
                OnDestroy = function()
                    if Script.FeatureConnections.Pump[pumpIdx] then Script.FeatureConnections.Pump[pumpIdx]:Disconnect() end
                end
            })
            Script.FeatureConnections.Pump[pumpIdx] = onFrame:GetPropertyChangedSignal("Visible"):Connect(function()
                if pumpEsp then pumpEsp.Destroy() end
            end)
        end
    else 
        return false
    end
    return true
end
function Script.Functions.EntityESP(entity)
    Script.Functions.ESP({
        Type = "Entity",
        Object = entity,
        Text = Script.Functions.GetShortName(entity.Name),
        Color = Options.EntityEspColor.Value,
        IsEntity = entity.Name ~= "JeffTheKiller",
    })
end
function Script.Functions.SideEntityESP(entity)
    if entity.Name == "Snare" and not entity:FindFirstChild("Hitbox") then return end
    Script.Functions.ESP({
        Type = "SideEntity",
        Object = entity,
        Text = Script.Functions.GetShortName(entity.Name),
        TextParent = entity.PrimaryPart,
        Color = Options.EntityEspColor.Value,
    })
end
function Script.Functions.ItemESP(item, dropped)
    Script.Functions.ESP({
        Type = dropped and "DroppedItem" or "Item",
        Object = item,
        Text = Script.Functions.GetShortName(item.Name),
        Color = Options.ItemEspColor.Value
    })
end
function Script.Functions.ChestESP(chest)
    local text = chest.Name:gsub("Box", ""):gsub("_Vine", ""):gsub("_Small", ""):gsub("Locked", "")
    local locked = chest:GetAttribute("Locked")
    local state = if locked then "[Khóa]" else ""
    Script.Functions.ESP({
        Type = "Chest",
        Object = chest,
        Text = string.format("%s %s", text, state),
        Color = Options.ChestEspColor.Value
    })
end
function Script.Functions.PlayerESP(character: Model)
    if not (character and character.PrimaryPart and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0) then return end
    local playerEsp = Script.Functions.ESP({
        Type = "Player",
        Object = character,
        Text = string.format("%s [%.1f]", character.Name, character.Humanoid.Health),
        TextParent = character.PrimaryPart,
        Color = Options.PlayerEspColor.Value
    })
    Script.FeatureConnections.Player[character.Name] = character.Humanoid.HealthChanged:Connect(function(newHealth)
        if newHealth > 0 then
            playerEsp.SetText(string.format("%s [%.1f]", character.Name, newHealth))
        else
            if Script.FeatureConnections.Player[character.Name] then Script.FeatureConnections.Player[character.Name]:Disconnect() end
            playerEsp.Destroy()
        end
    end)
end
function Script.Functions.HidingSpotESP(spot)
    Script.Functions.ESP({
        Type = "HidingSpot",
        Object = spot,
        Text = if spot:GetAttribute("LoadModule") == "Bed" then "Bed" else Script.HidingPlaceName[Script.Floor.Value],
        Color = Options.HidingSpotEspColor.Value
    })
end
function Script.Functions.GoldESP(gold)
    Script.Functions.ESP({
        Type = "Gold",
        Object = gold,
        Text = string.format("Vàng [%s]", gold:GetAttribute("GoldValue")),
        Color = Options.GoldEspColor.Value
    })
end
function Script.Functions.GuidingLightEsp(guidance)
    local part = guidance:Clone()
    part.Anchored = true
    part.Size = Vector3.new(3, 3, 3)
    part.Transparency = 0.5
    part.Name = "_Guidance"
    part:ClearAllChildren()
    part.Parent = shared.Workspace
    Script.Temp.Guidance[guidance] = part
    local guidanceEsp = Script.Functions.ESP({
        Type = "Guiding",
        Object = part,
        Text = "Guidance",
        Color = Options.GuidingLightEspColor.Value
    })
    guidance.AncestryChanged:Connect(function()
        if not guidance:IsDescendantOf(workspace) then
            if Script.Temp.Guidance[guidance] then Script.Temp.Guidance[guidance] = nil end
            if part then part:Destroy() end
            if guidanceEsp then guidanceEsp.Destroy() end
        end
    end)
end
end)() end,
    [31] = function()local wax,script,require=ImportGlobals(31)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
function Script.Functions.CalculateHideTime(room: number)
    for _, range in ipairs(Script.HideTimeValues) do
        if room >= range.min and room <= range.max then
            return math.round(range.a * (room - range.b) + range.c)
        end
    end    
    return nil
end
function Script.Functions.GetShortName(entityName: string)
    if Script.EntityTable.ShortNames[entityName] then
        return Script.EntityTable.ShortNames[entityName]
    end
    for suffix, fix in pairs(Script.SuffixPrefixes) do
        entityName = entityName:gsub(suffix, fix)
    end
    return entityName
end
function Script.Functions.DisableDupe(dupeRoom, value, isSpaceRoom)
    if isSpaceRoom then
        local collision = dupeRoom:WaitForChild("Collision", 5)
        if collision then
            collision.CanCollide = value
            collision.CanTouch = not value
        end
    else
        local doorFake = dupeRoom:WaitForChild("DoorFake", 5)
        if doorFake then
            doorFake:WaitForChild("Hidden", 5).CanTouch = not value
            local lock = doorFake:WaitForChild("Lock", 5)
            if lock and lock:FindFirstChild("UnlockPrompt") then
                lock.UnlockPrompt.Enabled = not value
            end
        end
    end
end
function Script.Functions.DeleteSeek(collision: BasePart)
    if not shared.RootPart then return end
    task.spawn(function()
        local attemps = 0
        repeat task.wait() attemps += 1 until collision.Parent or attemps > 200
        if collision:IsDescendantOf(workspace) and (collision.Parent and collision.Parent.Name == "TriggerEventCollision") then
            shared.Notify:Alert({
                Title = "Dương Api",
                Description = "Đang xóa seek, bình tĩnh :)...",
                Reason = "",
            })
            task.delay(4, function()
                if collision:IsDescendantOf(workspace) then
                    shared.Notify:Alert({
                        Title = "Dương Api",
                        Description = "Ca này không cứu nổi vì lỗi :v!",
                        Reason = "",
                    })
                end
            end)
            if shared.firetouch then
                shared.RootPart.Anchored = true
                task.delay(0.25, function() shared.RootPart.Anchored = false end)
                repeat
                    if collision:IsDescendantOf(workspace) then shared.firetouch(collision, shared.RootPart, 1) end
                    task.wait()
                    if collision:IsDescendantOf(workspace) then shared.firetouch(collision, shared.RootPart, 0) end
                    task.wait()
                until not collision:IsDescendantOf(workspace) or not Toggles.DeleteSeek.Value
            else
                collision:PivotTo(CFrame.new(shared.RootPart.Position))
                shared.RootPart.Anchored = true
                repeat task.wait() until not collision:IsDescendantOf(workspace) or not Toggles.DeleteSeek.Value
                shared.RootPart.Anchored = false
            end
            if not collision:IsDescendantOf(workspace) then
                shared.Notify:Log({
                    Title = "Dương Api",
                    Description = "Đã xóa thành công :)!",
                })
            end
        end
    end)
end
function Script.Functions.AvoidEntity(value: boolean, oldNoclip: boolean)
    if not shared.RootPart or not Script.Collision then return end
    local lastCFrame = shared.RootPart.CFrame
    task.wait()
    if value then
        Toggles.Noclip:SetValue(true)
        Script.Collision.Position += Vector3.new(0, 24, 0)
        task.wait()
        Script.Collision:PivotTo(lastCFrame)
    else
        Script.Collision.Position -= Vector3.new(0, 24, 0)
        task.wait()
        Script.Collision:PivotTo(lastCFrame)
        Toggles.Noclip:SetValue(oldNoclip or false)
    end
end
end)() end,
    [32] = function()local wax,script,require=ImportGlobals(32)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
type tPathfind = {
    esp: boolean,
    room_number: number, -- the room number
    real: table,
    fake: table,
    destroyed: boolean -- if the pathfind was destroyed for the Teleport
}
type tGroupTrack = {
    nodes: table,
    hasStart: boolean,
    hasEnd: boolean,
}
--@Internal nodes sorted by @GetNodes or @Pathfind
type tSortedNodes = {
    real: table,
    fake: table,
    room: number,
}
local function tGroupTrackNew(startNode: Part | nil): tGroupTrack
    local create: tGroupTrack = {
        nodes = startNode and {startNode} or {},
        hasStart = false,
        hasEnd   = false,
    }
    return create
end
--@Internal funtion
local function changeNodeColor(node: Model, color: Color3): Model
    if color == nil then
        node.Color = Script.MinecartPathNodeColor.Yellow
        node.Transparency = 1
        node.Size = Vector3.new(1.0, 1.0, 1.0)
        return
    end
    node.Color = color
    node.Material = Enum.Material.Neon
    node.Transparency = 0
    node.Shape = Enum.PartType.Ball
    node.Size = Vector3.new(0.7, 0.7, 0.7)
    return node
end
--@Internal function
--@Return #boolean. True if the pathfind algorithm was ran.
local function HasAlreadyPathfind(nodesFolder: Folder): boolean
    local hasPathfind = nodesFolder:GetAttribute("_mspaint_nodes_pathfind")
    return hasPathfind
end
--@Internal function
local function HasNodesToPathfind(room: Model)
    local roomNumber = tonumber(room.Name)
    --Make room number restrictions to avoid useless mapping.
    local seekChaseMinecartRooms = (roomNumber >= 42 and roomNumber <= 49)
    local seekChaseDuctsRoom     = (roomNumber >= 95 and roomNumber <= 100)
    local result = (seekChaseMinecartRooms or seekChaseDuctsRoom)
    Script.Functions.Minecart.debug("[HasNodesToPathfind]: " .. tostring(result) .. " - " .. room.Name)
    return result
end
--@Internal funtion
local function sortNodes(nodes: table, reversed: boolean) -- Sort nodes by their number
    table.sort(nodes, function(a, b)
        local Anumber, _ = (a.Name):gsub("[^%d+]", "")
        local Bnumber, _ = (b.Name):gsub("[^%d+]", "")
        if reversed then
            return tonumber(Anumber) > tonumber(Bnumber) --example: 100 to 0
        end
        return tonumber(Anumber) < tonumber(Bnumber) --example: 0 to 100
    end)
    return nodes
end
local function PathfindGetNodes(room: Model): tSortedNodes | nil
    Script.Functions.Minecart.debug("[GetNodes] Starting getting nodes for: " .. room.Name)
    if not HasNodesToPathfind(room) then return end
    local Nodes = {
        real = {},
        fake = {}
    }
    local nodeArray = room:WaitForChild("RunnerNodes", 5.0)
    if (nodeArray == nil) then 
        Script.Functions.Minecart.debug("[GetNodes] No node has been found for the room: " .. room.Name)
        return
    end
    if not HasAlreadyPathfind(nodeArray) then 
        Script.Functions.Minecart.debug("[GetNodes] Pathfind not initialized for room: " .. room.Name)
        Script.Functions.Minecart.Pathfind(room, true)
        return 
    end
    Script.Functions.Minecart.debug("[GetNodes] Get real & fake nodes for room: " .. room.Name, " - nodes:" .. tostring(#nodeArray:GetChildren()))
    for _, node: Part in ipairs(nodeArray:GetChildren()) do
        --check for real nodes
        local realNumber = node:GetAttribute("_mspaint_real_node")
        if realNumber then table.insert(Nodes.real, node) continue end
        --check for fake nodes
        local fakeNumber = node:GetAttribute("_mspaint_fake_node")
        if fakeNumber then table.insert(Nodes.fake, node) end
    end
    --If there's no nodes, return the empty table
    if #Nodes.real <= 0 and #Nodes.fake <= 0 then 
        Script.Functions.Minecart.debug("[GetNodes] No node has been mapped yet for room: " .. room.Name)
        return
    end
    local sortedReal = sortNodes(Nodes.real)
    local sortedFake = sortNodes(Nodes.fake)
    local nodesList = {
        real = sortedReal,
        fake = sortedFake,
        roomNumber = tonumber(room.Name)
    }
    Script.Functions.Minecart.debug("[GetNodes] Successfully sent sorted nodes in room: " .. room.Name) 
    return nodesList
end
--@Internal function
--@Return nil. __Set the node attribute.__ Can only be called after the __@Pathfind function is completed.__
local function PathfindSetNodes(nodes: table, nameAttribute: string)
    Script.Functions.Minecart.debug("[SetNodes] Setting pathfind attributes") 
    for i, node: Part in ipairs(nodes) do
        node:SetAttribute(nameAttribute, i)
    end
end
local WhitelistConfig = {
    [45] = {firstKeep = 3, lastKeep = 2},
    [46] = {firstKeep = 2, lastKeep = 2},
    [47] = {firstKeep = 2, lastKeep = 2},
    [48] = {firstKeep = 2, lastKeep = 2},
    [49] = {firstKeep = 2, lastKeep = 4},
}
--@Internal function
local function NodeDestroy(nodesList: tSortedNodes)
    if not nodesList then return end
    print("[NodeDestroy] Attempting to destroy nodes in room: " .. tostring(nodesList.roomNumber))
    local roomConfig = WhitelistConfig[nodesList.roomNumber]
    local _firstKeep = roomConfig.firstKeep
    local _lastKeep  = roomConfig.lastKeep
    local _removeTotal = #nodesList.real - (_firstKeep + _lastKeep) --remove nodes that arent in the first or last
    for idx=1, _removeTotal do
        local node = nodesList.real[_firstKeep + 1]
        --changeNodeColor(node, MinecartPathNodeColor.Orange) --debug only
        node:Destroy()
        table.remove(nodesList.real, _firstKeep + 1)
    end
    --Destroy all the fake nodes
    for _, node in ipairs(nodesList.fake) do
        node:Destroy()
        table.remove(nodesList.fake, 1)
    end
    Script.Functions.Minecart.debug(string.format("[NodeDestroy] Task completed, remaining: Real nodes: %d | Fake nodes %s", #nodesList.real, #nodesList.fake))
end
local function HasAlreadyDestroyed(room: Model): boolean
    Script.Functions.Minecart.debug("[HasAlreadyDestroyed] Checking destroyed nodes on room: " .. room.Name)
    local nodesFolder = room:WaitForChild("RunnerNodes", 5.0)
    if (nodesFolder == nil) then 
        Script.Functions.Minecart.debug("[HasAlreadyDestroyed] No node has been found." )
        return
    end
    local result = nodesFolder:GetAttribute("_mspaint_player_teleported") ~= nil
    Script.Functions.Minecart.debug("[HasAlreadyDestroyed] Destroyed: " .. tostring(result))
    return result
end
local MinecartFound = false
function Script.Functions.Minecart.Teleport(room: Model)
    if not Toggles.MinecartTeleport.Value then return end
    local roomNumber = tonumber(room.Name)
    if not (roomNumber >= 45 and roomNumber <= 49) then return end
    Script.Functions.Minecart.debug("[Teleport] Was called for room: " .. room.Name)
    if not HasAlreadyDestroyed(room) then
        local nodesList = PathfindGetNodes(room)
        if not nodesList then return end
        NodeDestroy(nodesList)
        room:SetAttribute("_mspaint_player_teleported", false)
    end
    local hasAlreadyTeleported = room:GetAttribute("_mspaint_player_teleported")
    Script.Functions.Minecart.debug("[Teleport] Player already teleported:" .. tostring(hasAlreadyTeleported))
    --Setup minecart teleport if room 45 is added.
    if roomNumber == 45 and not hasAlreadyTeleported then
        task.spawn(function()
            --Delete old notification
            if workspace:FindFirstChild("_internal_mspaint_minecart_teleport") then 
                workspace:FindFirstChild("_internal_mspaint_minecart_teleport"):Destroy() 
            end
            local progressPart = Instance.new("Part", workspace) do
                progressPart.Anchored = true
                progressPart.CanCollide = false
                progressPart.Name = "_internal_mspaint_minecart_teleport"
                progressPart.Transparency = 1
            end
            shared.Notify:Alert({
                Title = "Dương Api",
                Description = "Tính năng đã sẵn sàng, chờ người dùng lên xe mỏ...",
                Time = progressPart
            })
        end)
        Script.Functions.Minecart.debug("[Teleport] Minecart Teleport initialization room:" .. room.Name)
        local minecartRigs = {}
        task.spawn(function()
            while not MinecartFound and not shared.Library.Unloaded do
                shared.RunService.RenderStepped:Wait()
                for idx, stuff: Instance in pairs(shared.Camera:GetChildren()) do
                    if stuff.Name ~= "MinecartRig" then continue end
                    table.insert(minecartRigs, stuff)
                    Script.Functions.Minecart.debug("[Teleport] MinecartRig found, adding to table")
                    repeat 
                        task.wait()
                    until not stuff:IsDescendantOf(shared.Camera) 
                    Script.Functions.Minecart.debug("[Teleport] MinecartRig fake removed.")
                    table.remove(minecartRigs, idx)
                end
            end
        end)
        while #minecartRigs == 0 and not shared.Library.Unloaded do 
            task.wait(0.5)
            Script.Functions.Minecart.debug("[Teleport] Room to Teleport: " .. tostring(Script.LatestRoom.Value))
        end
        Script.Functions.Minecart.debug("[Teleport] MinecartRig Found! Initializing Teleport...")
        if workspace:FindFirstChild("_internal_mspaint_minecart_teleport") then workspace:FindFirstChild("_internal_mspaint_minecart_teleport"):Destroy() end
        shared.Notify:Alert({
            Title = "Dương Api",
            Description = "Bắt đầu chạy tính năng, hãy tận hưởng",
            Time = 10
        })
        task.wait(1.5)
        local startRoomNumber = math.min(49, Script.LatestRoom.Value)
        while startRoomNumber >= 45 and startRoomNumber <= 49 do
            if shared.Library.Unloaded then break end            
            Script.Functions.Minecart.debug("[Teleport] Teleporting to last node on room: " .. startRoomNumber)
            local GetRoom = workspace.CurrentRooms[startRoomNumber]
            local nodesList = PathfindGetNodes(GetRoom)
            local getLastNode = nodesList.real[#nodesList.real]
            repeat
                shared.RunService.RenderStepped:Wait()
                for _, minecart in pairs(minecartRigs) do
                    minecart.PrimaryPart.CFrame = getLastNode.CFrame
                end
            until GetRoom:WaitForChild("Door"):GetAttribute("Opened")
            GetRoom:SetAttribute("_mspaint_player_teleported", true)
            startRoomNumber += 1
            MinecartFound = true
            task.wait(1.2)
        end
        Script.Functions.Minecart.debug("[Teleport] Finished!")
    end
end
function Script.Functions.Minecart.DrawNodes(room: Model)
    local nodesList = PathfindGetNodes(room)
    if not nodesList then return end
    local espRealColor = if Toggles.MinecartPathVisualiser.Value then Script.MinecartPathNodeColor.Green else Script.MinecartPathNodeColor.Disabled
    for _, realNode in ipairs(nodesList.real) do
        changeNodeColor(realNode, espRealColor)
    end
     for idx, fakeNode in ipairs(nodesList.fake) do
         changeNodeColor(fakeNode, MinecartPathNodeColor.Red)
     end
end
function Script.Functions.Minecart.Pathfind(room: Model, forcePathfind: boolean)
    if not HasNodesToPathfind(room) then return end
    if not forcePathfind then
        local pathTimeout = tick() + 5
        repeat task.wait()
        until #Script.Functions.Minecart.pathfindQueue > 0 or tick() > pathTimeout
        pcall(table.remove, Script.Functions.Minecart.pathfindQueue, 1)
    end
    local nodesFolder = room:FindFirstChild("RunnerNodes")
    if (nodesFolder == nil) then return end
    local nodes = nodesFolder:GetChildren()
    local numOfNodes = #nodes
    if numOfNodes <= 0 then return end 
    if HasAlreadyPathfind(nodesFolder) then return end
    Script.Functions.Minecart.debug("[Pathfind] Initialized pathfind for room: " .. room.Name .. " - nodes: ", numOfNodes)
    local _shortW = 4
    local _longW = 24
    local doorModel = room:WaitForChild("Door", 5)
    local _startNode = nodes[1]
    local _lastNode = nil
    local _gpID = 1
    local stackNode = {}
    stackNode[_gpID] = tGroupTrackNew()
    nodes = sortNodes(nodes, true)
    local _last = 1
    for i=_last+1, numOfNodes, 1 do
        local nodeA: Part = nodes[_last]
        local nodeB: Part = _lastNode and nodes[i] or doorModel
        local distance = (nodeA:GetPivot().Position - nodeB:GetPivot().Position).Magnitude
        local isEndNode = distance <= _shortW
        local isNodeNear = (distance > _shortW and distance <= _longW)
        local _currNodeTask = "Track"
        if isNodeNear or isEndNode then
            if not _lastNode then
                _currNodeTask = "End"
                _lastNode = nodeA
            end
        else
            _currNodeTask = "Fake"
        end
        if  (_currNodeTask == "Fake" or _currNodeTask == "End") and _lastNode then
            _gpID += 1
            stackNode[_gpID] = tGroupTrackNew()
            if _currNodeTask == "End" then
                stackNode[_gpID].hasEnd = true
            end
        end
        table.insert(stackNode[_gpID].nodes, nodeA)
        Script.Functions.Minecart.debug(string.format("[%s] - [%s] Distance between: %s <--> %s ==> %.2f", _gpID, _currNodeTask, nodeA.Name, nodeB.Name, distance))
        _last = i
    end
    stackNode[_gpID].hasStart = true
    table.insert(stackNode[_gpID].nodes, _startNode)
    local hasMoreThanOneGroup = _gpID > 1
    local _closestNodes = {}
    local hasIncorrectPath = false
    if hasMoreThanOneGroup then
        Script.Functions.Minecart.debug()
        for _gpI, v: tGroupTrack in ipairs(stackNode) do
            _closestNodes[_gpI] = {}
            Script.Functions.Minecart.debug(string.format("[TrackGroup] Group %s has %s nodes. \t Start: %s | End: %s", _gpI, #v.nodes, tostring(v.hasStart), tostring(v.hasEnd)))
            if _gpI <= 1 then continue end
            Script.Functions.Minecart.debug(string.format("[TrackGroup] Group %s was selected to deep pathfinding", _gpI))
            v.nodes = sortNodes(v.nodes, false)
            local _gplast = 1
            local hasNodeJump = false
            for _gpS=_gplast+1, #v.nodes, 1 do
                local nodeA: Part = v.nodes[_gplast]
                local nodeB: Part = v.nodes[_gpS]
                local distance = (nodeA:GetPivot().Position - nodeB:GetPivot().Position).Magnitude
                hasNodeJump = (distance >= _longW)
                if not hasNodeJump then _gplast = _gpS continue end
                Script.Functions.Minecart.debug(string.format("[%s] Distance between %s <--> %s ==> %.2f", _gpI, nodeA.Name, nodeB.Name, distance))
                Script.Functions.Minecart.debug(string.format("[TrackGroup] Group %s with, %s will find his closest node now.", _gpI, nodeB.Name))
                local nodeSearchPath = nodeB
                local closestDistance = math.huge
                local _gpFlast = #v.nodes
                for i=_gpFlast-1, 1, -1 do
                    local fnode = v.nodes[_gpFlast]
                    local Sdistance = (nodeSearchPath:GetPivot().Position - fnode:GetPivot().Position).Magnitude
                    _gpFlast = i
                    if Sdistance == 0.00 then continue end --node is self
                    Script.Functions.Minecart.debug(string.format("  [%s] DeepPath ==> Distance between %s <--> %s ==> %.2f", _gpI, nodeSearchPath.Name, fnode.Name, Sdistance))
                    if Sdistance <= closestDistance then
                        closestDistance = Sdistance
                        table.insert(_closestNodes[_gpI], fnode)
                        table.remove(v.nodes, _gpFlast+1)
                        continue
                    end
                    break
                end
                local _FoundAmount = #_closestNodes[_gpI]
                if _FoundAmount > 1 then 
                    Script.Functions.Minecart.debug(string.format("[TrackGroup] Group %s with, closest node is: %s ", _gpI, _closestNodes[_gpI][_FoundAmount].Name))
                else
                    warn(string.format("[TrackGroup] Group %s ERROR: Unable to find closest node, path is likely broken.", _gpI))
                    hasIncorrectPath = true
                end
                break
            end
            if not hasNodeJump then
                Script.Functions.Minecart.debug(string.format("[TrackGroup] Group %s has a correct path! ", _gpI))
            end
        end
        for _gpI, v: tGroupTrack in ipairs(stackNode) do
            Script.Functions.Minecart.debug(string.format("[TrackGroup -- VERIFY] Group %s has %s nodes. \t Start: %s | End: %s", _gpI, #v.nodes, tostring(v.hasStart), tostring(v.hasEnd)))
        end
    end
    if hasIncorrectPath then return end
    local realNodes = {}
    local fakeNodes = {}
    for _gpFI, v: tGroupTrack in ipairs(stackNode) do
        local finalWrongNode = false
        if _gpFI == 1 and hasMoreThanOneGroup then
            finalWrongNode = true 
        end
        for _, vfinal in ipairs(v.nodes) do
            if finalWrongNode then
                table.insert(fakeNodes, vfinal)
                continue
            end
            table.insert(realNodes, vfinal)
        end
        for _, nfinal in ipairs(_closestNodes[_gpFI]) do
            table.insert(fakeNodes, nfinal)
        end
    end
    local nodesList: tSortedNodes = {
        real = sortNodes(realNodes, false),
        fake = sortNodes(fakeNodes, false)
    }
    nodesFolder:SetAttribute("_mspaint_nodes_pathfind", true)
    PathfindSetNodes(nodesList.real, "_mspaint_real_node")
    PathfindSetNodes(nodesList.fake, "_mspaint_fake_node")
    Script.Functions.Minecart.DrawNodes(room)
    Script.Functions.Minecart.Teleport(room)
end
end)() end,
    [33] = function()local wax,script,require=ImportGlobals(33)local ImportGlobals return (function(...)
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
function Script.Functions.GetPadlockCode(paper: Tool)
    if paper:FindFirstChild("UI") then
        local code = {}
        for _, image: ImageLabel in pairs(paper.UI:GetChildren()) do
            if image:IsA("ImageLabel") and tonumber(image.Name) then
                code[image.ImageRectOffset.X .. image.ImageRectOffset.Y] = {tonumber(image.Name), "_"}
            end
        end
        for _, image: ImageLabel in pairs(shared.PlayerGui.PermUI.Hints:GetChildren()) do
            if image.Name == "Icon" then
                if code[image.ImageRectOffset.X .. image.ImageRectOffset.Y] then
                    code[image.ImageRectOffset.X .. image.ImageRectOffset.Y][2] = image.TextLabel.Text
                end
            end
        end
        local normalizedCode = {}
        for _, num in pairs(code) do
            normalizedCode[num[1]] = num[2]
        end
        return table.concat(normalizedCode)
    end
    return "_____"
end
end)() end,
    [34] = function()local wax,script,require=ImportGlobals(34)local ImportGlobals return (function(...)
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
function Script.Functions.DistanceFromCharacter(position: Instance | Vector3, getPositionFromCamera: boolean | nil)
    if not position then return 9e9 end
    if typeof(position) == "Instance" then
        position = position:GetPivot().Position
    end
    if getPositionFromCamera and (shared.Camera or workspace.CurrentCamera) then
        local cameraPosition = if shared.Camera then shared.Camera.CFrame.Position else workspace.CurrentCamera.CFrame.Position
        return (cameraPosition - position).Magnitude
    end
    if shared.RootPart then
        return (shared.RootPart.Position - position).Magnitude
    elseif shared.Camera then
        return (shared.Camera.CFrame.Position - position).Magnitude
    end
    return 9e9
end
function Script.Functions.IsInViewOfPlayer(instance: Instance, range: number | nil, exclude: table | nil)
    if not instance then return false end
    if not Script.Collision then return false end
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    local filter = exclude or {}
    table.insert(filter, shared.Character)
    raycastParams.FilterDescendantsInstances = filter
    local direction = (instance:GetPivot().Position - Script.Collision.Position).unit * (range or 9e9)
    local raycast = workspace:Raycast(Script.Collision.Position, direction, raycastParams)
    if raycast and raycast.Instance then
        if raycast.Instance:IsDescendantOf(instance) or raycast.Instance == instance then
            return true
        end
        return false
    end
    return false
end
end)() end,
    [36] = function()local wax,script,require=ImportGlobals(36)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
Script.PresetHelper = wax.shared.FileHelper.new("mspaint/doors/presets")
Script.ElevatorPresetData = {}
Script.ElevatorPresets = {}
function Script.Functions.CreatePreset(name: string, data: table)
    local presetData = Script.Functions.EnforceTypes(data, {
        Floor = "Hotel",
        MaxPlayers = 1,
        Modifiers = nil,
        FriendsOnly = true
    })
    Script.PresetHelper.CreateFile(name .. ".json", shared.HttpService:JSONEncode(presetData))
end
function Script.Functions.LoadPresets()
    table.clear(Script.ElevatorPresets)
    table.clear(Script.ElevatorPresetData)
    for _, file in pairs(Script.PresetHelper.GetFilesClean()) do
        local success, ret = pcall(function()
            local data = Script.PresetHelper.ReadFile(file .. ".json")
            return shared.HttpService:JSONDecode(data)
        end)
        if success then
            Script.ElevatorPresetData[file] = Script.Functions.EnforceTypes(ret, {
                Floor = "Hotel",
                MaxPlayers = 1,
                Modifiers = nil,
                FriendsOnly = true
            })
            table.insert(Script.ElevatorPresets, file)
        else
            shared.Notify:Alert({
                Description = "Failed to load preset: " .. file
            })
        end
    end
    Options.Elevator_PresetList:SetValues(Script.ElevatorPresets)
    Options.Elevator_PresetList:SetValue(nil)
end
function Script.Functions.LoadPreset(name: string)
    local success, ret = pcall(function()
        local data = Script.PresetHelper.ReadFile(name .. ".json")
        return shared.HttpService:JSONDecode(data)
    end)
    if not success then
        shared.Notify:Alert({
            Description = "Failed to load preset: " .. name .. ".json"
        })
        return
    end
    local presetData = Script.Functions.EnforceTypes(ret, {
        Floor = "Hotel",
        MaxPlayers = 1,
        Modifiers = nil,
        FriendsOnly = true
    })
    local data = {
        ["FriendsOnly"] = presetData.FriendsOnly,
        ["Destination"] = presetData.Floor,
        ["Mods"] = presetData.Modifiers or {},
        ["MaxPlayers"] = tostring(presetData.MaxPlayers)
    }
    Script.CreateElevator:FireServer(data)
    shared.Notify:Alert({
        Description = "Loaded elevator preset: " .. name
    })
end
end)() end,
    [38] = function()local wax,script,require=ImportGlobals(38)local ImportGlobals return (function(...)
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
function Script.Functions.ChildCheck(child)
    if not child:IsA("Model") then return end
    if Toggles.BatteryESP.Value and child.Name == "battery" then
        Script.Functions.BatteryESP(child)
    elseif Toggles.LockerESP.Value and child.Name == "hidelocker" then
        Script.Functions.LockerESP(child)
    elseif Toggles.TableESP.Value and child.Name == "hidetable" then
        Script.Functions.TableESP(child)
    end
end
end)() end,
    [39] = function()local wax,script,require=ImportGlobals(39)local ImportGlobals return (function(...)
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
function Script.Functions.Chat(message: string)
    local chatEvents = shared.ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
    local sayMessage = chatEvents and chatEvents:FindFirstChild("SayMessageRequest")
    if sayMessage then
        sayMessage:FireServer(message, "All")
    end
end
end)() end,
    [40] = function()local wax,script,require=ImportGlobals(40)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
function Script.Functions.SetupCharacterConnection(newCharacter)
    shared.Character = newCharacter
    shared.Humanoid = shared.Character:WaitForChild("Humanoid")
    shared.RootPart = shared.Character:WaitForChild("HumanoidRootPart")
end
function Script.Functions.SetupLightingConnection()
    shared.Connect:GiveSignal(shared.Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
        if shared.Lighting.Ambient ~= Script.CurrentAmbient and shared.Lighting.Ambient ~= Color3.new(1, 1, 1) then
            Script.CurrentAmbient = shared.Lighting.Ambient
        end
        if Toggles.Fullbright.Value then
            shared.Lighting.Ambient = Color3.new(1, 1, 1)
        end
    end))
    shared.Connect:GiveSignal(shared.Lighting.ChildAdded:Connect(function(child)
        if Toggles.NoBlur.Value and child:IsA("Blur") then
            child.Enabled = false
        end
    end))
end
function Script.Functions.SetupRoomConnection(room)
    if Script.LoadedRooms[room] then return end
    Script.LoadedRooms[room] = true
    if Toggles.DoorESP.Value then
        Script.Functions.DoorESP(room)
    end
    for _, child in pairs(room:GetDescendants()) do
        task.spawn(Script.Functions.ChildCheck, child)
    end
    shared.Connections[room] = room.DescendantAdded:Connect(function(child)
        task.delay(0.1, Script.Functions.ChildCheck, child)
    end)
end
function Script.Functions.SetupUIConnection(GUI)
    Script.MainUI = GUI or shared.PlayerGui:WaitForChild("MainGui")
    if Toggles.NoFlashlightShadow.Value then
        local slender = Script.MainUI:WaitForChild("slender")
        if slender then
            slender.ImageTransparency = 1
            for _, bar in pairs(slender:GetChildren()) do
                bar.Visible = false
            end
        end
    end
end
end)() end,
    [41] = function()local wax,script,require=ImportGlobals(41)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
local ESPLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/laitung1122/Duonga2/refs/heads/main/esp.lua"))()
shared.ESPLibrary = ESPLibrary
type ESP = {
    Color: Color3,
    IsInvisible: boolean,
    Object: Instance,
    Offset: Vector3,
    MaxDistance: number,
    Text: string,
    TextParent: Instance,
    Type: string,
    OnDestroy: () -> (),
}
function Script.Functions.ESP(args: ESP)
    if not args.Object then return Script.Functions.Warn("ESP Object is nil") end
    local ESPManager = {
        Object = args.Object,
        Text = args.Text or "No Text",
        Color = args.Color or Color3.new(),
        MaxDistance = args.MaxDistance or 5000,
        Offset = args.Offset or Vector3.zero,
        IsInvisible = args.IsInvisible or false,
        Type = args.Type or "None",
        OnDestroy = args.OnDestroy or nil,
        Humanoid = nil
    }
    if ESPManager.IsInvisible and ESPManager.Object.PrimaryPart then
        if ESPManager.Object.PrimaryPart.Transparency == 1 then
            ESPManager.Object.PrimaryPart.Transparency = 0.99
        end
        local humanoid = ESPManager.Object:FindFirstChildOfClass("Humanoid")
        if not humanoid then humanoid = Instance.new("Humanoid", ESPManager.Object) end
        ESPManager.Humanoid = humanoid
    end
    local ESPInstance = ESPLibrary.ESP.Highlight({
        Name = ESPManager.Text,
        Model = ESPManager.Object,
        MaxDistance = ESPManager.MaxDistance,
        StudsOffset = ESPManager.Offset,
        FillColor = ESPManager.Color,
        OutlineColor = ESPManager.Color,
        TextColor = ESPManager.Color,
        TextSize = Options.ESPTextSize.Value or 16,
        FillTransparency = Options.ESPFillTransparency.Value,
        OutlineTransparency = Options.ESPOutlineTransparency.Value,
        Tracer = {
            Enabled = true,
            From = Options.ESPTracerStart.Value,
            Color = ESPManager.Color
        },
        Arrow = {
            Enabled = true,
            CenterOffset = Options.ESPArrowCenterOffset.Value,
            Color = ESPManager.Color
        },
        OnDestroy = ESPManager.OnDestroy or function()
            if ESPManager.Object.PrimaryPart and ESPManager.IsInvisible then ESPManager.Object.PrimaryPart.Transparency = 1 end
            if ESPManager.Humanoid then ESPManager.Humanoid:Destroy() end
        end
    })
    table.insert(Script.ESPTable[args.Type], ESPInstance)
    return ESPInstance
end
function Script.Functions.DoorESP(room)
    local door = room:WaitForChild("door", 5)
    if door then
        local clickDetector = door:FindFirstChild("ClickDetector")
        if not clickDetector then return end
        local roomNumber = if tonumber(room.Name) then room.Name else tostring(workspace.roomnumber.Value + 1)
        local doorEsp = Script.Functions.ESP({
            Type = "Door",
            Object = door,
            Text = string.format("Door %s", roomNumber),
            Color = Options.DoorEspColor.Value,
            OnDestroy = function()
                if Script.FeatureConnections.Door[door] then Script.FeatureConnections.Door[door]:Disconnect() end
            end
        })
        Script.FeatureConnections.Door[door] = clickDetector.AncestryChanged:Connect(function(_, parent)
            if parent then return end
            if doorEsp then doorEsp.Destroy() end
            if Script.FeatureConnections.Door[door] then Script.FeatureConnections.Door[door]:Disconnect() end
        end)
    end
end
function Script.Functions.EntityESP(entity, entityName)
    local isInvisible = entity:IsA("BasePart") and entity.Transparency == 1
    local entityModel = if isInvisible then Instance.new("Model") else entity
    if isInvisible then
        local entityClone = entity:Clone()
        entityClone.Parent = entityModel
        entityModel.Parent = shared.Workspace
        entityModel.PrimaryPart = entityClone
        entityClone:ClearAllChildren()
        Instance.new("SpecialMesh", entityClone)
        shared.Connections[entity] = shared.RunService.Heartbeat:Connect(function()
            if entity:IsDescendantOf(workspace) then
                entityModel:PivotTo(entity:GetPivot())
            else
                entityModel:Destroy()
                shared.Connect:DisconnectSignal(shared.Connections[entity])
            end
        end)
    end
    Script.Functions.ESP({
        Type = "Entity",
        Object = entityModel,
        Text = entityName,
        Color = Options.EntityEspColor.Value,
        IsInvisible = isInvisible,
    })
end
function Script.Functions.BatteryESP(battery)
    Script.Functions.ESP({
        Type = "Battery",
        Object = battery,
        Text = "Battery",
        Color = Options.BatteryEspColor.Value,
        MaxDistance = 300
    })
end
function Script.Functions.LockerESP(hideLocker)
    local jack = hideLocker:FindFirstChild("jack")
    local extra = if jack then " [Shell]" else ""
    local lockerEsp = Script.Functions.ESP({
        Type = "Locker",
        Object = hideLocker,
        Text = string.format("Locker%s", extra),
        Color = Options.LockerEspColor.Value,
        MaxDistance = 200,
        OnDestroy = function()
            if Script.FeatureConnections.Shell[jack] then Script.FeatureConnections.Shell[jack]:Disconnect() end
        end
    })
    if jack then
        Script.FeatureConnections.Shell[jack] = jack.AncestryChanged:Connect(function(_, parent)
            if parent then return end
            if lockerEsp then lockerEsp.Destroy() end
            if Script.FeatureConnections.Shell[jack] then Script.FeatureConnections.Shell[jack]:Disconnect() end
        end)
    end
end
function Script.Functions.TableESP(hideTable)
    Script.Functions.ESP({
        Type = "Table",
        Object = hideTable:FindFirstChild("spot"),
        Text = "Table",
        Color = Options.TableEspColor.Value,
        IsInvisible = true,
        MaxDistance = 250
    })
end
end)() end,
    [43] = function()local wax,script,require=ImportGlobals(43)local ImportGlobals return (function(...)   
local Toggles = shared.Toggles
local Options = shared.Options
local Script = shared.Script
function Script.Functions.SetupCharacterConnection(newCharacter)
    shared.Character = newCharacter
    shared.Humanoid = shared.Character:WaitForChild("Humanoid")
    shared.RootPart = shared.Character:WaitForChild("HumanoidRootPart")
end
function Script.Functions.SetupBloxstrapRPCConnection()
    shared.Connect:GiveSignal(shared.Players.PlayerAdded:Connect(function(player)
        Script.Functions.UpdateBloxstrapRPC()
    end))
    shared.Connect:GiveSignal(shared.Players.PlayerRemoving:Connect(function(player)
        Script.Functions.UpdateBloxstrapRPC()
    end))
end
end)() end,
    [45] = function()local wax,script,require=ImportGlobals(45)local ImportGlobals return (function(...)local BloxstrapRPC = {}
type RichPresence = {
    details:     string?,
    state:       string?,
    timeStart:   number?,
    timeEnd:     number?,
    smallImage:  RichPresenceImage?,
    largeImage:  RichPresenceImage?
}
type RichPresenceImage = {
    assetId:    number?,
    hoverText:  string?,
    clear:      boolean?,
    reset:      boolean?
}
function BloxstrapRPC.SendMessage(command: string, data: any)
    local json = shared.HttpService:JSONEncode({
        command = command, 
        data = data
    })
    print("[BloxstrapRPC] " .. json)
end
function BloxstrapRPC.SetRichPresence(data: RichPresence)
    if data.timeStart ~= nil then
        data.timeStart = math.round(data.timeStart)
    end
    if data.timeEnd ~= nil then
        data.timeEnd = math.round(data.timeEnd)
    end
    BloxstrapRPC.SendMessage("SetRichPresence", data)
end 
return BloxstrapRPC
end)() end,
    [46] = function()local wax,script,require=ImportGlobals(46)local ImportGlobals return (function(...)local Connect = {}
shared.Connections = {}
function Connect:GiveSignal(signal: RBXScriptConnection | RBXScriptSignal)
    table.insert(shared.Connections, signal)
end
function Connect:DisconnectSignal(signal: RBXScriptConnection | RBXScriptSignal)
    if not signal then return end
    if signal.Connected then
        signal:Disconnect()
    end
end
return Connect
end)() end,
    [47] = function()local wax,script,require=ImportGlobals(47)local ImportGlobals return (function(...)local ExecutorSupport = {}
local ExecutorSupportInfo = {}
local executorName = string.split(identifyexecutor() or "None", " ")[1]
local brokenFeatures = {
    ["Arceus"] = { "require" },
    ["Codex"] = { "require" },
    ["VegaX"] = { "require" },
}
function test(name: string, func: () -> (), shouldCallback: boolean)
    if typeof(brokenFeatures[executorName]) == "table" and table.find(brokenFeatures[executorName], name) then return false end -- garbage executor 🤯
    local success, errorMessage = false, nil
    if shouldCallback ~= false then
        success, errorMessage = pcall(func)
    else
        success = typeof(func) == "function"
    end
    ExecutorSupportInfo[name] = string.format("%s [%s]%s", (if success then "✅" else "❌"), name, (if errorMessage then (": " .. tostring(errorMessage)) else ""))
    ExecutorSupport[name] = success
    return success
end
test("readfile", readfile, false)
test("listfiles", listfiles, false)
test("writefile", writefile, false)
test("makefolder", makefolder, false)
test("appendfile", appendfile, false)
test("isfile", isfile, false)
test("isfolder", isfolder, false)
test("delfile", delfile, false)
test("delfolder", delfolder, false)
test("loadfile", loadfile, false)
test("getrenv", getrenv, false)
test("queue_on_teleport", queue_on_teleport, false)
test("getcallingscript", getcallingscript, false)
test("require", function()
    --wax.require(shared.Players.LocalPlayer:WaitForChild("PlayerScripts"):FindFirstChildWhichIsA("ModuleScript", true))
    wax.require(shared.Players.LocalPlayer:WaitForChild("PlayerScripts", math.huge):WaitForChild("PlayerModule", 5))
end)
test("hookmetamethod", function()
    local object = setmetatable({}, { __index = newcclosure(function() return false end), __metatable = "Locked!" })
    local ref = hookmetamethod(object, "__index", function() return true end)
    assert(object.test == true, "Failed to hook a metamethod and change the return value")
    assert(ref() == false, "Did not return the original function")
end)
test("getnamecallmethod", function()
    pcall(function()
        game:NAMECALL_METHODS_ARE_IMPORTANT()
    end)
    assert(getnamecallmethod() == "NAMECALL_METHODS_ARE_IMPORTANT", "getnamecallmethod did not return the real namecall method")
end)
test("hookfunction", function()
    local function test()
		return true
	end
	local ref = hookfunction(test, function()
		return false
	end)
	assert(test() == false, "Function should return false")
	assert(ref() == true, "Original function should return true")
	assert(test ~= ref, "Original function should not be same as the reference")
end)
test("firesignal", function()
    local event = Instance.new("BindableEvent")
    local fired = false
    event.Event:Once(function(value) fired = value end)
    firesignal(event.Event, true)
    task.wait(0.1)
    event:Destroy()
    assert(fired, "Failed to fire a BindableEvent")
end)
local canFirePrompt = test("fireproximityprompt", function()
    local prompt = Instance.new("ProximityPrompt", Instance.new("Part", shared.Workspace))
    local triggered = false
    prompt.Triggered:Once(function() triggered = true end)
    fireproximityprompt(prompt)
    task.wait(0.1)
    prompt.Parent:Destroy()
    assert(triggered, "Failed to fire proximity prompt")
end)
--// Fixes \\--
if not canFirePrompt then
    local function fireProximityPrompt(prompt: ProximityPrompt, lookToPrompt, doNotDoInstant)
        if not prompt:IsA("ProximityPrompt") then
            return error("ProximityPrompt expected, got " .. typeof(prompt))
        end
        local connection
        local promptPosition = prompt.Parent:GetPivot().Position
        local originalEnabled = prompt.Enabled
        local originalHold = prompt.HoldDuration
        local originalLineOfSight = prompt.RequiresLineOfSight
        local originalCamCFrame = workspace.CurrentCamera.CFrame
        prompt.Enabled = true
        prompt.RequiresLineOfSight = false
        if doNotDoInstant ~= true then
            prompt.HoldDuration = 0
        end
        if lookToPrompt == true then
            workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, promptPosition)
            connection = workspace.CurrentCamera:GetPropertyChangedSignal("CFrame"):Connect(function()
                workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, promptPosition)
            end)
            task.wait()
        end
        prompt:InputHoldEnd()
        prompt:InputHoldBegin()
        task.wait(prompt.HoldDuration + 0.05)
        prompt:InputHoldEnd()
        if connection then connection:Disconnect() end
        prompt.Enabled = originalEnabled
        prompt.HoldDuration = originalHold
        prompt.RequiresLineOfSight = originalLineOfSight
        if lookToPrompt == true then workspace.CurrentCamera.CFrame = originalCamCFrame end
    end
    shared.fireproximityprompt = function(...)
        return fireProximityPrompt(...)
    end
    shared.forcefireproximityprompt = function(prompt)
        return fireProximityPrompt(prompt, true)
    end
else
    shared.fireproximityprompt = fireproximityprompt
    shared.forcefireproximityprompt = fireproximityprompt
end
if not isnetworkowner then
    function isnetowner(part: BasePart)
        if not part:IsA("BasePart") then
            return error("BasePart expected, got " .. typeof(part))
        end
        return part.ReceiveAge == 0
    end
    shared.isnetworkowner = isnetowner
else
    shared.isnetworkowner = isnetworkowner
end
shared.firetouch = firetouchinterest or firetouchtransmitter
--// Load \\--
ExecutorSupport["_ExecutorName"] = executorName
ExecutorSupport["_SupportsFileSystem"] = (ExecutorSupport["isfile"] and ExecutorSupport["delfile"] and ExecutorSupport["listfiles"] and ExecutorSupport["writefile"] and ExecutorSupport["makefolder"] and ExecutorSupport["isfolder"])
for name, result in pairs(ExecutorSupport) do
    if ExecutorSupportInfo[name] then 
        print(ExecutorSupportInfo[name]) 
    elseif name:gsub("_", "") ~= name then
        print("🛠️ [" .. tostring(name) .. "]", tostring(result))
    else
        print("❓ [" .. tostring(name) .. "]", tostring(result))
    end
end
return ExecutorSupport
end)() end,
    [48] = function()local wax,script,require=ImportGlobals(48)local ImportGlobals return (function(...)local FileHelper = {}
function FileHelper.new(basepath: string)
    local self = setmetatable({}, {
        __index = function(self, key)
            local accessed = rawget(self, key)
            if typeof(accessed) == "function" then
                return function(...)
                    if not shared.ExecutorSupport["_SupportsFileSystem"] then return end
                    return accessed(self, ...)
                end
            end
            return accessed
        end
    })
    self.BasePath = basepath
    self.BuildPresetStructure = function()
        if not isfolder(self.BasePath) then
            makefolder(self.BasePath)
        end
    end
    self.CreateFile = function(name: string, data: string)
        self.BuildPresetStructure()
        writefile(self.BasePath .. "/" .. name, data)
    end
    self.AppendFile = function(name: string, data: string)
        self.BuildPresetStructure()
        appendfile(self.BasePath .. "/" .. name, data)
    end
    self.GetFiles = function()
        return listfiles(self.BasePath)
    end
    self.ReadFile = function(name: string)
        return readfile(self.BasePath .. "/" .. name)
    end
    self.IsFile = function(name: string)
        return isfile(self.BasePath .. "/" .. name)
    end
    self.DeleteFile = function(name: string)
        delfile(self.BasePath .. "/" .. name)
    end
    self.GetFilesClean = function()
        local files = {}
        for _, file in pairs(listfiles(self.BasePath)) do
            local name = FileHelper.GetFileNameFromPath(file)
            if name then
                table.insert(files, name)
            end
        end
        return files
    end
    self.GetFileNameFromPath = function(path: string, extention: string | nil)
        return FileHelper.GetFileNameFromPath(path, extention)
    end
    return self
end
function FileHelper.GetFileNameFromPath(path: string, extention: string | nil)
    local fileExtension = extention or ".json"
    if path:sub(-#fileExtension) == fileExtension then
        path = path:gsub("\\", "/")
        local pos = path:find("/[^/]*$")
        if pos then
            return path:sub(pos + 1, -#fileExtension - 1)
        end
    end
    return nil
end
return FileHelper
end)() end,
    [50] = function()local wax,script,require=ImportGlobals(50)local ImportGlobals return (function(...)-- Addons
if getgenv().mspaint_disable_addons or getgenv().mspaint_addons_activated then 
    return {}
end
task.spawn(function()
    if not wax.shared.ExecutorSupport["_SupportsFileSystem"] then
        warn("[DuongApi] Your executor doesn't support the FileSystem API. Addons will not work.")
        return
    end
    getgenv().mspaint_addons_activated = true
    if not isfolder("DuongApi/addons") then
        print("[DuongApi] Addons folder doesn't exist. Creating...")
        makefolder("DuongApi/addons")
        return
    end
    repeat task.wait() until getgenv().mspaint_loaded == true
    print("[DuongApi] Loading addons...")
    local function AddAddonElement(LinoriaElement, AddonName, Element)
        if not LinoriaElement then
            warn("[DuongApi] Element '" .. tostring(Element.Name) .. " (" .. tostring(Element.Type) .. ")' didn't load: Invalid Linoria element.")
            return
        end
        if typeof(Element) ~= "table" then
            warn("[DuongApi] Element '" .. tostring(Element.Name) .. " (" .. tostring(Element.Type) .. ")' didn't load: Invalid data.")
            return
        end 
        if typeof(Element.Type) ~= "string" then 
            warn("[DuongApi] Element '" .. tostring(Element.Name) .. " (" .. tostring(Element.Type) .. ")' didn't load: Invalid name.")
            return 
        end
        if typeof(AddonName) ~= "string" then 
            warn("[DuongApi] Element '" .. tostring(Element.Name) .. " (" .. tostring(Element.Type) .. ")' didn't load: Invalid addon name.")
            return 
        end
        if Element.Type:sub(1, 3) == "Add" then Element.Type = Element.Type:sub(4) end
        -- Elements with no Arguments
        if Element.Type == "Divider" then
            return LinoriaElement:AddDivider()
        end
        if Element.Type == "DependencyBox" then
            return LinoriaElement:AddDependencyBox()
        end
        if typeof(Element.Name) ~= "string" then 
            warn("[DuongApi] Element '" .. tostring(Element.Name) .. " (" .. tostring(Element.Type) .. ")' didn't load: Invalid name.")
            return 
        end
        -- Elements with Arguments
        if typeof(Element.Arguments) == "table" then
            if Element.Type == "Label" then
                return LinoriaElement:AddLabel(table.unpack(Element.Arguments))
            end
            if Element.Type == "Toggle" then
                return LinoriaElement:AddToggle(AddonName .. "_" .. Element.Name, Element.Arguments)
            end
            if Element.Type == "Button" then
                return LinoriaElement:AddButton(Element.Arguments)
            end
            if Element.Type == "Slider" then
                return LinoriaElement:AddSlider(AddonName .. "_" .. Element.Name, Element.Arguments)
            end
            if Element.Type == "Input" then
                return LinoriaElement:AddInput(AddonName .. "_" .. Element.Name, Element.Arguments)
            end
            if Element.Type == "Dropdown" then
                return LinoriaElement:AddInput(AddonName .. "_" .. Element.Name, Element.Arguments)
            end
            if Element.Type == "ColorPicker" then
                return LinoriaElement:AddColorPicker(AddonName .. "_" .. Element.Name, Element.Arguments)        
            end
            if Element.Type == "KeyPicker" then
                return LinoriaElement:AddKeyPicker(AddonName .. "_" .. Element.Name, Element.Arguments)
            end
        end
        warn("[DuongApi] Element '" .. tostring(Element.Name) .. " (" .. tostring(Element.Type) .. ")' didn't load: Invalid element type.")
        return
    end
    local AddonTab, LastGroupbox = nil, "Right"
    local function createAddonTab(hasAddons: boolean)
        if not AddonTab then
            AddonTab = shared.Window:AddTab("Mod [BETA]")
        end
        AddonTab:UpdateWarningBox({
            Visible = true,
            Title = "WARNING",
            Text =  (if not hasAddons then "Thư mục mod của bạn trống!" else "Cái này để thêm tính năng và sẽ rất rủi ro nếu sai sai bản mod")
        })
    end
    local containAddonsLoaded = false
    createAddonTab(false)
    for _, file in pairs(listfiles("DuongApi/addons")) do
        print("[DuongApi] Loading addon '" .. string.gsub(file, "DuongApi/addons/", "") .. "'...")
        if file:sub(#file - 3) ~= ".lua" and file:sub(#file - 4) ~= ".luau" and file:sub(#file - 7) ~= ".lua.txt" then continue end
        local success, errorMessage = pcall(function()
            local fileContent = readfile(file)
            local addon = loadstring(fileContent)()
            if typeof(addon.Name) ~= "string" or typeof(addon.Elements) ~= "table" then
                warn("Addon '" .. string.gsub(file, "DuongApi/addons/", "") .. "' didn't load: Invalid Name/Elements.")
                return 
            end
            if typeof(addon.Game) == "string" then
                if string.lower(addon.Game) ~= string.lower(shared.ScriptLoader) and addon.Game ~= "*" then
                    warn("Addon '" .. string.gsub(file, "DuongApi/addons/", "") .. "' didn't load: Wrong game.")
                    return
                end
            elseif typeof(addon.Game) == "table" then
                for i, addonGame in pairs(addon.Game) do
                    addon.Game[i] = string.lower(addonGame)
                end
                if not table.find(addon.Game, string.lower(shared.ScriptLoader)) then
                    warn("Addon '" .. string.gsub(file, "DuongApi/addons/", "") .. "' didn't load: Wrong game.")
                    return
                end
            else
                warn("Addon '" .. string.gsub(file, "DuongApi/addons", "") .. "' didn't load: Invalid GameId.")
                return
            end
            addon.Name = addon.Name:gsub("%s+", "")
            if typeof(addon.Title) ~= "string" then
                addon.Title = addon.Name
            end
            if not AddonTab then createAddonTab(true) end
            local AddonGroupbox = if LastGroupbox == "Right" then AddonTab:AddLeftGroupbox(addon.Title) else AddonTab:AddRightGroupbox(addon.Title)
            LastGroupbox = if LastGroupbox == "Right" then "Left" else "Right"
            if typeof(addon.Description) == "string" then
                AddonGroupbox:AddLabel(addon.Description, true)
            end
            local function loadElements(linoriaMainElement, elements)
                if not elements or typeof(elements) ~= "table" then return end
                for _, element in pairs(elements) do                      
                    local linoriaElement = AddAddonElement(linoriaMainElement, addon.Name, element)
                    loadElements(linoriaElement, element.Elements)
                end
            end
            loadElements(AddonGroupbox, addon.Elements)
        end)
        if not success then
            warn("[DuongApi] Failed to load addon '" .. string.gsub(file, "DuongApi/mod/", "") .. "':", errorMessage)
        else
            containAddonsLoaded = true
        end
    end
    createAddonTab(containAddonsLoaded)
end)
return {}
end)() end,
    [51] = function()local wax,script,require=ImportGlobals(51)local ImportGlobals return (function(...)local UICreator = {}
local repo = "https://raw.githubusercontent.com/laitung1122/Score.M4/refs/heads/main/"
shared.Library = loadstring(game:HttpGet(repo .. "lib.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "theme.lua"))()
shared.SaveManager = loadstring(game:HttpGet(repo .. "save.lua"))()
shared.Toggles = getgenv().Linoria.Toggles
shared.Options = getgenv().Linoria.Options
getgenv()._internal_unload_mspaint = function()
    getgenv().mspaint_loading = false
    getgenv().mspaint_loaded = false
    task.spawn(shared.Library.Unload)
end
function UICreator:CreateWindow()
    local Window = shared.Library:CreateWindow({
        Title = "Dương Api V2 (Chính thức) | " .. shared.ScriptName,
        Center = true,
        AutoShow = true,
        Resizable = true,
        NotifySide = "Right",
        ShowCustomCursor = true,
        TabPadding = 2,
        MenuFadeTime = 0
    })
    shared.NotifyStyle = "Linoria"
    shared.NotifyVolume = 2
    shared.Notify = require("Notify")
    shared.CheckToggle = function(toggleName: string, value: boolean)
        return shared.Toggles[toggleName] and shared.Toggles[toggleName].Value == value
    end
    shared.CheckOption = function(optionName: string, value: any)
        return shared.Options[optionName] and (typeof(shared.Options[optionName].Value) == "table" and shared.Options[optionName].Value[value] or shared.Options[optionName].Value == value)
    end
    shared.Library:OnUnload(function()
        print("Dừng tải...")
        shared.Fly:Stop()
        for _, connection in pairs(shared.Connections) do
            connection:Disconnect()
        end
        getgenv().mspaint_loading = false
        getgenv().mspaint_loaded = false
        shared.Library.Unloaded = true
        print("Đã tải!")
    end)
    return Window
end
Library:SetWatermarkVisibility(true)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 120;
local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;
    Library:SetWatermark(('Dương Api | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ));
end);
function UICreator:CreateSettingsTab()
    local SettingsTab = shared.Window:AddTab("Cài đặt UI")
    SettingsTab:UpdateWarningBox({
        Visible = true,
        Title = "Nếu thấy bất kì lỗi gì hãy ib tới admin",
        Text = "FB: Dương Ausus"
    })
    local MenuGroup = SettingsTab:AddLeftGroupbox("Menu")
    local CreditsGroup = SettingsTab:AddRightGroupbox("Credits")
    MenuGroup:AddToggle("ExecuteOnTeleport", { Default = true, Text = "Tự động chạy script(pc)" })
    MenuGroup:AddToggle("KeybindMenuOpen", { Default = false, Text = "Hiển thị phím tiện ích", Callback = function(value) shared.Library.KeybindFrame.Visible = value end})
    MenuGroup:AddToggle("ShowCustomCursor", {Text = "Custom Cursor", Default = true, Callback = function(Value) shared.Library.ShowCustomCursor = Value end})
    MenuGroup:AddDivider()
    MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })
    MenuGroup:AddButton("Gia nhập discord", function()
        local Inviter = loadstring(game:HttpGet("https://raw.githubusercontent.com/RegularVynixu/Utilities/main/Discord%20Inviter/Source.lua"))()
        Inviter.Join("https://discord.com/invite/cMQSc4zF")
        Inviter.Prompt({
            name = "Dương Api",
            invite = "https://discord.com/invite/cMQSc4zF",
        })
    end):AddButton("Sao chép", function()
        if setclipboard then
            setclipboard("https://discord.com/invite/cMQSc4zF")
            shared.Library:Notify("Đã sap chép vào bộ nhớ tạm!")
        else
            shared.Library:Notify("Discord link: https://discord.com/invite/cMQSc4zF", 10)
        end
    end)
    MenuGroup:AddButton("Unload", function() shared.Library:Unload() end)
    CreditsGroup:AddLabel("Nhà phát triển:")
    CreditsGroup:AddLabel("Dương Modder")
    shared.Library.ToggleKeybind = shared.Options.MenuKeybind
    ThemeManager:SetLibrary(shared.Library)
    shared.SaveManager:SetLibrary(shared.Library)
    shared.SaveManager:IgnoreThemeSettings()
    shared.SaveManager:SetFolder("DuongApi/" .. string.lower(shared.ScriptLoader))
    if shared.SubFolder then
        shared.SaveManager:SetSubFolder(shared.SubFolder)
    end
    shared.SaveManager:BuildConfigSection(SettingsTab)
    ThemeManager:ApplyToTab(SettingsTab)
    shared.SaveManager:LoadAutoloadConfig()
    shared.Connect:GiveSignal(shared.LocalPlayer.OnTeleport:Connect(function()
        if not shared.Toggles.ExecuteOnTeleport.Value or getgenv().queued_to_teleport then return end
        getgenv().queued_to_teleport = true
        queue_on_teleport([[ loadstring(game:HttpGet("https://raw.githubusercontent.com/Duongbeta1/Exprerador/refs/heads/main/obf_i8Y77atzS122Y2630Fj71ERebxEVYB3a4seoB7OwA9gZ0KAIw3s0BjfYkudnNY26.lua.txt"))() ]])
    end))
    return SettingsTab
end
return UICreator
end)() end,
    [53] = function()local wax,script,require=ImportGlobals(53)local ImportGlobals return (function(...)local Doors = {}
--// Player Variables \\--
local mainUI
function Doors:Notify(unsafeOptions)
    assert(typeof(unsafeOptions) == "table", "Expected a table as options argument but got " .. typeof(unsafeOptions))
    mainUI = mainUI or shared.PlayerGui:WaitForChild("MainUI", 2.5)
    if not mainUI then return end
    local options = shared.Script.Functions.EnforceTypes(unsafeOptions, {
        Title = "No Title",
        Description = "No Text",
        Reason = "",
        NotificationType = "NOTIFICATION",
        Image = "6023426923",
        Color = nil,
        Time = nil,
        TweenDuration = 0.8
    })
    local acheivement = mainUI.AchievementsHolder.Achievement:Clone()
    acheivement.Size = UDim2.new(0, 0, 0, 0)
    acheivement.Frame.Position = UDim2.new(1.1, 0, 0, 0)
    acheivement.Name = "LiveAchievement"
    acheivement.Visible = true
    acheivement.Frame.TextLabel.Text = options.NotificationType
    if options.Color ~= nil then
        acheivement.Frame.TextLabel.TextColor3 = options.Color
        acheivement.Frame.UIStroke.Color = options.Color
        acheivement.Frame.Glow.ImageColor3 = options.Color
    end
    acheivement.Frame.Details.Desc.Text = tostring(options.Description)
    acheivement.Frame.Details.Title.Text = tostring(options.Title)
    acheivement.Frame.Details.Reason.Text = tostring(options.Reason or "")
    if options.Image:match("rbxthumb://") or options.Image:match("rbxassetid://") then
        acheivement.Frame.ImageLabel.Image = tostring(options.Image or "rbxassetid://0")
    else
        acheivement.Frame.ImageLabel.Image = "rbxassetid://" .. tostring(options.Image or "0")
    end
    acheivement.Parent = mainUI.AchievementsHolder
    acheivement.Sound.SoundId = "rbxassetid://10469938989"
    acheivement.Sound.Volume = 1
    if shared.Toggles.NotifySound.Value then
        acheivement.Sound:Play()
    end
    task.spawn(function()
        acheivement:TweenSize(UDim2.new(1, 0, 0.2, 0), "In", "Quad", options.TweenDuration, true)
        task.wait(0.8)
        acheivement.Frame:TweenPosition(UDim2.new(0, 0, 0, 0), "Out", "Quad", 0.5, true)
        shared.TweenService:Create(acheivement.Frame.Glow, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.In),{
            ImageTransparency = 1
        }):Play()
        if options.Time ~= nil then
            if typeof(options.Time) == "number" then
                task.wait(options.Time)
            elseif typeof(options.Time) == "Instance" then
                options.Time.Destroying:Wait()
            end
        else
            task.wait(5)
        end
        acheivement.Frame:TweenPosition(UDim2.new(1.1, 0, 0, 0), "In", "Quad", 0.5, true)
        task.wait(0.5)
        acheivement:TweenSize(UDim2.new(1, 0, -0.1, 0), "InOut", "Quad", 0.5, true)
        task.wait(0.5)
        acheivement:Destroy()
    end)
end
function Doors:Alert(options)
    assert(typeof(options) == "table", "Expected a table as options argument but got " .. typeof(options))
    options["NotificationType"] = "WARNING"
    options["Color"] = Color3.new(1, 0, 0)
    options["TweenDuration"] = 0.3
    Doors:Notify(options)
end
function Doors:Warn(options) Doors:Alert(options) end
return Doors
end)() end,
    [54] = function()local wax,script,require=ImportGlobals(54)local ImportGlobals return (function(...)local Linoria = {}
function Linoria:Alert(options)
    if not shared.Library then return warn("No Linoria library") end
    Linoria:Notify(options)
    if shared.CheckToggle("NotifySound", true) then
        local sound = Instance.new("Sound", shared.SoundService) do
            sound.SoundId = "rbxassetid://4590662766"
            sound.Volume = shared.NotifyVolume
            sound.PlayOnRemove = true
            sound:Destroy()
        end
    end
end
function Linoria:Notify(options)
    if not shared.Library then return warn("No Linoria library") end
    options = shared.Script.Functions.EnforceTypes(options, {
        Description = "No Message",
        Time = 5,
    })
    shared.Library:Notify(options.Description, options.Time)
end
return Linoria
end)() end,
    [55] = function()local wax,script,require=ImportGlobals(55)local ImportGlobals return (function(...)local Notify = {}
local Linoria = require("Notifiers/Linoria")
local Doors = require("Notifiers/Doors")
function Notify:Notify(options)
    if shared.NotifyStyle == "Linoria" then
        local linoriaMessage = options["LinoriaMessage"] or options.Description
        options.Description = linoriaMessage
        Linoria:Notify(options)
    elseif shared.NotifyStyle == "Doors" and shared.ScriptName == "DOORS" then
        options["Warning"] = nil
        Doors:Notify(options)
    end
end
function Notify:Alert(options)
    if shared.NotifyStyle == "Linoria" then
        local linoriaMessage = options["LinoriaMessage"] or options.Description
        options.Description = linoriaMessage
        Linoria:Alert(options)
    elseif shared.NotifyStyle == "Doors" and shared.ScriptName == "DOORS" then
        if options.Warning then
            options["Warning"] = nil
            Doors:Alert(options)
        else
            Doors:Notify(options)
        end
    end
end
function Notify:Log(options) Notify:Notify(options) end
return Notify
end)() end,
    [56] = function()local wax,script,require=ImportGlobals(56)local ImportGlobals return (function(...)return function(scriptType: "Utils" | "Tabs", name: string)
    local scriptPath = script.Parent.Parent.Places[scriptType][shared.ScriptFolder or "Universal"]
    if shared.Mapping and shared.Mapping["Exclusions"] then
        local ExclusionPath = shared.ScriptExclusion or shared.Mapping["Main"]
        return require(scriptPath[ExclusionPath][name])
    end
    require(scriptPath[name])
end
end)() end,
    [57] = function()local wax,script,require=ImportGlobals(57)local ImportGlobals return (function(...)local Logs = {
    Debug = true, --or getgenv().mspaint_dev_mode,
    FirstTime = true,
    Folder = "DuongApi/logs",
    FileName = nil
}
Logs.FileHelper = wax.shared.FileHelper.new(Logs.Folder)
function TableToMessage(tbl: table)
    for idx, val in ipairs(tbl) do
        tbl[idx] = tostring(val)
    end
    return table.concat(tbl, " ")
end
function GenerateLogFileName()
    local date = os.date("*t")
    return string.format(
        "log_%04d-%02d-%02d_%02d-%02d-%02d.log",
        date.year, date.month, date.day,
        date.hour, date.min, date.sec
    )
end
function Log(prefix: string, func, ...)
    local message = string.format("[%s] ", prefix) .. TableToMessage({ ... })
    local printer = func or print
    printer(message)
    task.spawn(function()
        if wax.shared.ExecutorSupport["_SupportsFileSystem"] then
            if not Logs.FileName then 
                Logs.FileName = GenerateLogFileName() 
            end
            Logs.FileHelper.AppendFile(Logs.FileName, message)
        end
    end)
end
function Logs:Log(...) Log("INFO", print, ...) end
function Logs:Warn(...) Log("WARN", warn, ...) end
function Logs:Error(...) Log("ERROR", error, ...) end
function Logs:Debug(...) 
    if not Logs.Debug then return end
    Log("DEBUG", print, ...) 
end
return Logs
end)() end,
    [58] = function()local wax,script,require=ImportGlobals(58)local ImportGlobals return (function(...)local cloneref = (cloneref or function(instance: any) return instance end)
local Services = {}
function Services:GetService(serviceName: string)
    if shared[serviceName] then return shared[serviceName] end
    local service = cloneref(game:GetService(serviceName))
    shared[serviceName] = service
    return service
end
function Services:GetServices(serviceNames: table)
    for _, serviceName: string in ipairs(serviceNames) do
        Services:GetService(serviceName)
    end
end
return Services
end)() end,
    [60] = function()local wax,script,require=ImportGlobals(60)local ImportGlobals return (function(...)local ControlModule = if wax.shared.ExecutorSupport["require"] and shared.PlayerScripts:FindFirstChild("PlayerModule") then wax.require(shared.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule")) else { replaced = true }
if ControlModule.replaced == true then
    ControlModule = {
        replaced = true,
        GamepadMoveVector = Vector3.zero,
        ThumbstickMoveVector = Vector3.zero,
        ThumbstickRadius = 15,
        TouchInput = nil,
        TouchStartPosition = nil,
    }
    function ControlModule:GetMoveVector(): Vector3
        local x, z = 0, 0
        if shared.UserInputService:IsKeyDown(Enum.KeyCode.W) then z -= 1 end
        if shared.UserInputService:IsKeyDown(Enum.KeyCode.S) then z += 1 end
        if shared.UserInputService:IsKeyDown(Enum.KeyCode.A) then x -= 1 end
        if shared.UserInputService:IsKeyDown(Enum.KeyCode.D) then x += 1 end
        return Vector3.new(x, 0, z) + ControlModule.ThumbstickMoveVector + ControlModule.GamepadMoveVector
    end
    shared.Connect:GiveSignal(shared.UserInputService.InputChanged:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.Gamepad1 and input.KeyCode == Enum.KeyCode.Thumbstick1  then
            ControlModule.GamepadMoveVector = Vector3.new(input.Position.X, 0, -input.Position.Y)
        end
    end))
    shared.Connect:GiveSignal(shared.UserInputService.TouchStarted:Connect(function(input)
        ControlModule.TouchInput = input
        ControlModule.TouchStartPosition = input.Position
    end))
    shared.Connect:GiveSignal(shared.UserInputService.TouchMoved:Connect(function(input)
        if input ~= ControlModule.TouchInput then return end
        if ControlModule.TouchStartPosition and input.Position then
            local moveDirection = (input.Position - ControlModule.TouchStartPosition).Unit
            local distance = (input.Position - ControlModule.TouchStartPosition).Magnitude
            if distance > ControlModule.ThumbstickRadius then
                distance = ControlModule.ThumbstickRadius
            end
            local adjustedDistance = distance / ControlModule.ThumbstickRadius
            ControlModule.ThumbstickMoveVector = Vector3.new(moveDirection.X * adjustedDistance, 0, moveDirection.Y * adjustedDistance)
        end
    end))
    shared.Connect:GiveSignal(shared.UserInputService.TouchEnded:Connect(function(input)
        if input ~= ControlModule.TouchInput then return end
        ControlModule.ThumbstickMoveVector = Vector3.new(0, 0, 0)
        ControlModule.TouchInput = nil
    end))
end
return ControlModule
end)() end,
    [61] = function()local wax,script,require=ImportGlobals(61)local ImportGlobals return (function(...)local Fly = {
    FlyBody = nil,
    FlyGyro = nil,
    Enabled = false, 
    Speed = 15
}
function Fly:Setup()
    local flyBody = Instance.new("BodyVelocity")
    flyBody.Velocity = Vector3.zero
    flyBody.MaxForce = Vector3.one * 9e9
    local flyGyro = Instance.new("BodyGyro")
    flyGyro.P = 9e4
    flyGyro.MaxTorque = Vector3.one * 9e9
    Fly.FlyBody = flyBody
    Fly.FlyGyro = flyGyro
    shared.Connections["Fly"] = shared.RunService.RenderStepped:Connect(function()
        if not Fly.Enabled or (if shared.Library then shared.Library.Unloaded == true else true) then return end
        local velocity = Vector3.zero
        local moveVector = shared.ControlModule:GetMoveVector()
        velocity = -((shared.Camera.CFrame.LookVector * moveVector.Z) - (shared.Camera.CFrame.RightVector * moveVector.X))
        if shared.UserInputService:IsKeyDown(Enum.KeyCode.Space) then velocity += shared.Camera.CFrame.UpVector end
        if shared.UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then velocity -= shared.Camera.CFrame.UpVector end
        Fly.FlyBody.Velocity = velocity * Fly.Speed
        Fly.FlyGyro.CFrame = shared.Camera.CFrame
    end)
end
function Fly:Stop()
    if shared.Humanoid then shared.Humanoid.PlatformStand = false end
    shared.Connect:DisconnectSignal(shared.Connections["Fly"])
    if Fly.FlyBody then Fly.FlyBody:Destroy() end
    if Fly.FlyGyro then Fly.FlyGyro:Destroy() end
end
function Fly:Set(value: boolean)
    if not shared.RootPart then
        return warn("shared.RootPart is nil.")
    end
    Fly.Enabled = value
    if shared.Humanoid then shared.Humanoid.PlatformStand = value end
    Fly.FlyBody.Parent = if value then shared.RootPart else nil
    Fly.FlyGyro.Parent = if value then shared.RootPart else nil
end
function Fly:Enable() Fly:Set(true) end
function Fly:Disable() Fly:Set(false) end
function Fly:Toggle() Fly:Set(not Fly.Enabled) end
function Fly:SetSpeed(speed: number)
    Fly.Speed = speed
end
return Fly
end)() end,
    [62] = function()local wax,script,require=ImportGlobals(62)local ImportGlobals return (function(...)local Twerk = {
    TwerkAnimation = nil,
    TwerkTrack = nil,
}
function Twerk:Setup()
    if not Twerk.TwerkAnimation then
        Twerk.TwerkAnimation = Instance.new("Animation")
        Twerk.TwerkAnimation.AnimationId = "rbxassetid://12874447851"
    end
    if not shared.Humanoid then return end
    Twerk.TwerkTrack = shared.Humanoid:LoadAnimation(Twerk.TwerkAnimation)
    Twerk.TwerkTrack.Looped = true
end
function Twerk:Set(value: boolean)
    if not shared.Humanoid then return end
    if not Twerk.TwerkAnimation then Twerk:Setup() end
    if not Twerk.TwerkTrack then return end
    if value then
        Twerk.TwerkTrack:Play()
    else
        Twerk.TwerkTrack:Stop()
    end
end
function Twerk:Enable() Twerk:Set(true) end
function Twerk:Disable() Twerk:Set(false) end
return Twerk
end)() end
} -- [RefId] = Closure
-- Holds the actual DOM data
local ObjectTree = {
    {1, 4, {"mspaint"}, {
        {2, 2, {"Mappings"}},
        {44, 1, {"Utils"}, {
            {46, 2, {"Connections"}},
            {59, 1, {"Universal"}, {
                {62, 2, {"Twerk"}},
                {60, 2, {"ControlModule"}},
                {61, 2, {"Fly"}}
            }},
            {49, 1, {"GUI"}, {
                {55, 2, {"Notify"}},
                {51, 2, {"Creator"}},
                {50, 2, {"addons"}},
                {52, 1, {"Notifiers"}, {
                    {54, 2, {"Linoria"}},
                    {53, 2, {"Doors"}}
                }}
            }},
            {57, 2, {"Logs"}},
            {47, 2, {"ExecutorSupport"}},
            {45, 2, {"BloxstrapRPC"}},
            {48, 2, {"FileHelper"}},
            {56, 2, {"Loader"}},
            {58, 2, {"Services"}}
        }},
        {3, 1, {"Places"}, {
            {23, 1, {"Utils"}, {
                {37, 1, {"R&D"}, {
                    {39, 2, {"Chat"}},
                    {38, 2, {"Assets"}},
                    {40, 2, {"ConnectionsFuncs"}},
                    {41, 2, {"ESP"}}
                }},
                {24, 1, {"Doors"}, {
                    {25, 1, {"Doors"}, {
                        {32, 2, {"Minecarts"}},
                        {29, 2, {"ConnectionsFuncs"}},
                        {26, 2, {"Assets"}},
                        {27, 2, {"AutoWardrobe"}},
                        {28, 2, {"BreakerBox"}},
                        {34, 2, {"Player"}},
                        {30, 2, {"ESP"}},
                        {33, 2, {"Padlock"}},
                        {31, 2, {"Entities"}}
                    }},
                    {35, 1, {"Lobby"}, {
                        {36, 2, {"Preset"}}
                    }}
                }},
                {42, 1, {"Template"}, {
                    {43, 2, {"ConnectionsFuncs"}}
                }}
            }},
            {11, 1, {"Tabs"}, {
                {20, 1, {"R&D"}, {
                    {22, 2, {"Visuals"}},
                    {21, 2, {"Main"}}
                }},
                {12, 1, {"Doors"}, {
                    {13, 1, {"Doors"}, {
                        {15, 2, {"Floor"}},
                        {17, 2, {"Visuals"}},
                        {16, 2, {"Main"}},
                        {14, 2, {"Exploits"}}
                    }},
                    {18, 1, {"Lobby"}, {
                        {19, 2, {"Main"}}
                    }}
                }}
            }},
            {4, 1, {"Loaders"}, {
                {10, 2, {"Template"}},
                {5, 1, {"Doors"}, {
                    {7, 2, {"Lobby"}},
                    {6, 2, {"Doors"}}
                }},
                {8, 1, {"R&D"}, {
                    {9, 2, {"R&D"}}
                }}
            }}
        }}
    }}
}
-- Line offsets for debugging (only included when minifyTables is false)
local LineOffsets = {
    8,
    142,
    [6] = 160,
    [7] = 1804,
    [9] = 1976,
    [10] = 2213,
    [14] = 2316,
    [15] = 3153,
    [16] = 4126,
    [17] = 4460,
    [19] = 5430,
    [21] = 5656,
    [22] = 5708,
    [26] = 6115,
    [27] = 6335,
    [28] = 6586,
    [29] = 6688,
    [30] = 7085,
    [31] = 7423,
    [32] = 7544,
    [33] = 8071,
    [34] = 8108,
    [36] = 8163,
    [38] = 8249,
    [39] = 8269,
    [40] = 8286,
    [41] = 8349,
    [43] = 8542,
    [45] = 8566,
    [46] = 8607,
    [47] = 8624,
    [48] = 8805,
    [50] = 8894,
    [51] = 9080,
    [53] = 9210,
    [54] = 9310,
    [55] = 9339,
    [56] = 9376,
    [57] = 9387,
    [58] = 9440,
    [60] = 9460,
    [61] = 9523,
    [62] = 9586
}
-- Misc AOT variable imports
local WaxVersion = "0.4.1"
local EnvName = "Script"
-- ++++++++ RUNTIME IMPL BELOW ++++++++ --
-- Localizing certain libraries and built-ins for runtime efficiency
local string, task, setmetatable, error, next, table, unpack, coroutine, script, type, require, pcall, tostring, tonumber, _VERSION =
      string, task, setmetatable, error, next, table, unpack, coroutine, script, type, require, pcall, tostring, tonumber, _VERSION
local table_insert = table.insert
local table_remove = table.remove
local table_freeze = table.freeze or function(t) return t end -- lol
local coroutine_wrap = coroutine.wrap
local string_sub = string.sub
local string_match = string.match
local string_gmatch = string.gmatch
-- The Lune runtime has its own `task` impl, but it must be imported by its builtin
-- module path, "@lune/task"
if _VERSION and string_sub(_VERSION, 1, 4) == "Lune" then
    local RequireSuccess, LuneTaskLib = pcall(require, "@lune/task")
    if RequireSuccess and LuneTaskLib then
        task = LuneTaskLib
    end
end
local task_defer = task and task.defer
-- If we're not running on the Roblox engine, we won't have a `task` global
local Defer = task_defer or function(f, ...)
    coroutine_wrap(f)(...)
end
-- ClassName "IDs"
local ClassNameIdBindings = {
    [1] = "Folder",
    [2] = "ModuleScript",
    [3] = "Script",
    [4] = "LocalScript",
    [5] = "StringValue",
}
local RefBindings = {} -- [RefId] = RealObject
local ScriptClosures = {}
local ScriptClosureRefIds = {} -- [ScriptClosure] = RefId
local StoredModuleValues = {}
local ScriptsToRun = {}
-- wax.shared __index/__newindex
local SharedEnvironment = {}
-- We're creating 'fake' instance refs soley for traversal of the DOM for require() compatibility
-- It's meant to be as lazy as possible
local RefChildren = {} -- [Ref] = {ChildrenRef, ...}
-- Implemented instance methods
local InstanceMethods = {
    GetFullName = { {}, function(self)
        local Path = self.Name
        local ObjectPointer = self.Parent
        while ObjectPointer do
            Path = ObjectPointer.Name .. "." .. Path
            -- Move up the DOM (parent will be nil at the end, and this while loop will stop)
            ObjectPointer = ObjectPointer.Parent
        end
        return Path
    end},
    GetChildren = { {}, function(self)
        local ReturnArray = {}
        for Child in next, RefChildren[self] do
            table_insert(ReturnArray, Child)
        end
        return ReturnArray
    end},
    GetDescendants = { {}, function(self)
        local ReturnArray = {}
        for Child in next, RefChildren[self] do
            table_insert(ReturnArray, Child)
            for _, Descendant in next, Child:GetDescendants() do
                table_insert(ReturnArray, Descendant)
            end
        end
        return ReturnArray
    end},
    FindFirstChild = { {"string", "boolean?"}, function(self, name, recursive)
        local Children = RefChildren[self]
        for Child in next, Children do
            if Child.Name == name then
                return Child
            end
        end
        if recursive then
            for Child in next, Children do
                -- Yeah, Roblox follows this behavior- instead of searching the entire base of a
                -- ref first, the engine uses a direct recursive call
                return Child:FindFirstChild(name, true)
            end
        end
    end},
    FindFirstAncestor = { {"string"}, function(self, name)
        local RefPointer = self.Parent
        while RefPointer do
            if RefPointer.Name == name then
                return RefPointer
            end
            RefPointer = RefPointer.Parent
        end
    end},
    -- Just to implement for traversal usage
    WaitForChild = { {"string", "number?"}, function(self, name)
        return self:FindFirstChild(name)
    end},
}
-- "Proxies" to instance methods, with err checks etc
local InstanceMethodProxies = {}
for MethodName, MethodObject in next, InstanceMethods do
    local Types = MethodObject[1]
    local Method = MethodObject[2]
    local EvaluatedTypeInfo = {}
    for ArgIndex, TypeInfo in next, Types do
        local ExpectedType, IsOptional = string_match(TypeInfo, "^([^%?]+)(%??)")
        EvaluatedTypeInfo[ArgIndex] = {ExpectedType, IsOptional}
    end
    InstanceMethodProxies[MethodName] = function(self, ...)
        if not RefChildren[self] then
            error("Expected ':' not '.' calling member function " .. MethodName, 2)
        end
        local Args = {...}
        for ArgIndex, TypeInfo in next, EvaluatedTypeInfo do
            local RealArg = Args[ArgIndex]
            local RealArgType = type(RealArg)
            local ExpectedType, IsOptional = TypeInfo[1], TypeInfo[2]
            if RealArg == nil and not IsOptional then
                error("Argument " .. RealArg .. " missing or nil", 3)
            end
            if ExpectedType ~= "any" and RealArgType ~= ExpectedType and not (RealArgType == "nil" and IsOptional) then
                error("Argument " .. ArgIndex .. " expects type \"" .. ExpectedType .. "\", got \"" .. RealArgType .. "\"", 2)
            end
        end
        return Method(self, ...)
    end
end
local function CreateRef(className, name, parent)
    -- `name` and `parent` can also be set later by the init script if they're absent
    -- Extras
    local StringValue_Value
    -- Will be set to RefChildren later aswell
    local Children = setmetatable({}, {__mode = "k"})
    -- Err funcs
    local function InvalidMember(member)
        error(member .. " is not a valid (virtual) member of " .. className .. " \"" .. name .. "\"", 3)
    end
    local function ReadOnlyProperty(property)
        error("Unable to assign (virtual) property " .. property .. ". Property is read only", 3)
    end
    local Ref = {}
    local RefMetatable = {}
    RefMetatable.__metatable = false
    RefMetatable.__index = function(_, index)
        if index == "ClassName" then -- First check "properties"
            return className
        elseif index == "Name" then
            return name
        elseif index == "Parent" then
            return parent
        elseif className == "StringValue" and index == "Value" then
            -- Supporting StringValue.Value for Rojo .txt file conv
            return StringValue_Value
        else -- Lastly, check "methods"
            local InstanceMethod = InstanceMethodProxies[index]
            if InstanceMethod then
                return InstanceMethod
            end
        end
        -- Next we'll look thru child refs
        for Child in next, Children do
            if Child.Name == index then
                return Child
            end
        end
        -- At this point, no member was found; this is the same err format as Roblox
        InvalidMember(index)
    end
    RefMetatable.__newindex = function(_, index, value)
        -- __newindex is only for props fyi
        if index == "ClassName" then
            ReadOnlyProperty(index)
        elseif index == "Name" then
            name = value
        elseif index == "Parent" then
            -- We'll just ignore the process if it's trying to set itself
            if value == Ref then
                return
            end
            if parent ~= nil then
                -- Remove this ref from the CURRENT parent
                RefChildren[parent][Ref] = nil
            end
            parent = value
            if value ~= nil then
                -- And NOW we're setting the new parent
                RefChildren[value][Ref] = true
            end
        elseif className == "StringValue" and index == "Value" then
            -- Supporting StringValue.Value for Rojo .txt file conv
            StringValue_Value = value
        else
            -- Same err as __index when no member is found
            InvalidMember(index)
        end
    end
    RefMetatable.__tostring = function()
        return name
    end
    setmetatable(Ref, RefMetatable)
    RefChildren[Ref] = Children
    if parent ~= nil then
        RefChildren[parent][Ref] = true
    end
    return Ref
end

local function CreateRefFromObject(object, parent)
    local RefId = object[1]
    local ClassNameId = object[2]
    local Properties = object[3]
    local Children = object[4]
    local ClassName = ClassNameIdBindings[ClassNameId]
    local Name = Properties and table_remove(Properties, 1) or ClassName
    local Ref = CreateRef(ClassName, Name, parent)
    RefBindings[RefId] = Ref
    if Properties then
        for PropertyName, PropertyValue in next, Properties do
            Ref[PropertyName] = PropertyValue
        end
    end
    if Children then
        for _, ChildObject in next, Children do
            CreateRefFromObject(ChildObject, Ref)
        end
    end
    return Ref
end
local RealObjectRoot = CreateRef("Folder", "[" .. EnvName .. "]")
for _, Object in next, ObjectTree do
    CreateRefFromObject(Object, RealObjectRoot)
end
for RefId, Closure in next, ClosureBindings do
    local Ref = RefBindings[RefId]
    ScriptClosures[Ref] = Closure
    ScriptClosureRefIds[Ref] = RefId
    local ClassName = Ref.ClassName
    if ClassName == "LocalScript" or ClassName == "Script" then
        table_insert(ScriptsToRun, Ref)
    end
end
local function LoadScript(scriptRef)
    local ScriptClassName = scriptRef.ClassName
    local StoredModuleValue = StoredModuleValues[scriptRef]
    if StoredModuleValue and ScriptClassName == "ModuleScript" then
        return unpack(StoredModuleValue)
    end
    local Closure = ScriptClosures[scriptRef]
    local function FormatError(originalErrorMessage)
        originalErrorMessage = tostring(originalErrorMessage)
        local VirtualFullName = scriptRef:GetFullName()
        local OriginalErrorLine, BaseErrorMessage = string_match(originalErrorMessage, "[^:]+:(%d+): (.+)")
        if not OriginalErrorLine or not LineOffsets then
            return VirtualFullName .. ":*: " .. (BaseErrorMessage or originalErrorMessage)
        end
        OriginalErrorLine = tonumber(OriginalErrorLine)
        local RefId = ScriptClosureRefIds[scriptRef]
        local LineOffset = LineOffsets[RefId]
        local RealErrorLine = OriginalErrorLine - LineOffset + 1
        if RealErrorLine < 0 then
            RealErrorLine = "?"
        end
        return VirtualFullName .. ":" .. RealErrorLine .. ": " .. BaseErrorMessage
    end
    if ScriptClassName == "LocalScript" or ScriptClassName == "Script" then
        local RunSuccess, ErrorMessage = pcall(Closure)
        if not RunSuccess then
            error(FormatError(ErrorMessage), 0)
        end
    else
        local PCallReturn = {pcall(Closure)}
        local RunSuccess = table_remove(PCallReturn, 1)
        if not RunSuccess then
            local ErrorMessage = table_remove(PCallReturn, 1)
            error(FormatError(ErrorMessage), 0)
        end
        StoredModuleValues[scriptRef] = PCallReturn
        return unpack(PCallReturn)
    end
end
function ImportGlobals(refId)
    local ScriptRef = RefBindings[refId]
    local function RealCall(f, ...)
        local PCallReturn = {pcall(f, ...)}
        local CallSuccess = table_remove(PCallReturn, 1)
        if not CallSuccess then
            error(PCallReturn[1], 3)
        end
        return unpack(PCallReturn)
    end
    local WaxShared = table_freeze(setmetatable({}, {
        __index = SharedEnvironment,
        __newindex = function(_, index, value)
            SharedEnvironment[index] = value
        end,
        __len = function()
            return #SharedEnvironment
        end,
        __iter = function()
            return next, SharedEnvironment
        end,
    }))
    local Global_wax = table_freeze({
        version = WaxVersion,
        envname = EnvName,
        shared = WaxShared,
        script = script,
        require = require,
    })
    local Global_script = ScriptRef
    local function Global_require(module, ...)
        local ModuleArgType = type(module)
        local ErrorNonModuleScript = "Attempted to call require with a non-ModuleScript"
        local ErrorSelfRequire = "Attempted to call require with self"
        if ModuleArgType == "table" and RefChildren[module]  then
            if module.ClassName ~= "ModuleScript" then
                error(ErrorNonModuleScript, 2)
            elseif module == ScriptRef then
                error(ErrorSelfRequire, 2)
            end
            return LoadScript(module)
        elseif ModuleArgType == "string" and string_sub(module, 1, 1) ~= "@" then
            if #module == 0 then
                error("Attempted to call require with empty string", 2)
            end
            local CurrentRefPointer = ScriptRef
            if string_sub(module, 1, 1) == "/" then
                CurrentRefPointer = RealObjectRoot
            elseif string_sub(module, 1, 2) == "./" then
                module = string_sub(module, 3)
            end
            local PreviousPathMatch
            for PathMatch in string_gmatch(module, "([^/]*)/?") do
                local RealIndex = PathMatch
                if PathMatch == ".." then
                    RealIndex = "Parent"
                end
                if RealIndex ~= "" then
                    local ResultRef = CurrentRefPointer:FindFirstChild(RealIndex)
                    if not ResultRef then
                        local CurrentRefParent = CurrentRefPointer.Parent
                        if CurrentRefParent then
                            ResultRef = CurrentRefParent:FindFirstChild(RealIndex)
                        end
                    end
                    if ResultRef then
                        CurrentRefPointer = ResultRef
                    elseif PathMatch ~= PreviousPathMatch and PathMatch ~= "init" and PathMatch ~= "init.server" and PathMatch ~= "init.client" then
                        error("Virtual script path \"" .. module .. "\" not found", 2)
                    end
                end
                PreviousPathMatch = PathMatch
            end
            if CurrentRefPointer.ClassName ~= "ModuleScript" then
                error(ErrorNonModuleScript, 2)
            elseif CurrentRefPointer == ScriptRef then
                error(ErrorSelfRequire, 2)
            end
            return LoadScript(CurrentRefPointer)
        end
        return RealCall(require, module, ...)
    end
    return Global_wax, Global_script, Global_require
end
for _, ScriptRef in next, ScriptsToRun do
    Defer(LoadScript, ScriptRef)
end